<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Stay foolish Stay hungray">
<meta property="og:type" content="website">
<meta property="og:title" content="С�����ľ���">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="С�����ľ���">
<meta property="og:description" content="Stay foolish Stay hungray">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="С�����ľ���">
<meta name="twitter:description" content="Stay foolish Stay hungray">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>С�����ľ���</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">С�����ľ���</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">С�����ľ���</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/笔试面试（11）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/30/笔试面试（11）/" itemprop="url">笔试面试题（11）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T00:00:00+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基本知识/" itemprop="url" rel="index">
                    <span itemprop="name">基本知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/30/笔试面试（11）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/30/笔试面试（11）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/30/笔试面试（11）/" class="leancloud_visitors" data-flag-title="笔试面试题（11）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浏览器安全问题"><a href="#浏览器安全问题" class="headerlink" title="浏览器安全问题"></a>浏览器安全问题</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。简单的说就是<strong>一个源的页面上的js只能访问当前源的资源，不能访问其他源的资源</strong>。</p>
<p>那么资源是什么呢？<strong>DOM，通过AJAX请求的网络资源，Cookie，WebStorage，webSql</strong>。</p>
<h3 id="XSS-Cross-Site-Script"><a href="#XSS-Cross-Site-Script" class="headerlink" title="XSS(Cross-Site Script)"></a>XSS(Cross-Site Script)</h3><p>跨站脚本攻击本质上是一种注入攻击（有兴趣了解更多注入攻击可以看这里）。其原理，简单的说就是利用各种手段把恶意代码添加到网页中，并让受害者执行这段脚本，可对用户盗取cookie信息，会话劫持等各种攻击。主要包括client(客户端型)，server(服务端型)两大类型错误。</p>
<p>无论是服务端型还是客户端型xss，攻击达成需要两个条件</p>
<p>（1）代码被注入</p>
<p>（2）代码被执行</p>
<p>其实只要做好无论任何情况下<strong>保证代码不被执行就能完全杜绝xss攻击</strong>。常见做法就是将不受信任的代码进行转义</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>(1) 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。后台服务器需要在接收到用户输入的数据后，对特殊危险字符进行过滤或者转义处理，然后再存储到数据库中</p>
<p>(2) 输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击</p>
<p>(3)(4) HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。<strong>Web应用程序在设置cookie时</strong>，将其属性设为HttpOnly</p>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>将SQL命令插入到<strong>Web表单提交</strong>或<strong>输入域名</strong>或<strong>页面请求的查询字符串</strong>，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>常用防范方法：</p>
<p>（1）数据转义。设置php.ini选项magic_quotes_gpc=on，它会将提交的变量中所有的’(单引号)，”(双引号)，(反斜杠)，空白字符等都在前面自动加上\。或者采用mysql_real_escape()函数或addslashes()函数进行输入参数的转义。</p>
<p>（2）增加黑名单或者白名单验证。白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。</p>
<h3 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h3><p>Webpack + react 文件打包出来过大，动则几百k上兆（bundle.js : 852kb.）。</p>
<p>问题分析：</p>
<p>（1）在使用 import css 的时候，Webpack Css 直接作为模块打包到js中。</p>
<p>（2）所有Js 模块 + 依赖都会打包到一个文件，导致文件很大。</p>
<p>（3）React、React-dom 文件过大</p>
<p>解决方案：</p>
<p>（1）分离 css 文件,将css 单独打包（bundle.css – 56kb bundle.js -796kb）</p>
<p>（2）那么就从 react 上入手，发现react 里面存在很多注释，警告等，是一个开发版本。那么如何切换成生产版本呢？通过 webpack.DefinePlugin 的process.env 来切换成生产版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">new webpack.DefinePlugin(&#123;</div><div class="line">    &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(process.env.NODE_ENV),</div><div class="line">    &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="解决加载过慢的问题"><a href="#解决加载过慢的问题" class="headerlink" title="解决加载过慢的问题"></a>解决加载过慢的问题</h3><h4 id="从webpack入手，webpack本身会有一些插件的优化方法"><a href="#从webpack入手，webpack本身会有一些插件的优化方法" class="headerlink" title="从webpack入手，webpack本身会有一些插件的优化方法"></a>从webpack入手，webpack本身会有一些插件的优化方法</h4><p>1.UglifyJsPlugin 压缩代码的插件(这个可以很显著的缩小包的体积）。<code>new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } })</code></p>
<p>2.CommonsChunkPlugin (合并代码)：两个用法，一个是抽取公共的包，另一个则是把多个保重的公共依赖抽取出来</p>
<h4 id="从代码层面入手"><a href="#从代码层面入手" class="headerlink" title="从代码层面入手"></a>从代码层面入手</h4><p>首先你应该要知道code splitting这个东西，这个是代码层面优化的根基。code splitting，就是代码分割，就是代码分割成一个个小块，每次页面加载时，我只需要加载那些我需要的部分(加载包的体积变小了)，这样可以让页面加载的更快。通过webpack简而言之实现按需加载。</p>
<p>从实际代码入手如何实现呢？</p>
<p>借助工具：<code>npm install webpack-visualizer-plugin webpack-stats-plugin --save-dev</code></p>
<p>分析代码结构，这样就可以分析出你到底是什么导致你bundle.js报如此之大了，但有一些包我们是无法缩减的，例如react-dom,react,但是绝大部分的包都是可以进行缩减的。</p>
<p>流程：！[]<a href="https://segmentfault.com/a/1190000009792759" target="_blank" rel="external">https://segmentfault.com/a/1190000009792759</a></p>
<p>比如：加入你这个界面中用到了一个三方的图形控件Echart,那么这个包总是很大的，即使是最小的也有300k左右，其实你其他的代码可能都不到100k，那么这300k将会非常影响你这个界面的加载速度，所以需要给这个<strong>控件做一个按需加载</strong>，这样可以先展示其余的这100k所展示的界面，等待其余的300k下载好了再把Echart给补上。</p>
<p>通过服务器对代码进行gzip压缩</p>
<p>服务器端渲染</p>
<h2 id="跨域的实现方式"><a href="#跨域的实现方式" class="headerlink" title="跨域的实现方式"></a>跨域的实现方式</h2><p><em>由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。</em></p>
<p>（1）JSONP<br>这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制（所谓同源是指所请求的主机，域名，协议，端口与当前相同），同时资源加载到页面后会立即执行。具体来说就是本站脚本创建一个<script>元素，地址指向第三方的API网址，形如：<code>&lt;script src=&quot;http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt;</code>并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。   </p>
<p>第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：<code>callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;})</code>这样浏览器会调用callback函数，并传递解析后json对象作为参数，，客户端即可拿到数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function json(jsonObj) &#123;</div><div class="line">   //dosomthing</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用jsonHandle，传入地址、追加参数，服务器端返回js代码，</div><div class="line">// 并调用客户端写好的json方法并把json数据传入进来。</div><div class="line">function jsonHandle(url) &#123;</div><div class="line">    var script = document.createElement(&quot;script&quot;);</div><div class="line">    script.setAttribute(&quot;src&quot;,url);</div><div class="line">    document.body.appendChild(script);</div><div class="line"></div><div class="line">    // 防止 script 标签冗余</div><div class="line">    if(oScript) &#123;</div><div class="line">      document.body.removeChild(oScript);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(2)通过修改document.domain来跨<strong>子域</strong></p>
<p>在页面<a href="http://www.example.com/a.html">http://www.example.com/a.html</a> 上设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">document.domain = &apos;example.com&apos;;</div><div class="line">var ifr = document.createElement(&apos;iframe&apos;);</div><div class="line">ifr.src = &apos;http://example.com/b.html&apos;;</div><div class="line">ifr.style.display = &apos;none&apos;;</div><div class="line">document.body.appendChild(ifr);</div><div class="line">ifr.onload = function()&#123;</div><div class="line">    var doc = ifr.contentDocument || ifr.contentWindow.document;</div><div class="line">    // 在这里操纵b.html</div><div class="line">    alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>同时，在页面<a href="http://example.com/b.html上设置`document.domain">http://example.com/b.html上设置`document.domain</a> = ‘a.com’`</p>
<p>##　安全性问题</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>所谓SQL注入，就是<strong>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串</strong>，最终达到欺骗服务器执行恶意的SQL命令。<br>具体来说，它是利用现有应用程序，将(恶意)的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入(恶意)SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p>
<h3 id="Xss"><a href="#Xss" class="headerlink" title="Xss"></a>Xss</h3><p><strong>Xss表示Cross Site Scripting(跨站脚本攻击)</strong>。它与SQL注入攻击类似，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在Xss攻击中，通过插入恶意脚本，实现对用户浏览器的控制。它是不会对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本</p>
<p>现代web开发框架如vue.js、react.js等，在设计的时候就考虑了Xss攻击<strong>对html插值进行了更进一步的抽象、过滤和转义（转义安全字符）</strong>，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。</p>
<p>同时，<strong>许多基于MVVM框架的SPA（单页应用）不需要刷新URL来控制view，这样大大防止了XSS隐患</strong>。</p>
<h3 id="Csrf"><a href="#Csrf" class="headerlink" title="Csrf"></a>Csrf</h3><p>跨站点请求伪造：对于未被授权系统有权访问的某个资源的情况。</p>
<p>解决方法：</p>
<p>1.验证发送的请求者是否有权限访问相应的资源，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。</p>
<p>2.关键操作只接受POST请求</p>
<p>3.Token：目前主流的做法是使用<code>Token</code>抵御 CSRF 攻击。下面通过分析<code>CSRF</code>攻击来理解为什么 Token 能够有效CSRF攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击。</p>
<p>另一个更通用的做法是保持原有参数不变，另外添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。</p>
<p>Token 使用原则:</p>
<p>Token 要足够随机————只有这样才算不可预测</p>
<p>Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度</p>
<p>Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中</p>
<h2 id="HTTP最常见的响应头如下所示"><a href="#HTTP最常见的响应头如下所示" class="headerlink" title="HTTP最常见的响应头如下所示"></a>HTTP最常见的响应头如下所示</h2><p> Allow：服务器支持哪些请求方法（如GET、POST等）；</p>
<p>Content-Encoding： 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档 的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</p>
<p>Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入<code>ByteArrayOutputStram</code>，完成后查看其大小，然后把该值放入Content-Length头，最后通过 <code>byteArrayStream.writeTo(response.getOutputStream())</code>发送内容；</p>
<p>Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。可在web.xml文件中 配置扩展名和MIME类型的对应关系；</p>
<p>Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</p>
<p>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p>
<p>Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</p>
<p>Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</p>
<p>Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的`">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的`</a><META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path"><code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置 Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续 刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是</code><META HTTP-EQUIV="Refresh" ...>`。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>关于定时器要记住的最重要的一点是：指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时执行代码。</p>
<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>DOM操作比起非DOM交互需要更多的内存和CPU时间，其高频率的更改有可能使得浏览器崩溃。可以使用定时器对该函数进行<strong>节流</strong></p>
<p>函数节流背后的基本思想指的是：<strong>某些代码不可以在没有间断的情况下连续重复执行</strong>。节流函数形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function throttle(method,context)&#123;</div><div class="line">	clearTimeout(method.tId);</div><div class="line">	method.tId=setTimeout(function()&#123;</div><div class="line">		method.call(context)</div><div class="line">	&#125;,100)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的两个参数为：1.要执行的函数 2.在那个作用域中执行。节流在resize函数中使用的最为频繁。当代码时周期性执行的时候，都应该使用节流。</p>
</script></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/25/笔试面试（10）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/25/笔试面试（10）/" itemprop="url">笔试面试题（10）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-25T00:00:00+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基本知识/" itemprop="url" rel="index">
                    <span itemprop="name">基本知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/25/笔试面试（10）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/25/笔试面试（10）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/25/笔试面试（10）/" class="leancloud_visitors" data-flag-title="笔试面试题（10）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>前端流程：开发，测试，部署，就是把一整套前端工作流程中能用工具搞定的部分，用工具搞定。</p>
<p>目前来说，Web业务日益复杂化和多元化，前端开发已经由以WebPage模式为主转变为以WebApp模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个jQuery插件就能完成的了。工程复杂了就会产生许多问题，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？…</p>
<p>前端工程化主要应该从<strong>模块化、组件化、规范化、自动化</strong>四个方面来思考，下面一一展开。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>首先，组件化≠模块化。好多人对这两个概念有些混淆。<strong>模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</strong></p>
<p>从<strong>UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元</strong>，我们称之为组件。</p>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>目录结构的制定</p>
<p>编码规范</p>
<p>前后端接口规范</p>
<p>文档规范</p>
<p>组件管理</p>
<h2 id="垃圾回收机制的种类"><a href="#垃圾回收机制的种类" class="headerlink" title="垃圾回收机制的种类"></a>垃圾回收机制的种类</h2><p>函数中的局部变量的生命周期：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾回收器必须跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<p><strong>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）</strong>。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<p>到2008年为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p>
<h2 id="var-let-const区别"><a href="#var-let-const区别" class="headerlink" title="var let const区别"></a>var let const区别</h2><h3 id="var的bug"><a href="#var的bug" class="headerlink" title="var的bug"></a>var的bug</h3><p>(1)Js没有块级作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(let i-0;i&lt;10;i++)&#123;</div><div class="line">var a = &apos;a&apos;;</div><div class="line">&#125;</div><div class="line">console.log(i)</div><div class="line">循环外仍然能够输出a和i</div></pre></td></tr></table></figure>
<p>(2) 循环内变量过度共享 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 3; i++) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      console.log(i)</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div><div class="line">输出：3个3</div></pre></td></tr></table></figure>
<h3 id="let的好处"><a href="#let的好处" class="headerlink" title="let的好处"></a>let的好处</h3><p>（1）let声明的变量拥有块级作用域</p>
<p>（2）let声明的全局变量不是全局对象的属性</p>
<p>（3）形如for (let x…)的循环在每次迭代时都为x创建新的绑定</p>
<p>（4）用let重定义变量会抛出一个语法错误</p>
<h3 id="const用来定义常量"><a href="#const用来定义常量" class="headerlink" title="const用来定义常量"></a>const用来定义常量</h3><p>必须赋值，不可随意修改</p>
<h2 id="cookie-sessionstorage-localstorage的区别"><a href="#cookie-sessionstorage-localstorage的区别" class="headerlink" title="cookie sessionstorage localstorage的区别"></a>cookie sessionstorage localstorage的区别</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>只适合<strong>小容量的数据存储，它会在同源的http请求中来回传递</strong>，因此会一定程度上影响网站的性能，原生的API不友好。大小为4k左右</p>
<h3 id="sessionstorage"><a href="#sessionstorage" class="headerlink" title="sessionstorage"></a>sessionstorage</h3><p>针对一个 会话（session）进行数据存储。当用户关闭该标签页或者浏览器后，数据通常会被删除。大于5M</p>
<h3 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h3><p>可以实现<strong>永久存储，通过事件监听可以实现多个标签页的通信</strong>。大于5M</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式变量必须要声明</p>
<p>严格模式下禁止this指向全局对象，如果使用返回undefined</p>
<h2 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别"></a>undefined和null的区别</h2><p><strong>undefined:</strong></p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<p><strong>null表示”没有对象”，即该处不应该有值</strong></p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<h2 id="rem和em"><a href="#rem和em" class="headerlink" title="rem和em"></a>rem和em</h2><p>em是相对长度单位。<strong>相对于当前对象内文本的字体尺寸</strong>。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺</p>
<p>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但<strong>相对的只是HTML根元素的大小</strong>。</p>
<h2 id="为什么需要跨域限制"><a href="#为什么需要跨域限制" class="headerlink" title="为什么需要跨域限制"></a>为什么需要跨域限制</h2><p>比如一个黑客,他利用iframe把真正的银行登录页面嵌到他的页面上,当你使用真实的用户名和密码登录时<strong>,如果没有同源限制</strong>,他的页面就可以通过 JavaScript读取到你的表单中输入的内容,这样用户名和密码就轻松到手了</p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p> <em>.debounce 和 </em>.throttle</p>
<p>例如：想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。</p>
<p>throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。</p>
<p>debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。</p>
<h2 id="浅谈vue和react的区别"><a href="#浅谈vue和react的区别" class="headerlink" title="浅谈vue和react的区别"></a>浅谈vue和react的区别</h2><p>###相同处：</p>
<p>React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。React与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM</p>
<p>组件化:<strong>将应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系</strong></p>
<p><strong>React和Vue都有自己的构建工具，配套框架</strong>，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护</p>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><p>模板 vs JSX：React与Vue最大的不同是<strong>模板的编写</strong>。Vue鼓励你去写近似常规HTML的模板。写起来很接近标准HTML元素，只是多了一些属性。React应用不使用模板，它要求开发者借助JSX在JavaScript中创建DOM。</p>
<p>状态管理 vs 对象属性：在Vue对象中，data参数就是应用中数据的保存者。应用中的<strong>状态</strong>是（React）关键的概念。也有一些配套框架被设计为管理一个大的state对象，如Redux。此外，state对象在React应用中是不可变的，意味着它不能被直接改变。在React中你需要使用setState()方法去更新状态。React中是通过比较当前state和前一个state来决定<strong>何时在DOM中进行重渲染以及渲染的内容</strong>，因此<strong>需要不可变（immutable）的state</strong>。Vue中的数据是可变（mutated）的，所以同样的操作看起来更加简洁</p>
<p>React Native<strong>能在手机上创建原生应用，React在这方面处于领先位置。</strong>React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，<strong>只是不使用Web组件，而是使用原生组件</strong>。 如果你学过React.js，很快就能上手React Native</p>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><h4 id="Vue的优势是："><a href="#Vue的优势是：" class="headerlink" title="Vue的优势是："></a>Vue的优势是：</h4><p>模板和渲染函数的弹性选择</p>
<p>简单的语法和项目配置</p>
<p>更快的渲染速度和更小的体积</p>
<h4 id="React的优势是："><a href="#React的优势是：" class="headerlink" title="React的优势是："></a>React的优势是：</h4><p>更适合大型应用和更好的可测试性（vue的模板技术引入的技术债会阻碍应用扩展到更大的规模。模板容易出现很难注意到的运行时错误，同时也很难去测试，重构和分解。react的immutable应用状态可能写起来不够简洁，但它在大型应用中意义非凡，因为透明度和可测试性在大型项目中变得至关重要。）</p>
<p>Web端和移动端原生APP通吃</p>
<p>更大的生态系统，更多的支持和好用的工具</p>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>定义：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用</p>
<p>axios.request(config)</p>
<p>axios.get(url[, config])</p>
<p>axios.delete(url[, config])</p>
<p>axios.head(url[, config])</p>
<p>axios.post(url[, data[, config]])</p>
<p>axios.put(url[, data[, config]])</p>
<p>axios.patch(url[, data[, config]])</p>
<h4 id="axios用法"><a href="#axios用法" class="headerlink" title="axios用法"></a>axios用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">axios.post(url,&#123;&#125;,config)</div><div class="line">    .then(function(res)&#123;</div><div class="line">        console.log(res);</div><div class="line">    &#125;)</div><div class="line">    .catch(function(err)&#123;</div><div class="line">        console.log(err);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>//axios请求返回的也是一个promise,跟踪错误只需要在最后加一个catch就可以了。<br>//下面是关于同时发起多个请求时的处理</p>
<p>axios.all([get1(), get2()])<br>  .then(axios.spread(function (res1, res2) {<br>    // 只有两个请求都完成才会成功，否则会被catch捕获<br>  }));</p>
<p><strong>处理并发请求的帮助方法</strong></p>
<p>axios.spread(callback)</p>
<p>vue中利用axios做了一个ajax封装</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/笔试面试题（9）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔试面试题（9）/" itemprop="url">笔试面试题（9）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T00:00:00+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基本知识/" itemprop="url" rel="index">
                    <span itemprop="name">基本知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/20/笔试面试题（9）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/20/笔试面试题（9）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/20/笔试面试题（9）/" class="leancloud_visitors" data-flag-title="笔试面试题（9）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>最简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var cloneObj = JSON.parse(JSON.stringify(obj));</div></pre></td></tr></table></figure>
<p>正常方法：![]<a href="http://blog.csdn.net/flyingpig2016/article/details/52895620" target="_blank" rel="external">http://blog.csdn.net/flyingpig2016/article/details/52895620</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function deepCopy(obj)&#123;</div><div class="line">       var o;</div><div class="line">       switch(typeof obj)&#123;</div><div class="line">       case &apos;undefined&apos;: break;</div><div class="line">       case &apos;string&apos;   : o = obj + &apos;&apos;;break;</div><div class="line">       case &apos;number&apos;   : o = obj - 0;break;</div><div class="line">       case &apos;boolean&apos;  : o = obj;break;</div><div class="line">       case &apos;object&apos;   :</div><div class="line">           if(obj === null)&#123;</div><div class="line">               o = null;</div><div class="line">           &#125;else&#123;</div><div class="line">               if(obj instanceof Array)&#123;</div><div class="line">                   o = [];</div><div class="line">                   for(var i = 0, len = obj.length; i &lt; len; i++)&#123;</div><div class="line">                       o.push(deepCopy(obj[i]));</div><div class="line">                   &#125;</div><div class="line">               &#125;else&#123;</div><div class="line">                   o = &#123;&#125;;</div><div class="line">                   for(var k in obj)&#123;</div><div class="line">                       o[k] = deepCopy(obj[k]);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           break;</div><div class="line">       default:</div><div class="line">           o = obj;break;</div><div class="line">       &#125;</div><div class="line">       return o;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>理解深拷贝的递归你就能理解全部的拷贝精髓</p>
<h2 id="for函数里面setTimeout异步问题"><a href="#for函数里面setTimeout异步问题" class="headerlink" title="for函数里面setTimeout异步问题"></a>for函数里面setTimeout异步问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> for (var i=1; i&lt;=9; i++) &#123;</div><div class="line">     setTimeout( function timer()&#123;</div><div class="line">     console.log( i );</div><div class="line">     &#125;,i*1000 );</div><div class="line"> &#125;</div><div class="line">5479</div><div class="line">结果： 10</div></pre></td></tr></table></figure>
<p>更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> for (let i=1; i&lt;=9; i++) &#123;</div><div class="line">     setTimeout( function timer()&#123;</div><div class="line">     console.log( i );</div><div class="line">     &#125;,1000 );</div><div class="line"> &#125;</div><div class="line">6191</div><div class="line">VM306:3 1</div><div class="line">VM306:3 2</div><div class="line">VM306:3 3</div><div class="line">VM306:3 4</div><div class="line">VM306:3 5</div><div class="line">VM306:3 6</div><div class="line">VM306:3 7</div><div class="line">VM306:3 8</div><div class="line">VM306:3 9</div></pre></td></tr></table></figure></p>
<h2 id="让写个从几个li中取下标的闭包代码"><a href="#让写个从几个li中取下标的闭包代码" class="headerlink" title="让写个从几个li中取下标的闭包代码"></a>让写个从几个li中取下标的闭包代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"> var ul = document.createElement(&apos;ul&apos;);</div><div class="line"></div><div class="line"> for(var i=0;i&lt;10;i++)&#123;</div><div class="line"> 	var li = document.createElement(&apos;li&apos;);</div><div class="line"> 	li.innerHTML = i;</div><div class="line"> 	li.onclick = (function(i)&#123;</div><div class="line"> 		return function()&#123;</div><div class="line"> 			console.log(i)</div><div class="line"> 		&#125;</div><div class="line"> 	&#125;)(i)</div><div class="line"> 	ul.appendChild(li)</div><div class="line"> &#125;</div><div class="line"> document.body.appendChild(ul);</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="w3c事件与IE事件的区别"><a href="#w3c事件与IE事件的区别" class="headerlink" title="w3c事件与IE事件的区别"></a>w3c事件与IE事件的区别</h2><h3 id="w3c事件"><a href="#w3c事件" class="headerlink" title="w3c事件"></a>w3c事件</h3><p>addEventListener带有三个参数，第一个参数是事件类型，就是我们熟知的那些事件名字去掉前面的’on’，第二个参数是处理函数，可以直接给函数字面量或者函数名，第三个参数是boolean值，表示事件是否支持Capturing。</p>
<p>W3C的事件模型优点是Bubbling和Capturing都支持，并且可以在一个DOM元素上绑定多个事件处理器，各自并不会冲突。并且在处理函数内部，this关键字仍然可以使用只想被绑定的DOM元素。另外<code>function</code>参数列表的第一个位置(不管是否显示调用)，都永远是event对象的引用</p>
<h3 id="IE事件"><a href="#IE事件" class="headerlink" title="IE事件"></a>IE事件</h3><p>首先IE浏览器本身只支持Bubbling不支持Capturing；而且在<strong>事件处理的function内部this关键字也无法使用，因为this永远都只想window object这个全局对象</strong></p>
<h3 id="浏览器如何渲染界面"><a href="#浏览器如何渲染界面" class="headerlink" title="浏览器如何渲染界面"></a>浏览器如何渲染界面</h3><h4 id="浏览器解析"><a href="#浏览器解析" class="headerlink" title="浏览器解析"></a>浏览器解析</h4><p>1、浏览器通过请求的 URL 进行域名解析，向服务器发起请求，<strong>接收文件（HTML、CSS、JS、Images等等）</strong>。</p>
<p>2、HTML 文件加载后，开始构建 DOM Tree</p>
<p>3、CSS 样式文件加载后，开始解析和构建 CSS Rule Tree</p>
<p>4、Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree</p>
<h4 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h4><p>1、浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree</p>
<p>2、Rendering Tree 并不与 DOM Tree 对应，比如像 <head> 标签内容或带有 display: none; 的元素节点并不包括在 Rendering Tree 中 。</head></p>
<p>3、通过 CSS Rule Tree 匹配 DOM Tree 进行定位坐标和大小，是否换行，以及 position、overflow、z-index 等等属性，这个过程称为 Flow 或 Layout 。</p>
<p>4、最终通过调用<code>Native GUI</code>的<code>API</code>绘制网页画面的过程称为 Paint 。</p>
<h4 id="浏览器性能优化方法"><a href="#浏览器性能优化方法" class="headerlink" title="浏览器性能优化方法"></a>浏览器性能优化方法</h4><p>（1）白屏</p>
<p>HTML 和 CSS 的加载及解析速度</p>
<p><head> 内的脚本加载及执行</head></p>
<p>（2）图片加载（懒加载、预加载）</p>
<p><body> 内的脚本加载及执行</body></p>
<p><strong>CSS优化方法：</strong></p>
<p>将 CSS 放到文档头部，避免使用 CSS import。</p>
<h3 id="sql语句中模糊查询"><a href="#sql语句中模糊查询" class="headerlink" title="sql语句中模糊查询"></a>sql语句中模糊查询</h3><p>（1）%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请运用两个百分号（%%）表示。</p>
<p>（2）_： 表示任意单个字符。匹配单个任意字符，它常用来限定表达式的字符长度语句。</p>
<p>（3）[]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</p>
<p>（4）[^] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符</p>
<h3 id="页面缓存算法-页面置换算法"><a href="#页面缓存算法-页面置换算法" class="headerlink" title="页面缓存算法(页面置换算法)"></a>页面缓存算法(页面置换算法)</h3><p>（1）缓存数据和目标数据的一致性问题。</p>
<p>（2）缓存的过期策略（机制）。其中，缓存的过期策略涉及淘汰算法。常用的淘汰算法有下面几种：</p>
<p> （1）FIFO：First In First Out，先进先出</p>
<p> （2）LRU：Least Recently Used，最近最少使用</p>
<p> （3）LFU：Least Frequently Used，最不经常使用</p>
<h3 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h3><p>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。</p>
<h3 id="浏览器兼容性问题大汇总"><a href="#浏览器兼容性问题大汇总" class="headerlink" title="浏览器兼容性问题大汇总"></a>浏览器兼容性问题大汇总</h3><p><strong>css</strong></p>
<h4 id="css中的width和padding"><a href="#css中的width和padding" class="headerlink" title="css中的width和padding"></a>css中的width和padding</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">box.style&#123;</div><div class="line">    width:100;</div><div class="line">    border 1px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ie理解为box.width = 100 </p>
<p>ff理解为box.width = 100 + 1*2 = 102 //加上边框2px</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">    margin:30px!important;</div><div class="line">    margin:28px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="不同浏览器的标签默认的外补丁和内补丁不同"><a href="#不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="不同浏览器的标签默认的外补丁和内补丁不同"></a>不同浏览器的标签默认的外补丁和内补丁不同</h4><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p>
<p>解决方案：CSS里 *{margin:0;padding:0;}</p>
<p><strong>js</strong></p>
<h4 id="new-Date-getYear"><a href="#new-Date-getYear" class="headerlink" title="new Date().getYear()"></a>new Date().getYear()</h4><p>//方式一  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var year= new Date().getYear();  </div><div class="line">year = (year&lt;1900?(1900+year):year);  </div><div class="line">document.write(year);</div></pre></td></tr></table></figure>
<h3 id="前端性能优化方案"><a href="#前端性能优化方案" class="headerlink" title="前端性能优化方案"></a>前端性能优化方案</h3><p><strong>(1)请求和响应</strong></p>
<p>缓存控制</p>
<p>减少HTTP请求</p>
<p>使用CDN</p>
<p><strong>(2) HTML</strong></p>
<p>减少DOM</p>
<p>过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框）</p>
<p>CSS 和 JavaScript 文件位置</p>
<p>原因：样式表不参与 DOM 修改，所以不会为了解析样式停止文档解析</p>
<p><strong>（3） JavaScript</strong></p>
<p>优化建议：修改 className 而非 style；离线 DOM 后修改，如 documentFragment 或者 display:none 后再调整样式；缓存属性值；不使用 table 布局（牵一发动全身）</p>
<p>事件委托，事件代理</p>
<p><strong>（4）资源</strong></p>
<p>懒加载</p>
<p>如图像的懒加载（滚动到显示区域后才加载）等。</p>
<p>预加载</p>
<p>针对之后会用到的资源提前加载。</p>
<p>文件合并</p>
<p>文件最小化/文件压缩</p>
<p>使用 CDN 托管</p>
<p>缓存的使用（多个域名来提供缓存）</p>
<p>减少页面加载时间的方法：<br>1.优化图片 </p>
<p>2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） </p>
<p>3.优化CSS（压缩合并css，如margin-top,margin-left…) </p>
<p>4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） </p>
<p>5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） </p>
<p>6.减少http请求（合并文件，合并图片）。</p>
<p><strong>性能优化方法</strong></p>
<p>  （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>
<p>  （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
<p>  （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>
<p>  （4） 当需要设置的样式很多时设置className而不是直接操作style。</p>
<p>  （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
<p>  （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>
<p>  （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</p>
<h3 id="web-workers"><a href="#web-workers" class="headerlink" title="web workers"></a>web workers</h3><p>是可以运行异步javascript代码，避免阻塞用户界面。在执行复杂计算和数据处理的时候，这个API非常有用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/16/ReactJs(7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/16/ReactJs(7)/" itemprop="url">React.js基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-16T00:00:00+08:00">
                2017-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/16/ReactJs(7)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/16/ReactJs(7)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/16/ReactJs(7)/" class="leancloud_visitors" data-flag-title="React.js基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React-高阶API"><a href="#React-高阶API" class="headerlink" title="React 高阶API"></a>React 高阶API</h2><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>React组件可以通过继承 React.Component 或 React.PureComponent 来定义。React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。</p>
<p>如果React组件的 render() 函数在给定相同的props和state下渲染为相同的结果，在某些场景下你可以使用 React.PureComponent 来提升性能</p>
<p>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若<strong>需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法</strong></p>
<p>componentDidMount()在组件被装配后立即调用。<strong>初始化DOM节点应该进行到这里。若你需要从远端加载数据，这是一个适合实现网络请求的地方。在该方法里设置状态将会触发重渲</strong></p>
<p>componentWillReceiveProps(nextProps)在装配了的组件接收到新属性前调用。若你需要<strong>更新状态响应属性改变</strong>（例如，重置它），你可能需对比this.props和nextProps并在该方法中使用this.setState()处理状态改变</p>
<p>当接收到新属性或状态时，componentWillUpdate(nextProps, nextState)会在渲染前被立即调用。在更新发生前，使用该方法是一次准备机会。该方法不会在初始化渲染时调用。</p>
<p>注意：<strong>不能在这调用this.setState()</strong>，若你需要更新状态响应属性的调整，使用componentWillReceiveProps()代替</p>
<p><code>setState()</code>认为是一次请求而不是一次立即执行更新组件的命令。为了更为客观的性能，React可能会推迟它，稍后会一次性更新这些组件。React不会保证在setState之后，能够立刻拿到改变的结果。<code>setState()</code>不是立刻更新组件。其可能是批处理或推迟更新。这使得在调用setState()后立刻读取this.state的一个潜在陷阱。取而代之的是，使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。</p>
<p>setState()中的第一个函数是带签名的updater函数。prevState是之前状态的引用。其不应该被直接改变。代替地，改变应该通过构建一个来自于prevState 和 props输入的新对象来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">this.setState((prevState, props) =&gt; &#123;</div><div class="line">  return &#123;counter: prevState.counter + props.step&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>updater函数接收到的prevState 和 props保证都是最新的。updater的输出是和prevState的浅合并。</p>
<p>setState()的第二个参数是一个可选地回调函数，<strong>其将会在setState执行完成同时组件被重渲之后执行</strong>。通常，对于这类逻辑，我们推荐使用componentDidUpdate。</p>
<h2 id="ReactDOM"><a href="#ReactDOM" class="headerlink" title="ReactDOM"></a>ReactDOM</h2><p>ReactDOM提供三个方法：render()、unmountComponentAtNode()、findDOMNode()</p>
<p>findDOMNode:大多数情况下，你可以添加一个指向DOM节点的引用，从而完全避免使用findDOMNode 这个函数。当 render返回null或者false时，findDOMNode也返回null.</p>
<h2 id="React基本理论"><a href="#React基本理论" class="headerlink" title="React基本理论"></a>React基本理论</h2><p>组件构建提供了三种方式：React.createClass(),Es6的classes方法，和无状态函数function方法。</p>
<p>react中的setState是一种异步方法，一个生命周期内的所有的setState方法合并操作，具体原理详见后面<strong>React源码详解</strong>。</p>
<p>可以使用setState的钩子函数有：componentWillMount()中执行setState组件只会渲染一次,componentDidMount()会中setState会在初始过程中渲染两次组件,componentWillReceiveProps(nextProps),componentDidUpdate()。</p>
<p>DOM被真正添加到HTML中的生命周期方法是：componentDidMount()和componentDidUpdate</p>
<h2 id="漫谈React"><a href="#漫谈React" class="headerlink" title="漫谈React"></a>漫谈React</h2><h3 id="react中的事件委派"><a href="#react中的事件委派" class="headerlink" title="react中的事件委派"></a>react中的事件委派</h3><p>react中并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器。这个事件监听器上维持一个映射来保存所有组件内部的事件监听和处理函数。当事件发生时，首先被这个统一的事件监听器处理，然后映射到真正的事件处理函数使用。</p>
<h3 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h3><p>影响网页性能最大的问题是浏览器的重绘（reflow）和重排（repaint）。而React背后的virtual dom则是尽可能的减少浏览器的重绘和重排。从React渲染角度来说，如何避免不必要的渲染才是最需要去解决的问题。react提出一个方法叫PureRender();</p>
<p>(1)纯函数的概念：1.给定相同的输入，会一直得到相同的输出。2.过程中没有副作用。3.没有额外的状态依赖。</p>
<p>(2)PureRender():其中的Pure是指组件满足纯函数的条件。即组件的渲染是被相同的props和state渲染进而得到相同的结果。</p>
<h4 id="PureRender的本质"><a href="#PureRender的本质" class="headerlink" title="PureRender的本质"></a>PureRender的本质</h4><p>在shouldComponentUpdate阶段中，让传入的state和props做浅比较。</p>
<p>PureRender本质上对object只做了引用比较，并没有值的比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function shallowEqual(obj,newObj)&#123;</div><div class="line">	if（obj==newObj）&#123;</div><div class="line">		return true</div><div class="line">	&#125;</div><div class="line">	const objKeys = Object.keys(obj);</div><div class="line">	const newObjKeys = Object.keys(newObj);</div><div class="line">	if(objKeys.length!==newObjKeys.length)&#123;</div><div class="line">		return false</div><div class="line">	&#125;</div><div class="line">	return objKeys.every(key=&gt;&#123;</div><div class="line">		return newObj[key]==obj[key];</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="优化PureRender"><a href="#优化PureRender" class="headerlink" title="优化PureRender"></a>优化PureRender</h4><p>但是在事实上，浅比较覆盖的场景并不是很多。如果在props或state为以下几种情况时，它都会触发PureRender为true。（1）直接为props或state设置对象或数组。（2）设置props方法并将其通过事件绑定在元素上 </p>
<h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>在传递数据时可以使用Immutable Data来进一步提高组件的渲染性能。Immutable Data就是一旦创建就不能够更改的数据。immutable实现原理是<strong>持久化的数据结构</strong>，即使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时，为了避免深拷贝带来的性能损耗，Immutable使用了共享结构，即如果对象树中的一个节点发生变化，只需要修改这个节点和守它影响的父节点，其他节点可以共享。</p>
<p>Immutable.js库中的几种重要的数据结构：Map:键值对集合，对应于Object。List:有序可重复的列表，对应于Array。ArraySet:无序可重复的列表。</p>
<p>Immutable的优点：（1）降低了可变带来的复杂度 （2）节省内存（3）并发安全（4）拥抱函数式编程（输入一致，输出肯定一致）</p>
<p>语法难点：Map和List取值时语法和Js有一定的变化。例如：map.get(‘key’)而不是map.key；用array.get(0)而不是array[0]</p>
<h4 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h4><p>Immutable提供了is方法来直接比较对象的值。Immutable.is比较的是两个对象的hashCode或valueOf。由于Immutable内部使用了trie数据结构来存储，只要两个对象的hashCode相等，值就是一样的。这样的算法避免了深度遍历比较，因此性能非常好</p>
<p><strong>Immutable和PureRender</strong></p>
<p>React做性能优化时最常用的是shouldcComponentUpdate方法，但是默认为true时会始终执行render方法，造成很多没有必要的渲染。当然，我们可以在shouldComponentUpdate中使用深拷贝和浅拷贝的方法来避免不必要的render,但是深拷贝和浅拷贝依然是比较昂贵的选择。</p>
<p>利用Immutable在shouldCompoentUpdate使用，是一种简洁，高效的判断数据是否变化的方法。只需要===或者<code>is</code>比较就可以知道是否执行render,而这个操作成本几乎为0。</p>
<p>修改后的shouldComponentUpdate为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import React,&#123;Component&#125; from &apos;react&apos;</div><div class="line">import &#123;is&#125; from &apos;immutable&apos;</div><div class="line"></div><div class="line">class App extends Component&#123;</div><div class="line">	shouldComponentUpdate(nextProps,nextState)&#123;</div><div class="line">		const thisProps = this.props||&#123;&#125;;</div><div class="line">		cosnt thisState = this.state||&#123;&#125;;</div><div class="line">		if(Object.keys(thisProps).length!==Object.keys(nextProps).length||Object.keyss(thisState).length!==Object.keys(nextState).length)&#123;</div><div class="line">			return true</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for(const key in nextProps)&#123;</div><div class="line">			if(thisProps[key]!==nextProps[key]||!is(thisProps[key],nextProps[key]))&#123;</div><div class="line">				return true;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">		for(const key in nextState)&#123;</div><div class="line">			if(thisState[key]!==nextState[key]||!is(thisState[key],nextState[key]))&#123;</div><div class="line">				return true;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="setState机制"><a href="#setState机制" class="headerlink" title="setState机制"></a>setState机制</h3><p>生命周期的渲染过程是通过递归实现的，由于递归的特性，父组件的componentWillMount会在其子组件的componentWillMount之前调用，而父组件的componentDidMount会在子组件的componentDidMount之后被调用。</p>
<p>整个生命周期过程，可以调用setState方法的钩子函数有个：componentWillMount,componentDidMount,componentWillReceiveProps,componentDidUpdate,四个过程。</p>
<h4 id="setState机制-1"><a href="#setState机制-1" class="headerlink" title="setState机制"></a>setState机制</h4><p>setState通过一个队列机制实现state的更新。当执行setState时，<strong>会将需要更新的state合并后放入状态队列</strong>，而不会立刻更新this.state，队列机制高效的批量更新state。（异步更新）</p>
<p>流程示意：this.setState(newState) –&gt; newState存入pending队列 –&gt; 调用enqueueUpdate –&gt; 判断是否属于批量更新模式 –&gt; 如果是，将组建保存到dirtyComponents || 如果不是，遍历dirtyComponents，调用updateComponent，更新pending state props。</p>
<p>判断是否属于批量更新是利用batchingStrategy的标志位isBatchingUpdates，为true时属于批量更新模式，存入dirtyComponents，否则，进入更新。</p>
<h4 id="diff算法中的react-patch方法"><a href="#diff算法中的react-patch方法" class="headerlink" title="diff算法中的react patch方法"></a>diff算法中的react patch方法</h4><p>所谓的Patch，就是将tree diff计算出来的DOM差异队列更新到真实的DOM节点上，最终让浏览器渲染出数据。Patch主要是通过遍历差异队列，通过更新类型进行相应的操作，包括：新节点的插入，已有节点的移动和删除。</p>
<h3 id="redux三大原则"><a href="#redux三大原则" class="headerlink" title="redux三大原则"></a>redux三大原则</h3><p>单一数据源</p>
<p>状态是只读的</p>
<p>状态的修改均由纯函数来完成：在Redux中，通过定义reducer来确定状态的修改，而每一个reducer都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。</p>
<p>Redux的<strong>核心API</strong>：<strong>Redux的核心是一个store</strong>,这个store由Redux提供的createStore(reducers,[initialState])方法生成。最核心的API是createStore,通过createStore方法创建的store是一个对象，它本身含有四个方法：</p>
<p>getState():获取store中的状态,并返回当前状态；</p>
<p>dispatch(action):分发一个action，并返回这个action,这是唯一能改变store中数据的方式。</p>
<p>具体工作流程是这样：1.首先判断action是否为一个js对象，若不是则抛出错误。2.校验action是否包含type字段，没有则报错。3.确认当前是否处于某个action的分发过程中，如果不处于分发过程中，则先设定标志位，然后将当前的状态和action传给当前的reducer，用于生成新的reducer。</p>
<p>subscribe(listener):注册一个监听者，它在store发生变化时别调用（在使用connect方式时已经隐式的调用了subscribe方法）</p>
<p>replaceReducer(nextReducer):更新当前store里的reducer,一般只会在开发模式总使用（主要用于热替换）。</p>
<p>在Redux中，负责响应action并修改数据的角色就是reducer，reducer本质上是一个函数，函数签名为reducer(previousState,action)–&gt;newState</p>
<h3 id="Redux中的组件"><a href="#Redux中的组件" class="headerlink" title="Redux中的组件"></a>Redux中的组件</h3><p><strong>展示型组件：</strong></p>
<p>目的：长什么样子(标签，样式)；</p>
<p>无法感知Redux的存在</p>
<p>获取数据方式：从this.props中获取；</p>
<p>要改变数据：从props中传入action creator</p>
<p><strong>容器型组件：</strong></p>
<p>目的：干什么用（获取数据，更新状态）,在这一层中定义数据和action的入口，从这里将它们分发到各个子组件中去。</p>
<p>能够感知Redux的存在</p>
<p>获取数据方式：使用connect从Redux中获取</p>
<p>要改变数据：直接分发任意action</p>
<p>事实上，调用connect函数返回了一个高阶组件生成器，而这个生成器会基于原始组件生成一个全新的组件，并给这个组件增加额外的props。在构造一个高阶组件时，connect一般接受的参数有4个：</p>
<p>mapStateToProps:接受完整的Redux状态树作为参数，返回当前组件相关部分的状态树，返回对象的所有key都会成为组件的props。</p>
<p>mapDispatchToProps:接受Redux的dispatch方法作为参数，返回当前组件相关部分的<code>action creator</code>,将<code>action creator</code>和dispatch绑定</p>
<h3 id="高阶reducer"><a href="#高阶reducer" class="headerlink" title="高阶reducer"></a>高阶reducer</h3><p>将reducer作为参数或者返回值的函数称为<strong>高阶reducer</strong></p>
<p>高阶reducer可以解决reducer的复用问题，也可以对原始的reducer进行增强（使任意reducer变成可以执行撤销和重做的全新reducer）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/16/webpack基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/16/webpack基础/" itemprop="url">webpack基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-16T00:00:00+08:00">
                2017-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/16/webpack基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/16/webpack基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/16/webpack基础/" class="leancloud_visitors" data-flag-title="webpack基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>webpack（模块的打包器）有自己的特性（coding spliting）代码分割（切分加载）。<strong>webpack可以通过loader模块处理各种各样的文件</strong>，无论其模块化方式是AMD，Commonjs，ES6。模块热更新特性可以在开发中提高调试效率。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>WebPack可以看做是模块打包机：它做的事情是<strong>分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</strong></p>
<h3 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h3><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够<strong>优化前端的开发流程的工具</strong>，而<strong>WebPack是一种模块化的解决方案</strong>，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</p>
<p>Grunt和Gulp的工作方式是：<strong>在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务</strong></p>
<h4 id="Webpack的工作方式"><a href="#Webpack的工作方式" class="headerlink" title="Webpack的工作方式"></a>Webpack的工作方式</h4><p>把你的项目当做一个整体，<em>通过一个给定的主文件（如：index.js）</em>，Webpack将从这个文件开始找到你的<strong>项目的所有依赖文件</strong>，<strong>使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件</strong></p>
<p>详情配置参考！[]<a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">http://www.jianshu.com/p/42e11515c10f</a></p>
<h2 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h2><p>Loaders是webpack提供的最激动人心的功能之一了。<strong>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理</strong>，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件</p>
<p>Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p>
<p><code>test</code>：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）<br><code>loader</code>：loader的名称（必须）<br><code>include/exclude</code>:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；<br><code>query</code>：为loaders提供额外的设置选项（可选）</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的：</p>
<p>(1)使用下一代的JavaScript代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持；</p>
<p>(2)使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>
<h4 id="Babel的安装和配置"><a href="#Babel的安装和配置" class="headerlink" title="Babel的安装和配置"></a>Babel的安装和配置</h4><p>Babel其实是几个模块化的包，<strong>其核心功能位于称为babel-core的npm包中</strong>，webpack可以把其不同的包整合在一起使用，<strong>对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包</strong>）。</p>
<p><strong>Babel的配置</strong></p>
<p>Babel其实可以完全在<code>webpack.config.js</code>中进行配置，但是考虑到<code>babel</code>具有非常多的配置选项，在单一的<code>webpack.config.js</code>文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 <code>.babelrc</code> 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用<code>.babelrc</code>里的babel配置选项）</p>
<h3 id="一切皆模块"><a href="#一切皆模块" class="headerlink" title="一切皆模块"></a>一切皆模块</h3><p><strong>Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理</strong>，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。</p>
<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>webpack提供两个工具处理样式表，<code>css-loader</code>和<code>style-loader</code>，二者处理的任务不同，<code>css-loader</code>使你能够使用类似@import和url(…)的方法实现require()的功能,<code>style-loader</code>将所有的计算后的样式加入页面中，<strong>二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;</div><div class="line">import Greeter from &apos;./Greeter&apos;</div><div class="line">import &apos;./main.css&apos;</div><div class="line"></div><div class="line">render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;))</div></pre></td></tr></table></figure>
<h4 id="css-Module"><a href="#css-Module" class="headerlink" title="css Module"></a>css Module</h4><p>JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。</p>
<p>不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。</p>
<p>最近有一个叫做 CSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递到所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突</p>
<h4 id="css预处理器"><a href="#css预处理器" class="headerlink" title="css预处理器"></a>css预处理器</h4><p>Sass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以将这些特殊类型的语句转化为浏览器可识别的CSS语句。</p>
<p>常用的CSS处理loaders有:<code>Less Loader</code> <code>Sass Loader</code> <code>Stylus Loader</code></p>
<p>其实也存在一个CSS的处理平台<code>PostCSS</code>，它可以帮助你的CSS实现更多的功能，在其官方文档可了解更多相关知识。</p>
<p>举例来说如何使用<code>PostCSS</code>，我们使用<code>PostCSS</code>来为CSS代码自动添加适应不同浏览器的CSS前缀</p>
<h2 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件(Plugins)"></a>插件(Plugins)</h2><p>插件（Plugins）<strong>是用来拓展Webpack功能的，它们会在整个构建过程中生效</strong>，执行相关的任务。<br>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，<strong>loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个</strong>，<em>插件并不直接操作单个文件，它直接对整个构建过程其作用。</em></p>
<p>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<h3 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h3><p>要使用某个插件，我们需要<strong>通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子</strong>，我们添加了一个给打包后代码添加版权声明的插件。</p>
<h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><p>这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/笔试面试(8)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/笔试面试(8)/" itemprop="url">笔试面试题（8）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T00:00:00+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基本知识/" itemprop="url" rel="index">
                    <span itemprop="name">基本知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/15/笔试面试(8)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/15/笔试面试(8)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/15/笔试面试(8)/" class="leancloud_visitors" data-flag-title="笔试面试题（8）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单页应用之前端路由"><a href="#单页应用之前端路由" class="headerlink" title="单页应用之前端路由"></a>单页应用之前端路由</h2><p>前端路由主要有两种方案，一种是以angular1.x为代表的hash的解决方案，可以兼容低版本的浏览器，一种是HTML5提出的新的api。</p>
<h3 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h3><p>无刷新实现步骤：</p>
<ol>
<li><p>在A页面 通过发AJAX请求 请求页面中的B数据。</p>
</li>
<li><p>在页面A中通过JS装载相应的信息到相应的位置来。</p>
</li>
<li><p>通过History API在不刷新页面的情况下在浏览器的地址栏中从页面A的URL地址切换到页面B的URL地址</p>
</li>
</ol>
<p>主要就是<code>window.history.pushState</code> 和<code>window.history.replaceState</code>。这两种API都需要传入三个参数,</p>
<p>状态对象（state object）:一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</p>
<p>标题（title）:FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</p>
<p>地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</p>
<p>例如：<code>window.history.pushState(null, null, &quot;https://www.baidu.com/?name=orange&quot;);</code>百网址就会无刷新的变为上述地址。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理、Github 上各个标题之间的跳转等，路由里的 # 不叫锚点，我们称之为<code>hash</code>，大型框架的路由系统大多都是哈希实现的。同样我们需要一个根据监听哈希变化触发的事件<code>hashchange</code>事件。</p>
<p>大型框架的路由当然不会这么简单，angular 1.x 的路由对哈希、模版、处理器进行关联</p>
<p>详见！[]<a href="https://segmentfault.com/a/1190000007238999#articleHeader1" target="_blank" rel="external">https://segmentfault.com/a/1190000007238999#articleHeader1</a></p>
<h2 id="es6的简单了解"><a href="#es6的简单了解" class="headerlink" title="es6的简单了解"></a>es6的简单了解</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>用来声明变量，但是所声明的变量只在let命令所在的代码块内有效。let不像var那样会发生变量提升，所以一定要先声明后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(foo); //undefined</div><div class="line">console.log(bar); //报错ReferenceError</div><div class="line">var foo = 2;</div><div class="line">let bar = 3;</div></pre></td></tr></table></figure>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>(1) let实际上为javascript新增了块级作用域</p>
<p>(2) 外层作用域无法读取内层作用域的变量</p>
<p>(3) 内层作用域可以定义外层作用域的同名变量</p>
<p>(4) 块级作用域实际上使得广泛运用的立即执行函数变得不再必要了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let n=8;</div><div class="line">if(true)&#123;</div><div class="line">	let n=56;</div><div class="line">&#125;</div><div class="line">console.log(n)</div><div class="line">结果： 8</div></pre></td></tr></table></figure>
<p>变量n只在当前作用域有用，javascript没有块级作用域，但是<strong>用let声明的变量可以绑定到所在的任意作用域中，换句话说let为其声明的变量隐式的劫持了所在的块作用域{…}</strong></p>
<p><em>注意：let不允许在相同作用域内重复声明同一个变量，不能在函数内部重新声明参数。const也是这样</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function haha(n)&#123;</div><div class="line">	let n</div><div class="line">&#125;</div><div class="line">haha()</div><div class="line">VM271:2 Uncaught SyntaxError: Identifier &apos;n&apos; has already been declared</div><div class="line">    at &lt;anonymous&gt;:4:1</div></pre></td></tr></table></figure>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const同样可以创建块作用域变量，同样只在声明所在的块级作用域中有效。但其值是固定的，不可更改，只读。</p>
<p>一旦声明变量，就必须立即初始化，不能留到以后赋值。同样的,<strong>const声明的变量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用</strong></p>
<p>const的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义</p>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>浏览器环境指的是window对象 Node中指的是global对象</p>
<p><strong>ES6中，var命令和function命令声明的全局变量依旧是顶层对象的属性，但是let和const以及class声明的全局变量不属于顶层对象的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a =1;</div><div class="line">window.a</div><div class="line">结果：1</div><div class="line"></div><div class="line"></div><div class="line">let a =1;</div><div class="line">window.a</div><div class="line">VM344:1 Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</div><div class="line">    at &lt;anonymous&gt;:1:1</div></pre></td></tr></table></figure>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>异步<br>最大的特点就是可以交出函数的执行权（即暂停执行），函数名之前加星号。yield表示执行到此处，执行权将交给其他协程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function* gen(x) &#123;</div><div class="line">    var y = yield x + 2;</div><div class="line">    return y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen(1);</div><div class="line">g.next() //&#123;value:3,done:false&#125;</div><div class="line">//value是yield语句后面表达式的值，表示当前阶段的值，done表示函数是否执行完毕，是否还有下一个阶段。</div><div class="line">g.next() //&#123;value:undefined,done:true&#125;</div></pre></td></tr></table></figure>
<p><strong>调用generator函数会返回一个内部指针g</strong>，执行它不会返回结果,而是返回的指针对象。调用指针的g的next方法，会移动内部指针，指向第一个遇到的yield语句即x+2处。</p>
<h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>类似于数组但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var s = new Set([1,2,3,4,4]);</div><div class="line">[...s] </div><div class="line">结果：[1, 2, 3, 4]</div></pre></td></tr></table></figure>
<p>（1）操作方法<br>add:添加某个值，放回set结构本身</p>
<p>delete:删除某个值返回一个布尔值，表示删除是否成功</p>
<p>has(value):返回一个布尔值，表示该值是否为set的成员</p>
<p>clear:清除所有成员，没有返回</p>
<p>（2）<code>Array.from</code>方法可以将set数据结构转为数组</p>
<p>也可以使用[…s]将s转变为数组。</p>
<p>数组去重：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function dedupe(array) &#123;</div><div class="line">    return Array.from(new Set(array));</div><div class="line">&#125;</div><div class="line">dedupe([1,1,2,3]) </div><div class="line">结果：[1,2,3]</div></pre></td></tr></table></figure>
<h3 id="Default-Parameters（默认参数）"><a href="#Default-Parameters（默认参数）" class="headerlink" title="Default Parameters（默认参数）"></a>Default Parameters（默认参数）</h3><p>原来js中一切工作都是正常的，直到参数值是0后，就有问题了，因为在JavaScript中，0表示fasly，它是默认被hard-coded的值，而不能变成参数本身的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var link = function (height, color, url) &#123;</div><div class="line">    console.log(height || 50, color || &apos;red&apos;, url|| &apos;http://azat.co&apos;)</div><div class="line">&#125;</div><div class="line">link(0,1,1)</div><div class="line">结果为：50 1 1</div></pre></td></tr></table></figure>
<p>es6中，我们可以直接把默认值放在函数申明里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var link = function(height = 50, color = &apos;red&apos;, url = &apos;http://azat.co&apos;) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Template-Literals（模板对象）"><a href="#Template-Literals（模板对象）" class="headerlink" title="Template Literals（模板对象）"></a>Template Literals（模板对象）</h3><p>es5之前使用模板和插入值是在字符串里面输出变量的一种方式。在ES6中，我们可以使用新<strong>的语法$ {NAME}，并把它放在反引号里</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var first=&apos;aha&apos;;</div><div class="line">var last = &apos;hehe&apos;</div><div class="line">var name = `Your name is $&#123;first&#125; $&#123;last&#125;.`;</div><div class="line">console.log(name)</div><div class="line">结果： Your name is aha hehe.</div></pre></td></tr></table></figure></p>
<h3 id="Enhanced-Object-Literals（增强的对象字面量）"><a href="#Enhanced-Object-Literals（增强的对象字面量）" class="headerlink" title="Enhanced Object Literals（增强的对象字面量）"></a>Enhanced Object Literals（增强的对象字面量）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const _bookNum = 4;</div><div class="line"></div><div class="line">const basicConfig = &#123;</div><div class="line">  level: 5</div><div class="line">&#125;</div><div class="line"></div><div class="line">const config = &#123;</div><div class="line">  // 直接指定原型对象</div><div class="line">  __proto__: basicConfig,</div><div class="line">  </div><div class="line">  // 属性简写</div><div class="line">  _bookNum,</div><div class="line">  </div><div class="line">  // 方法简写</div><div class="line">  getBookNum() &#123;</div><div class="line">    return this.bookNum;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在未使用箭头函数前，我们在过程函数中使用父级 this，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 this 变量，会覆盖父级。</p>
<p><strong>原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。</strong></p>
<h3 id="Modules-（模块）"><a href="#Modules-（模块）" class="headerlink" title="Modules （模块）"></a>Modules （模块）</h3><p>众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在<strong>ES6中可以用模块import 和export 操作了</strong>。<br>在ES5中，你可以在 <script>中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。</p>
<p>Module 是 ES6 的新特性，是语言层面对模块化的支持。与之前模块加载机制不同，<strong>Module 是动态的加载，导入的是变量的 只读引用 ，而不是拷贝</strong></p>
<ol>
<li>export default 可以做默认导出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// a.js</div><div class="line">export default 5;      // 默认导出</div><div class="line"></div><div class="line">// b.js</div><div class="line">import b, &#123;a&#125; from &apos;./a.js&apos;;    // 默认导入，不需要加花括号</div></pre></td></tr></table></figure>
<ol>
<li>动态的加载机制</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// a.js</div><div class="line">export let a = 10;</div><div class="line">export let b = 10;</div><div class="line">export function add() &#123;</div><div class="line">  a = 15;</div><div class="line">  b = 20;</div><div class="line">  return a+b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// b.js</div><div class="line">import &#123;a, b, add&#125; from &apos;./a.js&apos;;</div><div class="line">a+b;    // 20</div><div class="line">add();  // 35</div><div class="line">a+b;    // 35</div></pre></td></tr></table></figure>
<h3 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class baseModel &#123;</div><div class="line">  constructor(options, data) &#123;</div><div class="line">    this.name = &apos;Base&apos;;</div><div class="line">    this.url = &apos;http://azat.co/api&apos;;</div><div class="line">    this.data = data;</div><div class="line">    this.options = options;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">    getName() &#123; // class method</div><div class="line">        console.log(`Class name: $&#123;this.name&#125;`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class AccountModel extends baseModel &#123;</div><div class="line">    constructor(options, data) &#123;</div><div class="line">       super(&#123;private: true&#125;, [&apos;32113123123&apos;, &apos;524214691&apos;]); //call the parent method with super</div><div class="line">       this.name = &apos;Account Model&apos;;</div><div class="line">       this.url +=&apos;/accounts/&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    get accountsData() &#123; //calculated attribute getter</div><div class="line">        return this.data;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let accounts = new AccountModel(5);</div><div class="line">accounts.getName();</div><div class="line">console.log(&apos;Data is %s&apos;, accounts.accountsData);</div></pre></td></tr></table></figure>
<h2 id="手写jsonp的实现"><a href="#手写jsonp的实现" class="headerlink" title="手写jsonp的实现"></a>手写jsonp的实现</h2><p>jsonp是一种跨域通信的手段，它的原理其实很简单：</p>
<p>（1）首先是<strong>利用script标签的src属性来实现跨域</strong>。</p>
<p>（2）通过将<strong>前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信</strong>。</p>
<p>（3）由于<strong>使用script标签的src属性，因此只支持get方法</strong></p>
<h4 id="jsonp简单实现"><a href="#jsonp简单实现" class="headerlink" title="jsonp简单实现"></a>jsonp简单实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;script src=&quot;jsonp.js&quot;&gt;</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">        jsonp(&#123;</div><div class="line">        url:&apos;http://api.douban.com/v2/movie/in_theaters&apos;,</div><div class="line">        data:&#123;count:5,start:2&#125;,</div><div class="line">    &#125;,(res)=&gt;&#123;console.log(res);&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// jsonp.js</div><div class="line">let jsonp = (data,cb)=&gt; &#123;</div><div class="line">  // 处理请求参数</div><div class="line">  const &#123;url,qs&#125; = data;</div><div class="line">  // 定义callback名称</div><div class="line">  const cb_name = `cb_$&#123;Math.random().toString().replace(&apos;.&apos;,&apos;&apos;)&#125;`;</div><div class="line">  // // 挂载callback</div><div class="line">  window[cb_name] = cb;</div><div class="line">  // // 处理url</div><div class="line">  let symbol = (url.indexOf(&apos;?&apos;)===-1) ? &apos;?&apos; : &apos;&amp;&apos;;</div><div class="line">  let params_from_qs = &apos;&apos;;</div><div class="line">  for(let key in qs) &#123;</div><div class="line">    params_from_qs += `$&#123;key&#125;=$&#123;qs[key]&#125;&amp;`;</div><div class="line">  &#125;</div><div class="line">  let complete_url = `$&#123;url&#125;$&#123;symbol&#125;$&#123;params_from_qs&#125;callback=$&#123;cb_name&#125;`;</div><div class="line">  // 挂载script</div><div class="line">  let script = document.createElement(&apos;script&apos;);</div><div class="line">  script.src = complete_url;</div><div class="line">  document.body.appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure></script></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/ReactJs(6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/ReactJs(6)/" itemprop="url">React.js基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T00:00:00+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/15/ReactJs(6)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/15/ReactJs(6)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/15/ReactJs(6)/" class="leancloud_visitors" data-flag-title="React.js基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Refs-amp-Dom"><a href="#Refs-amp-Dom" class="headerlink" title="Refs&amp;Dom"></a>Refs&amp;Dom</h2><p>在react典型的数据流中，props传递是父子组件交互的唯一方式；通过传递一个新的props值来使子组件重新re-render,从而达到父子组件通信。当然，就像react官网所描述的一样，在react典型的数据量之外，某些情况下（例如和第三方的dom库整合，或者某个dom元素focus等）为了修改子组件我们可能需要另一种方式，这就是ref方式。</p>
<p>ref可以挂到任何组件上，可以挂到组件上也可以是dom元素上；二者不同是：挂到组件（这里组件指的是有状态组件）上的<strong>ref表示对组件实例的引用</strong>，而挂<strong>载到dom元素上时表示具体的dom元素节点</strong></p>
<h3 id="ref可以设置回调函数"><a href="#ref可以设置回调函数" class="headerlink" title="ref可以设置回调函数"></a>ref可以设置回调函数</h3><p>ref属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为：</p>
<p>(1)<strong>组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例</strong>。</p>
<p>(2)<strong>组件被卸载或者原有的ref属性本身发生变化时，回调也会被立即执行，此时回调函数参数为null，以确保内存泄露</strong>。</p>
<p><strong>只能够对类组件和DOM元素添加ref属性</strong></p>
<h4 id="对于DOM元素添加ref属性"><a href="#对于DOM元素添加ref属性" class="headerlink" title="对于DOM元素添加ref属性"></a>对于DOM元素添加ref属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class CustomTextInput extends React.Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.focus = this.focus.bind(this);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  focus() &#123;</div><div class="line">    // 直接使用原生 API 使 text 输入框获得焦点</div><div class="line">    this.textInput.focus();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React </div><div class="line">    // 实例上（比如 this.textInput）</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;input</div><div class="line">          type=&quot;text&quot;</div><div class="line">          ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">        &lt;input</div><div class="line">          type=&quot;button&quot;</div><div class="line">          value=&quot;Focus the text input&quot;</div><div class="line">          onClick=&#123;this.focus&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对于类组件添加ref属性"><a href="#对于类组件添加ref属性" class="headerlink" title="对于类组件添加ref属性"></a>对于类组件添加ref属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class AutoFocusTextInput extends React.Component &#123;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    this.textInput.focus();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;CustomTextInput</div><div class="line">        ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不使用ES6与使用ES6比较"><a href="#不使用ES6与使用ES6比较" class="headerlink" title="不使用ES6与使用ES6比较"></a>不使用ES6与使用ES6比较</h2><p>使用ES6的class关键字来创建组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不使用的话,可以使用 create-react-class 模块来创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var createReactClass = require(&apos;create-react-class&apos;);</div><div class="line">var Greeting = createReactClass(&#123;</div><div class="line">  render: function() &#123;</div><div class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>ES6中class相关的接口与createReactClass方法十分相似，但有以下几个区别值得注意：</p>
<h3 id="声明默认属性"><a href="#声明默认属性" class="headerlink" title="声明默认属性"></a>声明默认属性</h3><p>如果使用 class 关键字创建组件，可以直接把自定义属性对象写到类的<code>defaultProps</code>属性中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Greeting.defaultProps = &#123;</div><div class="line">  name: &apos;Mary&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果使用 createReactClass 方法创建组件，那就需要在参数对象中定义<code>getDefaultProps</code>方法，并且在这个方法中返回包含自定义属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Greeting = createReactClass(&#123;</div><div class="line">  getDefaultProps: function() &#123;</div><div class="line">    return &#123;</div><div class="line">      name: &apos;Mary&apos;</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  // ...</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="自动绑定"><a href="#自动绑定" class="headerlink" title="自动绑定"></a>自动绑定</h3><p>对于使用 class 关键字创建的 React 组件，组件中的方法是不会自动绑定 this 的。类似地，通过 ES6 class 生成的实例，实例上的方法也不会绑定 this。因此，你需要在 constructor 中为方法手动添加 .bind(this)：</p>
<p>如果使用 createReactClass 方法创建组件，组件中的方法会自动绑定至实例，不需要像上面那样加 .bind(this)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var SayHello = createReactClass(&#123;</div><div class="line">  getInitialState: function() &#123;</div><div class="line">    return &#123;message: &apos;Hello!&apos;&#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  handleClick: function() &#123;</div><div class="line">    alert(this.state.message);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    return (</div><div class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">        Say hello</div><div class="line">      &lt;/button&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了保险起见，以下三种做法都是可以的：</p>
<p>(1)把方法绑定给构造器 (constructor)</p>
<p>(2)使用箭头函数，比如这样写：onClick={(e) =&gt; this.handleClick(e)}.</p>
<p>(3)使用 createReactClass.</p>
<h2 id="协调（Reconciliation）"><a href="#协调（Reconciliation）" class="headerlink" title="协调（Reconciliation）"></a>协调（Reconciliation）</h2><p>接下来会介绍React对比算法的选择以让组件更新可预测并使得高性能应用足够快。</p>
<p>React基于两点假设，实现了一个启发的O(n)算法：</p>
<p><strong>（1）两个不同类型的元素将产生不同的树。</strong></p>
<p><strong>（2）通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的</strong></p>
<h3 id="元素的不同类型"><a href="#元素的不同类型" class="headerlink" title="元素的不同类型"></a>元素的不同类型</h3><p>每当根元素有不同类型，React将卸载旧树并重新构建新树。从<code>&lt;a&gt;</code>到<code>&lt;img&gt;</code>或从<code>&lt;Article&gt;</code>到<code>&lt;Comment&gt;</code>，或从<code>&lt;Button&gt;</code> 到 <code>&lt;div&gt;</code>，任何的调整都会导致全部重建。当树被卸载，旧的DOM节点将被销毁。组件实例将会接收到componentWillUnmount()方法。</p>
<p>当构建一棵新树，新的DOM节点被插入到DOM中。组件实例将接收到componentWillMount()以及之后的componentDidMount()。任何有关旧树的状态都将被丢弃</p>
<h3 id="相同类型的DOM元素"><a href="#相同类型的DOM元素" class="headerlink" title="相同类型的DOM元素"></a>相同类型的DOM元素</h3><p>当比较两个相同类型的<code>React DOM</code>元素时，<code>React</code>则会观察二者的属性，保持相同的底层DOM节点，并仅更新变化的属性。</p>
<h3 id="相同类型的组件元素"><a href="#相同类型的组件元素" class="headerlink" title="相同类型的组件元素"></a>相同类型的组件元素</h3><p>当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React更新底层组件实例的属性以满足新元素，并在底层实例上调用<code>componentWillReceiveProps()</code>和 <code>componentWillUpdate()</code>方法</p>
<h3 id="利用keys来递归子树"><a href="#利用keys来递归子树" class="headerlink" title="利用keys来递归子树"></a>利用keys来递归子树</h3><p><strong>当子节点有key时，React使用key来匹配原本树的子节点和新树的子节点</strong></p>
<h2 id="context-API"><a href="#context-API" class="headerlink" title="context API"></a>context API</h2><p>无需手动向下传递props属性，但是应用需要谨慎。</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/ReactJs(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/ReactJs(5)/" itemprop="url">React.js基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T00:00:00+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/14/ReactJs(5)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/14/ReactJs(5)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/14/ReactJs(5)/" class="leancloud_visitors" data-flag-title="React.js基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React理念"><a href="#React理念" class="headerlink" title="React理念"></a>React理念</h2><p>React 最初的目的是使用<code>JavaScript</code>创建大型的，快速响应的网络应用。它在我们的<code>Facebook</code>和<code>Instagram</code>中已经实践的非常好了。</p>
<p>React的众多优点之一是它让你在编写代码的时候同时也在思考你的应用。</p>
<p>理念步骤：</p>
<h3 id="1-把-UI-划分出组件层级"><a href="#1-把-UI-划分出组件层级" class="headerlink" title="1.把 UI 划分出组件层级"></a>1.把 UI 划分出组件层级</h3><p>例如：单一功能原则，在理想状况下，一个组件应该只做一件事情。如果这个组件功能不断丰富，它应该被分成更小的组。</p>
<h3 id="2-用React创建一个静态版本"><a href="#2-用React创建一个静态版本" class="headerlink" title="2.用React创建一个静态版本"></a>2.用React创建一个静态版本</h3><p>传入数据模型，渲染 UI 但没有任何交互，最好把这些过程解耦</p>
<p>###3.定义UI状态的最小(但完整)(state)表示</p>
<p>为了正确构建你的应用，首先你需要考虑你的应用所需要的最小可变状态集（不要重复）。</p>
<p>找出哪一个是<code>state</code>。每个数据只要考虑三个问题：</p>
<p>（1）它是通过<code>props</code>从父级传来的吗？如果是，他可能不是<code>state</code>。</p>
<p>（2）它随着时间推移不变吗？如果是，它可能不是<code>state</code>。</p>
<p>（3）你能够根据组件中任何其他的<code>state</code>或<code>props</code>把它计算出来吗？如果是，它不是<code>state</code>。</p>
<h3 id="4-确定state应该位于哪里"><a href="#4-确定state应该位于哪里" class="headerlink" title="4.确定state应该位于哪里"></a>4.确定state应该位于哪里</h3><p>确定了应用<code>state</code>的最小集合。接下来，我们需要确定哪个组件会改变，或拥有这个<code>state</code>。</p>
<p>（1）确定每一个需要这个<code>state</code>来渲染的组件。</p>
<p>（2）找到一个公共所有者组件(一个在层级上高于所有其他需要这个<code>state</code>的组件的组件)</p>
<p>（3）这个公共所有者组件或另一个层级更高的组件应该拥有这个<code>state</code>。</p>
<p>（4）如果你没有找到可以拥有这个<code>state</code>的组件，创建一个仅用来保存状态的组件并把它加入比这个公共所有者组件层级更高的地方。</p>
<h3 id="5-添加反向数据流"><a href="#5-添加反向数据流" class="headerlink" title="5.添加反向数据流"></a>5.添加反向数据流</h3><p>正确渲染的应用程序，它的数据在层级中通过函数的<code>props</code>和<code>state</code>向下流动。层级结构中最底层的表单组件需要去更新在父组件中的<code>state</code>。</p>
<p>当我们想确保每当用户更改低层组件的表单时，我们更新父组件的状态来反应用户输入。<strong>因为组件应该只更新自己的状态，所以父组件会将一个回调函数传递给子组件，每当应该更新状态时，它就会触发。我们可以使用子组件输入上的onChange事件来调用它。父组件传入的回调函数会调用setState()，这时应用程序会被更新。</strong></p>
<p>虽然这听起来很复杂，但它只是几行代码的问题。而且，你可以清楚地看出你的应用中数据是如何流动的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/ReactJs(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/ReactJs(4)/" itemprop="url">React.js基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T00:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/10/ReactJs(4)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/10/ReactJs(4)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/10/ReactJs(4)/" class="leancloud_visitors" data-flag-title="React.js基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="表单（利用受控组件绑定value）"><a href="#表单（利用受控组件绑定value）" class="headerlink" title="表单（利用受控组件绑定value）"></a>表单（利用受控组件绑定value）</h2><p>值由React控制的输入表单元素称为“受控组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class NameForm extends React.Component&#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state=&#123;value: &apos;&apos;&#125;;</div><div class="line">    this.formSubmit = this.formSubmit.bind(this);</div><div class="line">    this.changeValue = this.changeValue.bind(this);</div><div class="line">  &#125;</div><div class="line">  formSubmit(event)&#123;</div><div class="line">    alert(&apos;this name is&apos; +this.state.value);</div><div class="line">    event.preventDefault();</div><div class="line">  &#125;</div><div class="line">  changeValue(event)&#123;</div><div class="line">    this.setState(&#123;value: event.target.value&#125;)</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    return(</div><div class="line">      &lt;form onSubmit=&#123;this.formSubmit&#125;&gt;</div><div class="line">      &lt;label&gt;</div><div class="line">        Name:&lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.changeValue&#125; /&gt;</div><div class="line">      &lt;/label&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">    )</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;NameForm /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。总之，<input type="text">，<textarea>,和</textarea><select>都十分类似，他们都通过传入一个value属性来实现对组件的控制。</select></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;form onSubmit=&#123;this.formSubmit&#125;&gt;</div><div class="line">		//在select根属性上设置value</div><div class="line">        &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.changeValue&#125;&gt;</div><div class="line">        &lt;option value=&quot;haha&quot;&gt;Haha&lt;/option&gt;</div><div class="line">          &lt;option value=&quot;hehe&quot;&gt;Hehe&lt;/option&gt;</div><div class="line">          &lt;option  selected value=&quot;hihi&quot;&gt;Hihi&lt;/option&gt;</div><div class="line">          &lt;option value=&quot;lala&quot;&gt;Lala&lt;/option&gt;</div><div class="line">        &lt;/select&gt;</div><div class="line">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</div><div class="line">    &lt;/form&gt;</div></pre></td></tr></table></figure>
<p>当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  handleChange(event)&#123;</div><div class="line">    let target = event.target;</div><div class="line">    let name = target.name;</div><div class="line">    let value = name===&quot;checkbox&quot;?target.checked : target.value;</div><div class="line">    this.setState(&#123;</div><div class="line">      [name]: value</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render()&#123;</div><div class="line">      return (</div><div class="line">        &lt;form &gt;</div><div class="line">          &lt;label&gt; </div><div class="line">            isGoing:&lt;input type=&quot;checkbox&quot; value=&#123;this.state.isGoing&#125; name=&quot;isGoing&quot; onChange=&#123;this.handleChange&#125; /&gt;</div><div class="line">          &lt;/label&gt;  </div><div class="line">          &lt;br /&gt;</div><div class="line">          &lt;label&gt;</div><div class="line">            输入框：&lt;input type=&quot;text&quot; value=&#123;this.state.nameValue&#125; name=&quot;nameValue&quot; onChange=&#123;this.handleChange&#125; /&gt;</div><div class="line">          &lt;/label&gt;</div><div class="line">        &lt;/form&gt;</div><div class="line">      )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>使用 react 经常会遇到几个组件需要共用状态数据的情况。这种情况下，我们最好将这部分<strong>共享的状态提升至他们最近的父组件当中</strong>进行管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function BoilingVerdict(props)&#123;</div><div class="line">  if(props.celcius&gt;=100)&#123;</div><div class="line">    return &lt;p&gt;The water is boiling &lt;/p&gt;</div><div class="line">  &#125;else&#123;</div><div class="line">    return &lt;p&gt; The water is not boiling&lt;/p&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">handleChange(event)&#123;</div><div class="line">this.setState(&#123;temperature: event.target.value&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">render()&#123;</div><div class="line">const temperature = this.state.temperature;</div><div class="line">return(</div><div class="line">  &lt;fieldset&gt;</div><div class="line">    &lt;legend&gt;This a tap &lt;/legend&gt;</div><div class="line">    &lt;label&gt;</div><div class="line">      输入温度：&lt;input type=&quot;text&quot; value=&#123;temperature&#125;  onChange=&#123;this.handleChange&#125;/&gt;</div><div class="line">    &lt;/label&gt;</div><div class="line">    &lt;BoilingVerdict celcius=&#123;temperature&#125; /&gt;</div><div class="line">      </div><div class="line">  &lt;/fieldset&gt;</div><div class="line">)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.React在DOM原生组件<input>上调用指定的onChange函数。在本例中，指的是TemperatureInput组件上的handleChange函数。</p>
<p>2.TemperatureInput组件的handleChange函数会在值发生变化时调用this.props.onTemperatureChange()函数。这些props属性，像onTemperatureChange都是由父组件Calculator提供的。</p>
<p>3.当最开始渲染时，Calculator组件把内部的handleCelsiusChange方法指定给摄氏输入组件TemperatureInput的onTemperatureChange方法，并且把handleFahrenheitChange方法指定给华氏输入组件TemperatureInput的onTemperatureChange。两个Calculator内部的方法都会在相应输入框被编辑时被调用。</p>
<p>4.在这些方法内部，Calculator组件会让React使用编辑输入的新值和当前输入框的温标来调用this.setState()方法来重渲染自身。</p>
<p>5.React会调用Calculator组件的render方法来识别UI界面的样子。基于当前温度和温标，两个输入框的值会被重新计算。温度转换就是在这里被执行的。</p>
<p>6.接着React会使用Calculator指定的新props来分别调用TemperatureInput组件。React也会识别出子组件的UI界面。React DOM 会更新DOM来匹配对应的值。我们编辑的输入框获取新值，而另一个输入框则更新经过转换的温度值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">const scaleNames = &#123;</div><div class="line">  c: &apos;Celsius&apos;,</div><div class="line">  f: &apos;Fahrenheit&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function toCelsius(fahrenheit) &#123;</div><div class="line">  return (fahrenheit - 32) * 5 / 9;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function toFahrenheit(celsius) &#123;</div><div class="line">  return (celsius * 9 / 5) + 32;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function tryConvert(temperature, convert) &#123;</div><div class="line">  const input = parseFloat(temperature);</div><div class="line">  if (Number.isNaN(input)) &#123;</div><div class="line">    return &apos;&apos;;</div><div class="line">  &#125;</div><div class="line">  const output = convert(input);</div><div class="line">  const rounded = Math.round(output * 1000) / 1000;</div><div class="line">  return rounded.toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function BoilingVerdict(props) &#123;</div><div class="line">  if (props.celsius &gt;= 100) &#123;</div><div class="line">    return &lt;p&gt;The water would boil.&lt;/p&gt;;</div><div class="line">  &#125;</div><div class="line">  return &lt;p&gt;The water would not boil.&lt;/p&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TemperatureInput extends React.Component&#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.handleChange = this.handleChange.bind(this);</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  handleChange(e)&#123;</div><div class="line">    this.props.onTemperatureChange(e.target.value);</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    const temperature = this.props.temperature;</div><div class="line">    const scale = this.props.scale;</div><div class="line">    return(</div><div class="line">      &lt;fieldset&gt;</div><div class="line">        &lt;legend&gt;在&#123;scaleNames[scale]&#125;中输温度值 &lt;/legend&gt;</div><div class="line">        &lt;input type=&quot;text&quot; value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt;</div><div class="line">      &lt;/fieldset&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Calculator extends React.Component&#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state=&#123;temperature: &apos;&apos;,scale: &apos;c&apos;&#125;;</div><div class="line">    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);</div><div class="line">    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);</div><div class="line">  &#125;</div><div class="line">  handleCelsiusChange(value)&#123;</div><div class="line">    this.setState(&#123;</div><div class="line">      scale: &apos;c&apos;,temperature: value</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  handleFahrenheitChange(value)&#123;</div><div class="line">    this.setState(&#123;</div><div class="line">      scale: &apos;f&apos;,temperature: value</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    const scale = this.state.scale;</div><div class="line">    const temperature = this.state.temperature;</div><div class="line">    const celsius = scale===&apos;f&apos;? tryConvert(temperature,toCelsius):temperature;</div><div class="line">    const fahrenheit = scale===&apos;c&apos;?tryConvert(temperature,toFahrenheit):temperature;</div><div class="line">    return(</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;TemperatureInput </div><div class="line">          scale=&apos;c&apos; </div><div class="line">          temperature=&#123;celsius&#125; </div><div class="line">          onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt;</div><div class="line">        </div><div class="line">        &lt;TemperatureInput </div><div class="line">          scale=&apos;f&apos; </div><div class="line">          temperature=&#123;fahrenheit&#125; </div><div class="line">          onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt;</div><div class="line">        &lt; BoilingVerdict celsius=&#123;celsius&#125; /&gt;</div><div class="line">        </div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Calculator /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>React 具有强大的组合模型，建议<strong>使用组合而不是继承来复用组件之间</strong>的代码</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/ReactJs(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superDjy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="С�����ľ���">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/ReactJs(3)/" itemprop="url">React.js基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T00:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/10/ReactJs(3)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/10/ReactJs(3)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/10/ReactJs(3)/" class="leancloud_visitors" data-flag-title="React.js基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="state-amp-amp-生命周期"><a href="#state-amp-amp-生命周期" class="headerlink" title="state&amp;&amp;生命周期"></a>state&amp;&amp;生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Clock extends React.Component&#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state=&#123;date: new Date()&#125;</div><div class="line">  &#125;</div><div class="line">   render()&#123;</div><div class="line">      return(</div><div class="line">        &lt;div&gt;</div><div class="line">          &lt;h1&gt; this is a test&lt;/h1&gt;</div><div class="line">          &lt;h2&gt;&#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  componentDidMount()&#123;</div><div class="line">    this.timer=setInterval(()=&gt;&#123;this.tick()&#125;,1000) </div><div class="line">  &#125;</div><div class="line">  componentWillUnmount()&#123;</div><div class="line">    clearInterval(this.timer)</div><div class="line">  &#125;</div><div class="line">  tick()&#123;</div><div class="line">    this.setState(&#123;date: new Date()&#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(&lt;Clock /&gt;, document.getElementById(&apos;root&apos;))</div></pre></td></tr></table></figure>
<p>上述代码实际作用：</p>
<p>1) 当 <clock> 被传递给 ReactDOM.render()时，React调用Clock组件的构造函数。由于 Clock 需要显示当前时间，所以使用<strong>包含当前时间的对象</strong>来初始化this.state。我们稍后会更新此状态。</clock></p>
<p>2) React然后调用Clock组件的render()方法。这是React了解屏幕上应该显示什么内容，然后 React更新DOM以匹配 Clock 的渲染输出。</p>
<p>3) 当Clock的输出插入到DOM中时，React调用componentDidMount()生命周期钩子。在其中，Clock组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。</p>
<p>4) 浏览器每秒钟调用tick()方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState()来调度UI更新。 通过调用setState()，React 知道状态已经改变，并再次调用 render()方法来确定屏幕上应当显示什么。这一次，render()方法中的this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新DOM。</p>
<p>5) 一旦Clock组件被从DOM中移除，React会调用componentWillUnmount()这个钩子函数，定时器也就会被清除</p>
<p><em>注意：构造函数是唯一能够初始化 this.state 的地方。</em></p>
<p>组件可以选择将其状态作为属性传递给其子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function FormattedDate(props) &#123;</div><div class="line">  return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">·····</div><div class="line"></div><div class="line"> &lt;FormattedDate date=&#123;this.state.date&#125; /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Toggle extends React.Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123;isToggleOn: true&#125;;</div><div class="line"></div><div class="line">    // This binding is necessary to make `this` work in the callback</div><div class="line">    this.handleClick = this.handleClick.bind(this)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleClick() &#123;</div><div class="line">    this.setState(prevState =&gt; (&#123;</div><div class="line">      isToggleOn: !prevState.isToggleOn</div><div class="line">    &#125;));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">        &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125;</div><div class="line">      &lt;/button&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Toggle /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>this.handleClick = this.handleClick.bind(this)</code><br>必须谨慎对待JSX回调函数中的this，<strong>类的方法默认是不会绑定this的</strong>。如果你忘记绑定 this.handleClick并把它传入onClick, 当你调用这个函数的时候this的值会是undefined</p>
<p>也可以在回调函数中使用箭头函数：<code>&lt;button onClick={(e)=&gt;this.handleClick(e)}&gt;</code></p>
<p><strong>通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。</strong></p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>可以通过用花括号包裹代码在JSX中嵌入任何表达式 ，也包括JavaScript的逻辑与&amp;&amp;，它可以方便地条件渲染一个元素。</p>
<p>function Mailbox(props) {<br>  const unreadMessages = props.unreadMessages;<br>  return (<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Mailbox(props)&#123;</div><div class="line">  const mes = props.unreadMessages;</div><div class="line">  return (</div><div class="line">    &lt;div&gt;</div><div class="line">      &#123;mes.length&gt;0&amp;&amp;&lt;h2&gt;haha&lt;/h2&gt;&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>之所以能这样做，是因为在JavaScript中，true&amp;&amp;expression总是返回 expression，而false&amp;&amp;expression总是返回false</p>
<h3 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class LoginControl extends React.Component&#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123;isLoginIn: false&#125;;</div><div class="line">    this.handleLoginClick = this.handleLoginClick.bind(this);</div><div class="line">    this.handleLogoutClick = this.handleLogoutClick.bind(this);</div><div class="line">  &#125;</div><div class="line">  handleLogoutClick()&#123;</div><div class="line">    this.setState(&#123;isLoginIn: true&#125;)</div><div class="line">  &#125;</div><div class="line">  handleLoginClick()&#123;</div><div class="line">    this.setState(&#123;isLoginIn: false&#125;)</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    const isLoginIn = this.state.isLoginIn;</div><div class="line">    let button = null;</div><div class="line">    if(isLoginIn)&#123;</div><div class="line">      button = &lt;LoginOutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</div><div class="line">    &#125;else&#123;</div><div class="line">      button = &lt;LoginInButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">   return( &lt;div&gt;</div><div class="line">            &lt;Greeting isLoginIn=&#123;isLoginIn&#125; /&gt;</div><div class="line">             &#123;button&#125;//通过元素变量来渲染</div><div class="line">          &lt;/div&gt;</div><div class="line">          )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">function LoginInButton(props)&#123;</div><div class="line">  return(</div><div class="line">  &lt;button onClick=&#123;props.onClick&#125;&gt;LoginIn&lt;/button&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">function LoginOutButton(props)&#123;</div><div class="line">  return(</div><div class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</div><div class="line">      LoginOut</div><div class="line">    &lt;/button&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">function UserGreeting(props)&#123;</div><div class="line">  return(</div><div class="line">    &lt;h1&gt;welcome back&lt;/h1&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">function GuestGreeting(props)&#123;</div><div class="line">  return(</div><div class="line">  &lt;h1&gt;please sign up&lt;/h1&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">function Greeting(props)&#123;</div><div class="line">  const isLoginIn = props.isLoginIn;</div><div class="line">  if(isLoginIn)&#123;</div><div class="line">    return &lt;UserGreetin /&gt;</div><div class="line">  &#125;else&#123;</div><div class="line">    return &lt;GuestGreeting /&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;LoginControl /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="列表-amp-amp-keys"><a href="#列表-amp-amp-keys" class="headerlink" title="列表&amp;&amp;keys"></a>列表&amp;&amp;keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function NumberList(props) &#123;</div><div class="line">  const numbers = props.numbers;</div><div class="line">  const listItems = numbers.map((number) =&gt;</div><div class="line">    &lt;li key=&#123;number.toString()&#125;&gt;</div><div class="line">      &#123;number&#125;</div><div class="line">    &lt;/li&gt;</div><div class="line">  );</div><div class="line">  return (</div><div class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">const numbers = [1, 2, 3, 4, 5];</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><strong>Keys</strong>可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key</p>
<p><strong>用key提取组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function ListItem(props)&#123;</div><div class="line">  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function NumberList(props) &#123;</div><div class="line">  const numbers = props.numbers;</div><div class="line">  const listItems = numbers.map((number) =&gt;</div><div class="line">    &lt;ListItem value=&#123;number&#125; key=&#123;number.toString()&#125; /&gt;</div><div class="line">  );</div><div class="line">  return (</div><div class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">const numbers = [1, 2, 4, 5];</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>提取出一个ListItem组件，<strong>应该把key保存在数组中的这个<listitem>元素上</listitem></strong>，而不是放在ListItem组件中的<li>元素上。</li></p>
<p><strong>元素的key在他的兄弟元素之间应该唯一</strong><br>数组元素中使用的key在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Blog(props)&#123;</div><div class="line">  const list=(</div><div class="line">    &lt;ul&gt;</div><div class="line">      &#123;props.posts.map(post=&gt;&lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;)&#125;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  );</div><div class="line">  const content=props.posts.map(post=&gt;</div><div class="line">                           &lt;div key=&#123;post.id&#125;&gt;</div><div class="line">                                  &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</div><div class="line">                                  &lt;h4&gt;&#123;post.content&#125;&lt;/h4&gt;</div><div class="line">                           &lt;/div&gt; </div><div class="line">                               )</div><div class="line">  return(</div><div class="line">  &lt;div&gt;</div><div class="line">    &#123;list&#125;</div><div class="line">    &lt;hr /&gt;</div><div class="line">    &#123;content&#125;                       </div><div class="line">   &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用PropTypes"><a href="#使用PropTypes" class="headerlink" title="使用PropTypes"></a>使用PropTypes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line"></div><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Greeting.propTypes = &#123;</div><div class="line">  name: PropTypes.string</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>PropTypes</code>包含一整套验证器，可用于确保你接收的数据是有效的。在这个示例中，我们使用了PropTypes.string。当你给属性传递了无效值时，JavsScript 控制台将会打印警告</p>
<h3 id="限制单个子代"><a href="#限制单个子代" class="headerlink" title="限制单个子代"></a>限制单个子代</h3><p>使用<code>PropTypes.element</code>你可以指定只传递一个子代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    const children = this.props.children;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;children&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyComponent.propTypes = &#123;</div><div class="line">  children: PropTypes.element.isRequired</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="属性默认值"><a href="#属性默认值" class="headerlink" title="属性默认值"></a>属性默认值</h3><p>通过配置<code>defaultProps</code>为props定义默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Greeting extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 为属性指定默认值:</div><div class="line">Greeting.defaultProps = &#123;</div><div class="line">  name: &apos;Stranger&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>defaultProps</code>用来确保<code>this.props.name</code>在父组件没有特别指定的情况下，有一个初始值</p>
<h2 id="父子组件数据通信"><a href="#父子组件数据通信" class="headerlink" title="父子组件数据通信"></a>父子组件数据通信</h2><p>父子组件之间的数据通信细分其实还有两种：父与子之间和子与父之间。</p>
<p>在React中，<strong>父与子之间的数据通信是通过props属性就行传递的</strong>；</p>
<p>而子与父之间的数据通信<strong>可以通过父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信</strong>;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://img.mp.itc.cn/upload/20170429/a2379efc26214d7fa790af6105312132"
               alt="superDjy" />
          <p class="site-author-name" itemprop="name">superDjy</p>
           
              <p class="site-description motion-element" itemprop="description">Stay foolish Stay hungray</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3262132644/home?wvr=5&sudaref=www.google.com.hk&retcode=6102" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/djy1028" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">superDjy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    

  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("47T3BxRMXIqlatB3fOpMnh1P-gzGzoHsz", "vUwh4kLezhjJyIlME1vvs4kU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
