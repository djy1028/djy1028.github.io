<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[笔试面试题（12）]]></title>
    <url>%2F2017%2F09%2F15%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%EF%BC%8812%EF%BC%89%2F</url>
    <content type="text"><![CDATA[prototype和proto的区别是什么是什么proto（隐式原型）与prototype（显式原型）：每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过proto来访问。 对象有属性proto,指向该对象的构造函数的原型对象；方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象 作用显式原型的作用：用来实现基于原型的继承与属性的共享； 隐式原型的作用：构成原型链，同样用于实现基于原型的继承Array.prototype.__proto__ === Object.prototype //true以及function Foo(){} Foo.prototype.__proto__ === Object.prototype //true js压缩工具YUI compressor 前端模块化模块化的好处：模块化可以让每个文件的职责单一，非常有利于代码的维护（避免命名冲突）。前端模块化：标签风格(ps：不使用模块系统)、CommonJs、AMD和它的一些衍生物、ES6模块 1.:全局对象中的变量冲突。 按需加载的问题。 开发者需要手动解析模块或者库的依赖项。 在特别大的项目中，这个现象会变得越来越严重，越来越难以管理。 2.commonJs中用同步require()来引入模块： 优点：server端的模块可以被复用、有许多现成的模块以供使用(npm)、非常的简单易用。 缺点：因为网络请求都是异步的，所以阻塞式的调用在网路中支持的不是很好 3.AMD：异步的require 优点：十分适合在现下网络的异步请求、支持多个模块的同时并行加载 缺点：写码开销。读写十分的困难、看上去像是一种解决方案。 4.ES6模块化 优点：很容易的静态模块解析、未来不久将要作为ES标准来推行 缺点：让大部分的浏览器支持这个功能还需要一段时间、这种风格的模块太少了，让人不适应。 css预处理器好处：无需考虑浏览器的兼容性问题，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 缺点：提高了门槛，首先是上手门槛，其次是维护门槛，再来是团队整体水平和规范的门槛 前后端分离前端负责：controller,view 后端：负责model overflow的几种取值方式visible 默认值。内容及时超出父级元素也会完全显示。 hidden 如果内容超出则会被隐藏。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 渐进增强和优雅降级渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 css的content属性css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动 清除浮动1.在浮动元素后面增加空元素，用空标签清除浮动 clear:both(理论上能清楚任何标签，增加无意义的标签) 2.在浮动元素的父级元素中使用overflow:auto/hidden(空标签元素清除浮动而不得不增加无意代码的弊端，使用zoom:1用于兼容IE) 3.对于浮动元素的父元素使用afert伪元素清除浮动(用于非IE浏览器).outer:after{content:&#39;.&#39;;visibility:hidden;width:0;height:0;dispaly:block} bootstrap响应式布局原理首先通过媒体查询确认container的宽度，每个col-xx-xx都是通过百分比定义的，屏幕尺寸变化了，container就变化了，col自然就变了啊 css画三角HTML代码： CSS代码：12345678910111213141516171819202122232425262728293031向上的等腰三角形.test1&#123; width: 0; height: 0; border-right: 50px solid transparent; border-bottom: 50px solid blue; border-left: 50px solid transparent;&#125;向右的等腰三角形.test2&#123; width: 0; height: 0; border-top: 50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid orange;&#125;向下的等腰三角形.test3&#123; width: 0; height: 0; border-top: 50px solid black; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125;.test4&#123; width: 0; height: 0; border-top: 50px solid transparent; border-right: 50px solid red; border-bottom: 50px solid transparent; doctype作用：目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（11）]]></title>
    <url>%2F2017%2F08%2F30%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%EF%BC%8811%EF%BC%89%2F</url>
    <content type="text"><![CDATA[浏览器安全问题同源策略同源策略限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。简单的说就是一个源的页面上的js只能访问当前源的资源，不能访问其他源的资源。 那么资源是什么呢？DOM，通过AJAX请求的网络资源，Cookie，WebStorage，webSql。 XSS(Cross-Site Script)跨站脚本攻击本质上是一种注入攻击（有兴趣了解更多注入攻击可以看这里）。其原理，简单的说就是利用各种手段把恶意代码添加到网页中，并让受害者执行这段脚本，可对用户盗取cookie信息，会话劫持等各种攻击。主要包括client(客户端型)，server(服务端型)两大类型错误。 无论是服务端型还是客户端型xss，攻击达成需要两个条件 （1）代码被注入 （2）代码被执行 其实只要做好无论任何情况下保证代码不被执行就能完全杜绝xss攻击。常见做法就是将不受信任的代码进行转义 解决方法(1) 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。后台服务器需要在接收到用户输入的数据后，对特殊危险字符进行过滤或者转义处理，然后再存储到数据库中 (2) 输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击 (3)(4) HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly sql注入将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 常用防范方法： （1）数据转义。设置php.ini选项magic_quotes_gpc=on，它会将提交的变量中所有的’(单引号)，”(双引号)，(反斜杠)，空白字符等都在前面自动加上\。或者采用mysql_real_escape()函数或addslashes()函数进行输入参数的转义。 （2）增加黑名单或者白名单验证。白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。 开发中遇到的问题Webpack + react 文件打包出来过大，动则几百k上兆（bundle.js : 852kb.）。 问题分析： （1）在使用 import css 的时候，Webpack Css 直接作为模块打包到js中。 （2）所有Js 模块 + 依赖都会打包到一个文件，导致文件很大。 （3）React、React-dom 文件过大 解决方案： （1）分离 css 文件,将css 单独打包（bundle.css – 56kb bundle.js -796kb） （2）那么就从 react 上入手，发现react 里面存在很多注释，警告等，是一个开发版本。那么如何切换成生产版本呢？通过 webpack.DefinePlugin 的process.env 来切换成生产版本 123456new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: JSON.stringify(process.env.NODE_ENV), &#125;,&#125;) 解决加载过慢的问题从webpack入手，webpack本身会有一些插件的优化方法1.UglifyJsPlugin 压缩代码的插件(这个可以很显著的缩小包的体积）。new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } }) 2.CommonsChunkPlugin (合并代码)：两个用法，一个是抽取公共的包，另一个则是把多个保重的公共依赖抽取出来 从代码层面入手首先你应该要知道code splitting这个东西，这个是代码层面优化的根基。code splitting，就是代码分割，就是代码分割成一个个小块，每次页面加载时，我只需要加载那些我需要的部分(加载包的体积变小了)，这样可以让页面加载的更快。通过webpack简而言之实现按需加载。 从实际代码入手如何实现呢？ 借助工具：npm install webpack-visualizer-plugin webpack-stats-plugin --save-dev 分析代码结构，这样就可以分析出你到底是什么导致你bundle.js报如此之大了，但有一些包我们是无法缩减的，例如react-dom,react,但是绝大部分的包都是可以进行缩减的。 流程：！[]https://segmentfault.com/a/1190000009792759 比如：加入你这个界面中用到了一个三方的图形控件Echart,那么这个包总是很大的，即使是最小的也有300k左右，其实你其他的代码可能都不到100k，那么这300k将会非常影响你这个界面的加载速度，所以需要给这个控件做一个按需加载，这样可以先展示其余的这100k所展示的界面，等待其余的300k下载好了再把Echart给补上。 通过服务器对代码进行gzip压缩 服务器端渲染 跨域的实现方式由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。 （1）JSONP这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制（所谓同源是指所请求的主机，域名，协议，端口与当前相同），同时资源加载到页面后会立即执行。具体来说就是本站脚本创建一个元素，地址指向第三方的API网址，形如：&lt;script src=&quot;http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt;并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;})这样浏览器会调用callback函数，并传递解析后json对象作为参数，，客户端即可拿到数据。 12345678910111213141516function json(jsonObj) &#123; //dosomthing&#125;// 调用jsonHandle，传入地址、追加参数，服务器端返回js代码，// 并调用客户端写好的json方法并把json数据传入进来。function jsonHandle(url) &#123; var script = document.createElement(&quot;script&quot;); script.setAttribute(&quot;src&quot;,url); document.body.appendChild(script); // 防止 script 标签冗余 if(oScript) &#123; document.body.removeChild(oScript); &#125;&#125; (2)通过修改document.domain来跨子域 在页面http://www.example.com/a.html 上设置12345678910document.domain = &apos;example.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://example.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;; 同时，在页面http://example.com/b.html上设置`document.domain = ‘a.com’` ## 安全性问题 SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将(恶意)的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入(恶意)SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 XssXss表示Cross Site Scripting(跨站脚本攻击)。它与SQL注入攻击类似，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在Xss攻击中，通过插入恶意脚本，实现对用户浏览器的控制。它是不会对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本 现代web开发框架如vue.js、react.js等，在设计的时候就考虑了Xss攻击对html插值进行了更进一步的抽象、过滤和转义（转义安全字符），我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。 同时，许多基于MVVM框架的SPA（单页应用）不需要刷新URL来控制view，这样大大防止了XSS隐患。 Csrf跨站点请求伪造：对于未被授权系统有权访问的某个资源的情况。 解决方法： 1.验证发送的请求者是否有权限访问相应的资源，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。 2.关键操作只接受POST请求 3.Token：目前主流的做法是使用Token抵御 CSRF 攻击。下面通过分析CSRF攻击来理解为什么 Token 能够有效CSRF攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击。 另一个更通用的做法是保持原有参数不变，另外添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。 Token 使用原则: Token 要足够随机————只有这样才算不可预测 Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度 Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中 HTTP最常见的响应头如下所示 Allow：服务器支持哪些请求方法（如GET、POST等）； Content-Encoding： 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档 的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面； Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream())发送内容； Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。可在web.xml文件中 配置扩展名和MIME类型的对应关系； Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦； Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。 Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置； Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302； Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的`实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置 Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续 刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是`。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 定时器关于定时器要记住的最重要的一点是：指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时执行代码。 函数节流DOM操作比起非DOM交互需要更多的内存和CPU时间，其高频率的更改有可能使得浏览器崩溃。可以使用定时器对该函数进行节流 函数节流背后的基本思想指的是：某些代码不可以在没有间断的情况下连续重复执行。节流函数形式： 1234567function throttle(method,context)&#123; clearTimeout(method.tId); method.tId=setTimeout(function()&#123; method.call(context) &#125;,100)&#125; 函数的两个参数为：1.要执行的函数 2.在那个作用域中执行。节流在resize函数中使用的最为频繁。当代码时周期性执行的时候，都应该使用节流。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（10）]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%EF%BC%8810%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端工程化前端流程：开发，测试，部署，就是把一整套前端工作流程中能用工具搞定的部分，用工具搞定。 目前来说，Web业务日益复杂化和多元化，前端开发已经由以WebPage模式为主转变为以WebApp模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个jQuery插件就能完成的了。工程复杂了就会产生许多问题，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？… 前端工程化主要应该从模块化、组件化、规范化、自动化四个方面来思考，下面一一展开。 模块化简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。 组件化首先，组件化≠模块化。好多人对这两个概念有些混淆。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。 从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。 规范化目录结构的制定 编码规范 前后端接口规范 文档规范 组件管理 垃圾回收机制的种类函数中的局部变量的生命周期：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾回收器必须跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。 标记清除js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到2008年为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 var let const区别var的bug(1)Js没有块级作用域 12345for(let i-0;i&lt;10;i++)&#123;var a = &apos;a&apos;;&#125;console.log(i)循环外仍然能够输出a和i (2) 循环内变量过度共享 123456for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1000);&#125;输出：3个3 let的好处（1）let声明的变量拥有块级作用域 （2）let声明的全局变量不是全局对象的属性 （3）形如for (let x…)的循环在每次迭代时都为x创建新的绑定 （4）用let重定义变量会抛出一个语法错误 const用来定义常量必须赋值，不可随意修改 cookie sessionstorage localstorage的区别cookie只适合小容量的数据存储，它会在同源的http请求中来回传递，因此会一定程度上影响网站的性能，原生的API不友好。大小为4k左右 sessionstorage针对一个 会话（session）进行数据存储。当用户关闭该标签页或者浏览器后，数据通常会被删除。大于5M localstorage可以实现永久存储，通过事件监听可以实现多个标签页的通信。大于5M 严格模式严格模式变量必须要声明 严格模式下禁止this指向全局对象，如果使用返回undefined undefined和null的区别undefined: （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值 （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 rem和emem是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺 区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素的大小。 为什么需要跨域限制比如一个黑客,他利用iframe把真正的银行登录页面嵌到他的页面上,当你使用真实的用户名和密码登录时,如果没有同源限制,他的页面就可以通过 JavaScript读取到你的表单中输入的内容,这样用户名和密码就轻松到手了 防抖和节流 .debounce 和 .throttle 例如：想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。 throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。 debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。 浅谈vue和react的区别###相同处： React与Vue存在很多相似之处，例如他们都是JavaScript的UI框架，专注于创造前端的富应用。React与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM 组件化:将应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系 React和Vue都有自己的构建工具，配套框架，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护 主要区别模板 vs JSX：React与Vue最大的不同是模板的编写。Vue鼓励你去写近似常规HTML的模板。写起来很接近标准HTML元素，只是多了一些属性。React应用不使用模板，它要求开发者借助JSX在JavaScript中创建DOM。 状态管理 vs 对象属性：在Vue对象中，data参数就是应用中数据的保存者。应用中的状态是（React）关键的概念。也有一些配套框架被设计为管理一个大的state对象，如Redux。此外，state对象在React应用中是不可变的，意味着它不能被直接改变。在React中你需要使用setState()方法去更新状态。React中是通过比较当前state和前一个state来决定何时在DOM中进行重渲染以及渲染的内容，因此需要不可变（immutable）的state。Vue中的数据是可变（mutated）的，所以同样的操作看起来更加简洁 React Native能在手机上创建原生应用，React在这方面处于领先位置。React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native 总结一下：Vue的优势是：模板和渲染函数的弹性选择 简单的语法和项目配置 更快的渲染速度和更小的体积 React的优势是：更适合大型应用和更好的可测试性（vue的模板技术引入的技术债会阻碍应用扩展到更大的规模。模板容易出现很难注意到的运行时错误，同时也很难去测试，重构和分解。react的immutable应用状态可能写起来不够简洁，但它在大型应用中意义非凡，因为透明度和可测试性在大型项目中变得至关重要。） Web端和移动端原生APP通吃 更大的生态系统，更多的支持和好用的工具 axios定义：基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) axios用法1234567axios.post(url,&#123;&#125;,config) .then(function(res)&#123; console.log(res); &#125;) .catch(function(err)&#123; console.log(err); &#125;) //axios请求返回的也是一个promise,跟踪错误只需要在最后加一个catch就可以了。//下面是关于同时发起多个请求时的处理 axios.all([get1(), get2()]) .then(axios.spread(function (res1, res2) { // 只有两个请求都完成才会成功，否则会被catch捕获 })); 处理并发请求的帮助方法 axios.spread(callback) vue中利用axios做了一个ajax封装]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（9）]]></title>
    <url>%2F2017%2F08%2F20%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深拷贝最简单的方法： 1var cloneObj = JSON.parse(JSON.stringify(obj)); 正常方法：![]http://blog.csdn.net/flyingpig2016/article/details/52895620 1234567891011121314151617181920212223242526272829function deepCopy(obj)&#123; var o; switch(typeof obj)&#123; case &apos;undefined&apos;: break; case &apos;string&apos; : o = obj + &apos;&apos;;break; case &apos;number&apos; : o = obj - 0;break; case &apos;boolean&apos; : o = obj;break; case &apos;object&apos; : if(obj === null)&#123; o = null; &#125;else&#123; if(obj instanceof Array)&#123; o = []; for(var i = 0, len = obj.length; i &lt; len; i++)&#123; o.push(deepCopy(obj[i])); &#125; &#125;else&#123; o = &#123;&#125;; for(var k in obj)&#123; o[k] = deepCopy(obj[k]); &#125; &#125; &#125; break; default: o = obj;break; &#125; return o; &#125; 理解深拷贝的递归你就能理解全部的拷贝精髓 for函数里面setTimeout异步问题1234567 for (var i=1; i&lt;=9; i++) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;,i*1000 ); &#125;5479结果： 10 更改：123456789101112131415 for (let i=1; i&lt;=9; i++) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;,1000 ); &#125;6191VM306:3 1VM306:3 2VM306:3 3VM306:3 4VM306:3 5VM306:3 6VM306:3 7VM306:3 8VM306:3 9 让写个从几个li中取下标的闭包代码12345678910111213141516&lt;script&gt; var ul = document.createElement(&apos;ul&apos;); for(var i=0;i&lt;10;i++)&#123; var li = document.createElement(&apos;li&apos;); li.innerHTML = i; li.onclick = (function(i)&#123; return function()&#123; console.log(i) &#125; &#125;)(i) ul.appendChild(li) &#125; document.body.appendChild(ul);&lt;/script&gt; w3c事件与IE事件的区别w3c事件addEventListener带有三个参数，第一个参数是事件类型，就是我们熟知的那些事件名字去掉前面的’on’，第二个参数是处理函数，可以直接给函数字面量或者函数名，第三个参数是boolean值，表示事件是否支持Capturing。 W3C的事件模型优点是Bubbling和Capturing都支持，并且可以在一个DOM元素上绑定多个事件处理器，各自并不会冲突。并且在处理函数内部，this关键字仍然可以使用只想被绑定的DOM元素。另外function参数列表的第一个位置(不管是否显示调用)，都永远是event对象的引用 IE事件首先IE浏览器本身只支持Bubbling不支持Capturing；而且在事件处理的function内部this关键字也无法使用，因为this永远都只想window object这个全局对象 浏览器如何渲染界面浏览器解析1、浏览器通过请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、CSS、JS、Images等等）。 2、HTML 文件加载后，开始构建 DOM Tree 3、CSS 样式文件加载后，开始解析和构建 CSS Rule Tree 4、Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree 浏览器渲染1、浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree 2、Rendering Tree 并不与 DOM Tree 对应，比如像 标签内容或带有 display: none; 的元素节点并不包括在 Rendering Tree 中 。 3、通过 CSS Rule Tree 匹配 DOM Tree 进行定位坐标和大小，是否换行，以及 position、overflow、z-index 等等属性，这个过程称为 Flow 或 Layout 。 4、最终通过调用Native GUI的API绘制网页画面的过程称为 Paint 。 浏览器性能优化方法（1）白屏 HTML 和 CSS 的加载及解析速度 &lt;head&gt;内的脚本加载及执行 （2）图片加载（懒加载、预加载） 内的脚本加载及执行 CSS优化方法： 将 CSS 放到文档头部，避免使用 CSS import。 sql语句中模糊查询（1）%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请运用两个百分号（%%）表示。 （2）_： 表示任意单个字符。匹配单个任意字符，它常用来限定表达式的字符长度语句。 （3）[]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。 （4）[^] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符 页面缓存算法(页面置换算法)（1）缓存数据和目标数据的一致性问题。 （2）缓存的过期策略（机制）。其中，缓存的过期策略涉及淘汰算法。常用的淘汰算法有下面几种： （1）FIFO：First In First Out，先进先出 （2）LRU：Least Recently Used，最近最少使用 （3）LFU：Least Frequently Used，最不经常使用 DOCTYPEDOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。 如果文件代码不合法，那么浏览器解析时便会出一些差错。 浏览器兼容性问题大汇总css css中的width和padding1234box.style&#123; width:100; border 1px;&#125; ie理解为box.width = 100 ff理解为box.width = 100 + 1*2 = 102 //加上边框2px 解决方法： 1234div&#123; margin:30px!important; margin:28px;&#125; 不同浏览器的标签默认的外补丁和内补丁不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。 解决方案：CSS里 *{margin:0;padding:0;} js new Date().getYear()//方式一 123var year= new Date().getYear(); year = (year&lt;1900?(1900+year):year); document.write(year); 前端性能优化方案(1)请求和响应 缓存控制 减少HTTP请求 使用CDN (2) HTML 减少DOM 过多的DOM元素会影响渲染、加载、执行。除了精简页面结构外，还可以适时删除不必要的DOM元素（页面内已经不会再访问的元素），又或者可以懒加载（不一定会使用到的元素，如登录框） CSS 和 JavaScript 文件位置 原因：样式表不参与 DOM 修改，所以不会为了解析样式停止文档解析 （3） JavaScript 优化建议：修改 className 而非 style；离线 DOM 后修改，如 documentFragment 或者 display:none 后再调整样式；缓存属性值；不使用 table 布局（牵一发动全身） 事件委托，事件代理 （4）资源 懒加载 如图像的懒加载（滚动到显示区域后才加载）等。 预加载 针对之后会用到的资源提前加载。 文件合并 文件最小化/文件压缩 使用 CDN 托管 缓存的使用（多个域名来提供缓存） 减少页面加载时间的方法：1.优化图片 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 3.优化CSS（压缩合并css，如margin-top,margin-left…) 4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） 6.减少http请求（合并文件，合并图片）。 性能优化方法 （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 web workers是可以运行异步javascript代码，避免阻塞用户界面。在执行复杂计算和数据处理的时候，这个API非常有用。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2017%2F08%2F16%2Fwebpack%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[webpack（模块的打包器）有自己的特性（coding spliting）代码分割（切分加载）。webpack可以通过loader模块处理各种各样的文件，无论其模块化方式是AMD，Commonjs，ES6。模块热更新特性可以在开发中提高调试效率。 定义WebPack可以看做是模块打包机：它做的事情是分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用 WebPack和Grunt以及Gulp相比有什么特性其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务 Webpack的工作方式把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件 详情配置参考！[]http://www.jianshu.com/p/42e11515c10f loadersLoaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件 Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）loader：loader的名称（必须）include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；query：为loaders提供额外的设置选项（可选） BabelBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： (1)使用下一代的JavaScript代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持； (2)使用基于JavaScript进行了拓展的语言，比如React的JSX； Babel的安装和配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 Babel的配置 Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 .babelrc 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项） 一切皆模块Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。 CSSwebpack提供两个工具处理样式表，css-loader和style-loader，二者处理的任务不同，css-loader使你能够使用类似@import和url(…)的方法实现require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 123456import React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;import Greeter from &apos;./Greeter&apos;import &apos;./main.css&apos;render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)) css ModuleJavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。 不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。 最近有一个叫做 CSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递到所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突 css预处理器Sass 和 Less 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以将这些特殊类型的语句转化为浏览器可识别的CSS语句。 常用的CSS处理loaders有:Less Loader Sass Loader Stylus Loader 其实也存在一个CSS的处理平台PostCSS，它可以帮助你的CSS实现更多的功能，在其官方文档可了解更多相关知识。 举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀 插件(Plugins)插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 使用插件的方法要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。 HtmlWebpackPlugin这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F08%2F16%2FReactJs(7)%2F</url>
    <content type="text"><![CDATA[React 高阶APIComponentsReact组件可以通过继承 React.Component 或 React.PureComponent 来定义。React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。 如果React组件的 render() 函数在给定相同的props和state下渲染为相同的结果，在某些场景下你可以使用 React.PureComponent 来提升性能 render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法 componentDidMount()在组件被装配后立即调用。初始化DOM节点应该进行到这里。若你需要从远端加载数据，这是一个适合实现网络请求的地方。在该方法里设置状态将会触发重渲 componentWillReceiveProps(nextProps)在装配了的组件接收到新属性前调用。若你需要更新状态响应属性改变（例如，重置它），你可能需对比this.props和nextProps并在该方法中使用this.setState()处理状态改变 当接收到新属性或状态时，componentWillUpdate(nextProps, nextState)会在渲染前被立即调用。在更新发生前，使用该方法是一次准备机会。该方法不会在初始化渲染时调用。注意：不能在这调用this.setState()，若你需要更新状态响应属性的调整，使用componentWillReceiveProps()代替 setState()认为是一次请求而不是一次立即执行更新组件的命令。为了更为客观的性能，React可能会推迟它，稍后会一次性更新这些组件。React不会保证在setState之后，能够立刻拿到改变的结果。setState()不是立刻更新组件。其可能是批处理或推迟更新。这使得在调用setState()后立刻读取this.state的一个潜在陷阱。取而代之的是，使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。 setState()中的第一个函数是带签名的updater函数。prevState是之前状态的引用。其不应该被直接改变。代替地，改变应该通过构建一个来自于prevState 和 props输入的新对象来表示。 123this.setState((prevState, props) =&gt; &#123; return &#123;counter: prevState.counter + props.step&#125;;&#125;); updater函数接收到的prevState 和 props保证都是最新的。updater的输出是和prevState的浅合并。 setState()的第二个参数是一个可选地回调函数，其将会在setState执行完成同时组件被重渲之后执行。通常，对于这类逻辑，我们推荐使用componentDidUpdate。 ReactDOMReactDOM提供三个方法：render()、unmountComponentAtNode()、findDOMNode() findDOMNode:大多数情况下，你可以添加一个指向DOM节点的引用，从而完全避免使用findDOMNode 这个函数。当 render返回null或者false时，findDOMNode也返回null. React基本理论组件构建提供了三种方式：React.createClass(),Es6的classes方法，和无状态函数function方法。 react中的setState是一种异步方法，一个生命周期内的所有的setState方法合并操作，具体原理详见后面React源码详解。 可以使用setState的钩子函数有：componentWillMount()中执行setState组件只会渲染一次,componentDidMount()会中setState会在初始过程中渲染两次组件,componentWillReceiveProps(nextProps),componentDidUpdate()。 DOM被真正添加到HTML中的生命周期方法是：componentDidMount()和componentDidUpdate 漫谈Reactreact中的事件委派react中并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器。这个事件监听器上维持一个映射来保存所有组件内部的事件监听和处理函数。当事件发生时，首先被这个统一的事件监听器处理，然后映射到真正的事件处理函数使用。 组件性能优化影响网页性能最大的问题是浏览器的重绘（reflow）和重排（repaint）。而React背后的virtual dom则是尽可能的减少浏览器的重绘和重排。从React渲染角度来说，如何避免不必要的渲染才是最需要去解决的问题。react提出一个方法叫PureRender(); (1)纯函数的概念：1.给定相同的输入，会一直得到相同的输出。2.过程中没有副作用。3.没有额外的状态依赖。 (2)PureRender():其中的Pure是指组件满足纯函数的条件。即组件的渲染是被相同的props和state渲染进而得到相同的结果。 PureRender的本质在shouldComponentUpdate阶段中，让传入的state和props做浅比较。 PureRender本质上对object只做了引用比较，并没有值的比较。 1234567891011121314function shallowEqual(obj,newObj)&#123; if（obj==newObj）&#123; return true &#125; const objKeys = Object.keys(obj); const newObjKeys = Object.keys(newObj); if(objKeys.length!==newObjKeys.length)&#123; return false &#125; return objKeys.every(key=&gt;&#123; return newObj[key]==obj[key]; &#125;)&#125; 优化PureRender但是在事实上，浅比较覆盖的场景并不是很多。如果在props或state为以下几种情况时，它都会触发PureRender为true。（1）直接为props或state设置对象或数组。（2）设置props方法并将其通过事件绑定在元素上 Immutable在传递数据时可以使用Immutable Data来进一步提高组件的渲染性能。Immutable Data就是一旦创建就不能够更改的数据。immutable实现原理是持久化的数据结构，即使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时，为了避免深拷贝带来的性能损耗，Immutable使用了共享结构，即如果对象树中的一个节点发生变化，只需要修改这个节点和受它影响的父节点，其他节点可以共享。 Immutable.js库中的几种重要的数据结构：Map:键值对集合，对应于Object。List:有序可重复的列表，对应于Array。ArraySet:无序可重复的列表。 Immutable的优点：（1）降低了可变带来的复杂度 （2）节省内存（3）并发安全（4）拥抱函数式编程（输入一致，输出肯定一致） 语法难点：Map和List取值时语法和Js有一定的变化。例如：map.get(‘key’)而不是map.key；用array.get(0)而不是array[0] immutable.jsImmutable提供了is方法来直接比较对象的值。Immutable.is比较的是两个对象的hashCode或valueOf。由于Immutable内部使用了trie数据结构来存储，只要两个对象的hashCode相等，值就是一样的。这样的算法避免了深度遍历比较，因此性能非常好 Immutable和PureRender React做性能优化时最常用的是shouldcComponentUpdate方法，但是默认为true时会始终执行render方法，造成很多没有必要的渲染。当然，我们可以在shouldComponentUpdate中使用深拷贝和浅拷贝的方法来避免不必要的render,但是深拷贝和浅拷贝依然是比较昂贵的选择。 利用Immutable在shouldCompoentUpdate使用，是一种简洁，高效的判断数据是否变化的方法。只需要===或者is比较就可以知道是否执行render,而这个操作成本几乎为0。 修改后的shouldComponentUpdate为 12345678910111213141516171819202122232425262728import React,&#123;Component&#125; from &apos;react&apos;import &#123;is&#125; from &apos;immutable&apos;class App extends Component&#123; shouldComponentUpdate(nextProps,nextState)&#123; const thisProps = this.props||&#123;&#125;; cosnt thisState = this.state||&#123;&#125;; if(Object.keys(thisProps).length!==Object.keys(nextProps).length||Object.keys(thisState).length!==Object.keys(nextState).length)&#123; return true &#125; for(const key in nextProps)&#123; if(thisProps[key]!==nextProps[key]||!is(thisProps[key],nextProps[key]))&#123; return true; &#125; &#125; for(const key in nextState)&#123; if(thisState[key]!==nextState[key]||!is(thisState[key],nextState[key]))&#123; return true; &#125; &#125; return false; &#125;&#125; setState机制生命周期的渲染过程是通过递归实现的，由于递归的特性，父组件的componentWillMount会在其子组件的componentWillMount之前调用，而父组件的componentDidMount会在子组件的componentDidMount之后被调用。 整个生命周期过程，可以调用setState方法的钩子函数有个：componentWillMount,componentDidMount,componentWillReceiveProps,componentDidUpdate,四个过程。 setState机制setState通过一个队列机制实现state的更新。当执行setState时，会将需要更新的state合并后放入状态队列，而不会立刻更新this.state，队列机制高效的批量更新state。（异步更新） 流程示意：this.setState(newState) –&gt; newState存入pending队列 –&gt; 调用enqueueUpdate –&gt; 判断是否属于批量更新模式 –&gt; 如果是，将组建保存到dirtyComponents || 如果不是，遍历dirtyComponents，调用updateComponent，更新pending state props。 判断是否属于批量更新是利用batchingStrategy的标志位isBatchingUpdates，为true时属于批量更新模式，存入dirtyComponents，否则，进入更新。 diff算法中的react patch方法所谓的Patch，就是将tree diff计算出来的DOM差异队列更新到真实的DOM节点上，最终让浏览器渲染出数据。Patch主要是通过遍历差异队列，通过更新类型进行相应的操作，包括：新节点的插入，已有节点的移动和删除。 redux三大原则单一数据源 状态是只读的 状态的修改均由纯函数来完成：在Redux中，通过定义reducer来确定状态的修改，而每一个reducer都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。 Redux的核心API：Redux的核心是一个store,这个store由Redux提供的createStore(reducers,[initialState])方法生成。最核心的API是createStore,通过createStore方法创建的store是一个对象，它本身含有四个方法： getState():获取store中的状态,并返回当前状态； dispatch(action):分发一个action，并返回这个action,这是唯一能改变store中数据的方式。 具体工作流程是这样：1.首先判断action是否为一个js对象，若不是则抛出错误。2.校验action是否包含type字段，没有则报错。3.确认当前是否处于某个action的分发过程中，如果不处于分发过程中，则先设定标志位，然后将当前的状态和action传给当前的reducer，用于生成新的reducer。 subscribe(listener):注册一个监听者，它在store发生变化时别调用（在使用connect方式时已经隐式的调用了subscribe方法） replaceReducer(nextReducer):更新当前store里的reducer,一般只会在开发模式总使用（主要用于热替换）。 在Redux中，负责响应action并修改数据的角色就是reducer，reducer本质上是一个函数，函数签名为reducer(previousState,action)–&gt;newState Redux中的组件展示型组件： 目的：长什么样子(标签，样式)； 无法感知Redux的存在 获取数据方式：从this.props中获取； 要改变数据：从props中传入action creator 容器型组件： 目的：干什么用（获取数据，更新状态）,在这一层中定义数据和action的入口，从这里将它们分发到各个子组件中去。 能够感知Redux的存在 获取数据方式：使用connect从Redux中获取 要改变数据：直接分发任意action 事实上，调用connect函数返回了一个高阶组件生成器，而这个生成器会基于原始组件生成一个全新的组件，并给这个组件增加额外的props。在构造一个高阶组件时，connect一般接受的参数有4个： mapStateToProps:接受完整的Redux状态树作为参数，返回当前组件相关部分的状态树，返回对象的所有key都会成为组件的props。 mapDispatchToProps:接受Redux的dispatch方法作为参数，返回当前组件相关部分的action creator,将action creator和dispatch绑定 高阶reducer将reducer作为参数或者返回值的函数称为高阶reducer 高阶reducer可以解决reducer的复用问题，也可以对原始的reducer进行增强（使任意reducer变成可以执行撤销和重做的全新reducer）]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F08%2F15%2FReactJs(6)%2F</url>
    <content type="text"><![CDATA[Refs&amp;Dom在react典型的数据流中，props传递是父子组件交互的唯一方式；通过传递一个新的props值来使子组件重新re-render,从而达到父子组件通信。当然，就像react官网所描述的一样，在react典型的数据量之外，某些情况下（例如和第三方的dom库整合，或者某个dom元素focus等）为了修改子组件我们可能需要另一种方式，这就是ref方式。 ref可以挂到任何组件上，可以挂到组件上也可以是dom元素上；二者不同是：挂到组件（这里组件指的是有状态组件）上的ref表示对组件实例的引用，而挂载到dom元素上时表示具体的dom元素节点 ref可以设置回调函数ref属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为： (1)组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。 (2)组件被卸载或者原有的ref属性本身发生变化时，回调也会被立即执行，此时回调函数参数为null，以确保内存泄露。 只能够对类组件和DOM元素添加ref属性 对于DOM元素添加ref属性12345678910111213141516171819202122232425262728class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.focus = this.focus.bind(this); &#125; focus() &#123; // 直接使用原生 API 使 text 输入框获得焦点 this.textInput.focus(); &#125; render() &#123; // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React // 实例上（比如 this.textInput） return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.focus&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 对于类组件添加ref属性123456789101112class AutoFocusTextInput extends React.Component &#123; componentDidMount() &#123; this.textInput.focus(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; 不使用ES6与使用ES6比较使用ES6的class关键字来创建组件 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 不使用的话,可以使用 create-react-class 模块来创建：123456var createReactClass = require(&apos;create-react-class&apos;);var Greeting = createReactClass(&#123; render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;) ES6中class相关的接口与createReactClass方法十分相似，但有以下几个区别值得注意： 声明默认属性如果使用 class 关键字创建组件，可以直接把自定义属性对象写到类的defaultProps属性中1234567class Greeting extends React.Component &#123; // ...&#125;Greeting.defaultProps = &#123; name: &apos;Mary&apos;&#125;; 如果使用 createReactClass 方法创建组件，那就需要在参数对象中定义getDefaultProps方法，并且在这个方法中返回包含自定义属性的对象： 12345678910var Greeting = createReactClass(&#123; getDefaultProps: function() &#123; return &#123; name: &apos;Mary&apos; &#125;; &#125;, // ...&#125;); 自动绑定对于使用 class 关键字创建的 React 组件，组件中的方法是不会自动绑定 this 的。类似地，通过 ES6 class 生成的实例，实例上的方法也不会绑定 this。因此，你需要在 constructor 中为方法手动添加 .bind(this)： 如果使用 createReactClass 方法创建组件，组件中的方法会自动绑定至实例，不需要像上面那样加 .bind(this)： 1234567891011121314151617var SayHello = createReactClass(&#123; getInitialState: function() &#123; return &#123;message: &apos;Hello!&apos;&#125;; &#125;, handleClick: function() &#123; alert(this.state.message); &#125;, render: function() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Say hello &lt;/button&gt; ); &#125;&#125;); 为了保险起见，以下三种做法都是可以的： (1)把方法绑定给构造器 (constructor) (2)使用箭头函数，比如这样写：onClick={(e) =&gt; this.handleClick(e)}. (3)使用 createReactClass. 协调（Reconciliation）接下来会介绍React对比算法的选择以让组件更新可预测并使得高性能应用足够快。 React基于两点假设，实现了一个启发的O(n)算法： （1）两个不同类型的元素将产生不同的树。 （2）通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的 元素的不同类型每当根元素有不同类型，React将卸载旧树并重新构建新树。从&lt;a&gt;到&lt;img&gt;或从&lt;Article&gt;到&lt;Comment&gt;，或从&lt;Button&gt; 到 &lt;div&gt;，任何的调整都会导致全部重建。当树被卸载，旧的DOM节点将被销毁。组件实例将会接收到componentWillUnmount()方法。 当构建一棵新树，新的DOM节点被插入到DOM中。组件实例将接收到componentWillMount()以及之后的componentDidMount()。任何有关旧树的状态都将被丢弃 相同类型的DOM元素当比较两个相同类型的React DOM元素时，React则会观察二者的属性，保持相同的底层DOM节点，并仅更新变化的属性。 相同类型的组件元素当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React更新底层组件实例的属性以满足新元素，并在底层实例上调用componentWillReceiveProps()和 componentWillUpdate()方法 利用keys来递归子树当子节点有key时，React使用key来匹配原本树的子节点和新树的子节点 context API无需手动向下传递props属性，但是应用需要谨慎。 高阶组件]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（8）]]></title>
    <url>%2F2017%2F08%2F15%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(8)%2F</url>
    <content type="text"><![CDATA[单页应用之前端路由前端路由主要有两种方案，一种是以angular1.x为代表的hash的解决方案，可以兼容低版本的浏览器，一种是HTML5提出的新的api。 History API无刷新实现步骤： 在A页面 通过发AJAX请求 请求页面中的B数据。 在页面A中通过JS装载相应的信息到相应的位置来。 通过History API在不刷新页面的情况下在浏览器的地址栏中从页面A的URL地址切换到页面B的URL地址 主要就是window.history.pushState 和window.history.replaceState。这两种API都需要传入三个参数, 状态对象（state object）:一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。 标题（title）:FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。 地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。 例如：window.history.pushState(null, null, &quot;https://www.baidu.com/?name=orange&quot;);百网址就会无刷新的变为上述地址。 hash我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理、Github 上各个标题之间的跳转等，路由里的 # 不叫锚点，我们称之为hash，大型框架的路由系统大多都是哈希实现的。同样我们需要一个根据监听哈希变化触发的事件hashchange事件。 大型框架的路由当然不会这么简单，angular 1.x 的路由对哈希、模版、处理器进行关联 详见！[]https://segmentfault.com/a/1190000007238999#articleHeader1 es6的简单了解let用来声明变量，但是所声明的变量只在let命令所在的代码块内有效。let不像var那样会发生变量提升，所以一定要先声明后使用 1234console.log(foo); //undefinedconsole.log(bar); //报错ReferenceErrorvar foo = 2;let bar = 3; 块级作用域(1) let实际上为javascript新增了块级作用域 (2) 外层作用域无法读取内层作用域的变量 (3) 内层作用域可以定义外层作用域的同名变量 (4) 块级作用域实际上使得广泛运用的立即执行函数变得不再必要了 123456let n=8;if(true)&#123; let n=56;&#125;console.log(n)结果： 8 变量n只在当前作用域有用，javascript没有块级作用域，但是用let声明的变量可以绑定到所在的任意作用域中，换句话说let为其声明的变量隐式的劫持了所在的块作用域{…} 注意：let不允许在相同作用域内重复声明同一个变量，不能在函数内部重新声明参数。const也是这样 123456function haha(n)&#123; let n&#125;haha()VM271:2 Uncaught SyntaxError: Identifier &apos;n&apos; has already been declared at &lt;anonymous&gt;:4:1 constconst同样可以创建块作用域变量，同样只在声明所在的块级作用域中有效。但其值是固定的，不可更改，只读。 一旦声明变量，就必须立即初始化，不能留到以后赋值。同样的,const声明的变量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用 const的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义 顶层对象的属性浏览器环境指的是window对象 Node中指的是global对象 ES6中，var命令和function命令声明的全局变量依旧是顶层对象的属性，但是let和const以及class声明的全局变量不属于顶层对象的属性 123456789var a =1;window.a结果：1let a =1;window.aVM344:1 Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared at &lt;anonymous&gt;:1:1 Generator函数异步最大的特点就是可以交出函数的执行权（即暂停执行），函数名之前加星号。yield表示执行到此处，执行权将交给其他协程。 123456789function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() //&#123;value:3,done:false&#125;//value是yield语句后面表达式的值，表示当前阶段的值，done表示函数是否执行完毕，是否还有下一个阶段。g.next() //&#123;value:undefined,done:true&#125; 调用generator函数会返回一个内部指针g，执行它不会返回结果,而是返回的指针对象。调用指针的g的next方法，会移动内部指针，指向第一个遇到的yield语句即x+2处。 Set数据结构类似于数组但是成员的值都是唯一的，没有重复的值。 1234var s = new Set([1,2,3,4,4]);[...s] 结果：[1, 2, 3, 4] （1）操作方法add:添加某个值，放回set结构本身 delete:删除某个值返回一个布尔值，表示删除是否成功 has(value):返回一个布尔值，表示该值是否为set的成员 clear:清除所有成员，没有返回 （2）Array.from方法可以将set数据结构转为数组 也可以使用[…s]将s转变为数组。 数组去重： 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1,1,2,3]) 结果：[1,2,3] Default Parameters（默认参数）原来js中一切工作都是正常的，直到参数值是0后，就有问题了，因为在JavaScript中，0表示fasly，它是默认被hard-coded的值，而不能变成参数本身的值 12345var link = function (height, color, url) &#123; console.log(height || 50, color || &apos;red&apos;, url|| &apos;http://azat.co&apos;)&#125;link(0,1,1)结果为：50 1 1 es6中，我们可以直接把默认值放在函数申明里： 123var link = function(height = 50, color = &apos;red&apos;, url = &apos;http://azat.co&apos;) &#123; ...&#125; Template Literals（模板对象）es5之前使用模板和插入值是在字符串里面输出变量的一种方式。在ES6中，我们可以使用新的语法$ {NAME}，并把它放在反引号里：12345var first=&apos;aha&apos;;var last = &apos;hehe&apos;var name = `Your name is $&#123;first&#125; $&#123;last&#125;.`;console.log(name)结果： Your name is aha hehe. Enhanced Object Literals（增强的对象字面量）12345678910111213141516171819const _bookNum = 4;const basicConfig = &#123; level: 5&#125;const config = &#123; // 直接指定原型对象 __proto__: basicConfig, // 属性简写 _bookNum, // 方法简写 getBookNum() &#123; return this.bookNum; &#125;&#125; 箭头函数在未使用箭头函数前，我们在过程函数中使用父级 this，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 this 变量，会覆盖父级。 原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。 Modules （模块）众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。在ES5中，你可以在 中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。 Module 是 ES6 的新特性，是语言层面对模块化的支持。与之前模块加载机制不同，Module 是动态的加载，导入的是变量的 只读引用 ，而不是拷贝 export default 可以做默认导出 123456// a.jsexport default 5; // 默认导出// b.jsimport b, &#123;a&#125; from &apos;./a.js&apos;; // 默认导入，不需要加花括号 动态的加载机制 1234567891011121314// a.jsexport let a = 10;export let b = 10;export function add() &#123; a = 15; b = 20; return a+b;&#125;;// b.jsimport &#123;a, b, add&#125; from &apos;./a.js&apos;;a+b; // 20add(); // 35a+b; // 35 class类12345678910111213class baseModel &#123; constructor(options, data) &#123; this.name = &apos;Base&apos;; this.url = &apos;http://azat.co/api&apos;; this.data = data; this.options = options; &#125; getName() &#123; // class method console.log(`Class name: $&#123;this.name&#125;`); &#125;&#125; 123456789101112131415class AccountModel extends baseModel &#123; constructor(options, data) &#123; super(&#123;private: true&#125;, [&apos;32113123123&apos;, &apos;524214691&apos;]); //call the parent method with super this.name = &apos;Account Model&apos;; this.url +=&apos;/accounts/&apos;; &#125; get accountsData() &#123; //calculated attribute getter return this.data; &#125;&#125;let accounts = new AccountModel(5);accounts.getName();console.log(&apos;Data is %s&apos;, accounts.accountsData); 手写jsonp的实现jsonp是一种跨域通信的手段，它的原理其实很简单： （1）首先是利用script标签的src属性来实现跨域。 （2）通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。 （3）由于使用script标签的src属性，因此只支持get方法 jsonp简单实现123456789101112&lt;body&gt;&lt;script src=&quot;jsonp.js&quot;&gt;&lt;/script&gt;&lt;script&gt; jsonp(&#123; url:&apos;http://api.douban.com/v2/movie/in_theaters&apos;, data:&#123;count:5,start:2&#125;, &#125;,(res)=&gt;&#123;console.log(res);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920// jsonp.jslet jsonp = (data,cb)=&gt; &#123; // 处理请求参数 const &#123;url,qs&#125; = data; // 定义callback名称 const cb_name = `cb_$&#123;Math.random().toString().replace(&apos;.&apos;,&apos;&apos;)&#125;`; // // 挂载callback window[cb_name] = cb; // // 处理url let symbol = (url.indexOf(&apos;?&apos;)===-1) ? &apos;?&apos; : &apos;&amp;&apos;; let params_from_qs = &apos;&apos;; for(let key in qs) &#123; params_from_qs += `$&#123;key&#125;=$&#123;qs[key]&#125;&amp;`; &#125; let complete_url = `$&#123;url&#125;$&#123;symbol&#125;$&#123;params_from_qs&#125;callback=$&#123;cb_name&#125;`; // 挂载script let script = document.createElement(&apos;script&apos;); script.src = complete_url; document.body.appendChild(script);&#125;]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F08%2F14%2FReactJs(5)%2F</url>
    <content type="text"><![CDATA[React理念React 最初的目的是使用JavaScript创建大型的，快速响应的网络应用。它在我们的Facebook和Instagram中已经实践的非常好了。 React的众多优点之一是它让你在编写代码的时候同时也在思考你的应用。 理念步骤： 1.把 UI 划分出组件层级例如：单一功能原则，在理想状况下，一个组件应该只做一件事情。如果这个组件功能不断丰富，它应该被分成更小的组。 2.用React创建一个静态版本传入数据模型，渲染 UI 但没有任何交互，最好把这些过程解耦 ###3.定义UI状态的最小(但完整)(state)表示 为了正确构建你的应用，首先你需要考虑你的应用所需要的最小可变状态集（不要重复）。 找出哪一个是state。每个数据只要考虑三个问题： （1）它是通过props从父级传来的吗？如果是，他可能不是state。 （2）它随着时间推移不变吗？如果是，它可能不是state。 （3）你能够根据组件中任何其他的state或props把它计算出来吗？如果是，它不是state。 4.确定state应该位于哪里确定了应用state的最小集合。接下来，我们需要确定哪个组件会改变，或拥有这个state。 （1）确定每一个需要这个state来渲染的组件。 （2）找到一个公共所有者组件(一个在层级上高于所有其他需要这个state的组件的组件) （3）这个公共所有者组件或另一个层级更高的组件应该拥有这个state。 （4）如果你没有找到可以拥有这个state的组件，创建一个仅用来保存状态的组件并把它加入比这个公共所有者组件层级更高的地方。 5.添加反向数据流正确渲染的应用程序，它的数据在层级中通过函数的props和state向下流动。层级结构中最底层的表单组件需要去更新在父组件中的state。 当我们想确保每当用户更改低层组件的表单时，我们更新父组件的状态来反应用户输入。因为组件应该只更新自己的状态，所以父组件会将一个回调函数传递给子组件，每当应该更新状态时，它就会触发。我们可以使用子组件输入上的onChange事件来调用它。父组件传入的回调函数会调用setState()，这时应用程序会被更新。 虽然这听起来很复杂，但它只是几行代码的问题。而且，你可以清楚地看出你的应用中数据是如何流动的。]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F08%2F10%2FReactJs(4)%2F</url>
    <content type="text"><![CDATA[表单（利用受控组件绑定value）值由React控制的输入表单元素称为“受控组件123456789101112131415161718192021222324252627282930class NameForm extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123;value: &apos;&apos;&#125;; this.formSubmit = this.formSubmit.bind(this); this.changeValue = this.changeValue.bind(this); &#125; formSubmit(event)&#123; alert(&apos;this name is&apos; +this.state.value); event.preventDefault(); &#125; changeValue(event)&#123; this.setState(&#123;value: event.target.value&#125;) &#125; render()&#123; return( &lt;form onSubmit=&#123;this.formSubmit&#125;&gt; &lt;label&gt; Name:&lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.changeValue&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render( &lt;NameForm /&gt;, document.getElementById(&apos;root&apos;)); 使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。总之，，,和都十分类似，他们都通过传入一个value属性来实现对组件的控制。 12345678910&lt;form onSubmit=&#123;this.formSubmit&#125;&gt; //在select根属性上设置value &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.changeValue&#125;&gt; &lt;option value=&quot;haha&quot;&gt;Haha&lt;/option&gt; &lt;option value=&quot;hehe&quot;&gt;Hehe&lt;/option&gt; &lt;option selected value=&quot;hihi&quot;&gt;Hihi&lt;/option&gt; &lt;option value=&quot;lala&quot;&gt;Lala&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; 当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么 1234567891011121314151617181920212223 handleChange(event)&#123; let target = event.target; let name = target.name; let value = name===&quot;checkbox&quot;?target.checked : target.value; this.setState(&#123; [name]: value &#125;) &#125; render()&#123; return ( &lt;form &gt; &lt;label&gt; isGoing:&lt;input type=&quot;checkbox&quot; value=&#123;this.state.isGoing&#125; name=&quot;isGoing&quot; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; 输入框：&lt;input type=&quot;text&quot; value=&#123;this.state.nameValue&#125; name=&quot;nameValue&quot; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ) &#125;&#125; 状态提升使用 react 经常会遇到几个组件需要共用状态数据的情况。这种情况下，我们最好将这部分共享的状态提升至他们最近的父组件当中进行管理 12345678910111213141516171819202122232425function BoilingVerdict(props)&#123; if(props.celcius&gt;=100)&#123; return &lt;p&gt;The water is boiling &lt;/p&gt; &#125;else&#123; return &lt;p&gt; The water is not boiling&lt;/p&gt; &#125;&#125;handleChange(event)&#123;this.setState(&#123;temperature: event.target.value&#125;)&#125;render()&#123;const temperature = this.state.temperature;return( &lt;fieldset&gt; &lt;legend&gt;This a tap &lt;/legend&gt; &lt;label&gt; 输入温度：&lt;input type=&quot;text&quot; value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;/label&gt; &lt;BoilingVerdict celcius=&#123;temperature&#125; /&gt; &lt;/fieldset&gt;)&#125; 1.React在DOM原生组件上调用指定的onChange函数。在本例中，指的是TemperatureInput组件上的handleChange函数。 2.TemperatureInput组件的handleChange函数会在值发生变化时调用this.props.onTemperatureChange()函数。这些props属性，像onTemperatureChange都是由父组件Calculator提供的。 3.当最开始渲染时，Calculator组件把内部的handleCelsiusChange方法指定给摄氏输入组件TemperatureInput的onTemperatureChange方法，并且把handleFahrenheitChange方法指定给华氏输入组件TemperatureInput的onTemperatureChange。两个Calculator内部的方法都会在相应输入框被编辑时被调用。 4.在这些方法内部，Calculator组件会让React使用编辑输入的新值和当前输入框的温标来调用this.setState()方法来重渲染自身。 5.React会调用Calculator组件的render方法来识别UI界面的样子。基于当前温度和温标，两个输入框的值会被重新计算。温度转换就是在这里被执行的。 6.接着React会使用Calculator指定的新props来分别调用TemperatureInput组件。React也会识别出子组件的UI界面。React DOM 会更新DOM来匹配对应的值。我们编辑的输入框获取新值，而另一个输入框则更新经过转换的温度值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const scaleNames = &#123; c: &apos;Celsius&apos;, f: &apos;Fahrenheit&apos;&#125;;function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125;function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return &apos;&apos;; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125;function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125;class TemperatureInput extends React.Component&#123; constructor(props)&#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e)&#123; this.props.onTemperatureChange(e.target.value); &#125; render()&#123; const temperature = this.props.temperature; const scale = this.props.scale; return( &lt;fieldset&gt; &lt;legend&gt;在&#123;scaleNames[scale]&#125;中输温度值 &lt;/legend&gt; &lt;input type=&quot;text&quot; value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ) &#125;&#125;class Calculator extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123;temperature: &apos;&apos;,scale: &apos;c&apos;&#125;; this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); &#125; handleCelsiusChange(value)&#123; this.setState(&#123; scale: &apos;c&apos;,temperature: value &#125;) &#125; handleFahrenheitChange(value)&#123; this.setState(&#123; scale: &apos;f&apos;,temperature: value &#125;) &#125; render()&#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale===&apos;f&apos;? tryConvert(temperature,toCelsius):temperature; const fahrenheit = scale===&apos;c&apos;?tryConvert(temperature,toFahrenheit):temperature; return( &lt;div&gt; &lt;TemperatureInput scale=&apos;c&apos; temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=&apos;f&apos; temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt; BoilingVerdict celsius=&#123;celsius&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Calculator /&gt;, document.getElementById(&apos;root&apos;)); 组合React 具有强大的组合模型，建议使用组合而不是继承来复用组件之间的代码]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F08%2F10%2FReactJs(3)%2F</url>
    <content type="text"><![CDATA[state&amp;&amp;生命周期12345678910111213141516171819202122232425class Clock extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123;date: new Date()&#125; &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt; this is a test&lt;/h1&gt; &lt;h2&gt;&#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; this.timer=setInterval(()=&gt;&#123;this.tick()&#125;,1000) &#125; componentWillUnmount()&#123; clearInterval(this.timer) &#125; tick()&#123; this.setState(&#123;date: new Date()&#125;) &#125;&#125;ReactDOM.render(&lt;Clock /&gt;, document.getElementById(&apos;root&apos;)) 上述代码实际作用： 1) 当 被传递给 ReactDOM.render()时，React调用Clock组件的构造函数。由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化this.state。我们稍后会更新此状态。 2) React然后调用Clock组件的render()方法。这是React了解屏幕上应该显示什么内容，然后 React更新DOM以匹配Clock的渲染输出。 3) 当Clock的输出插入到DOM中时，React调用componentDidMount()生命周期钩子。在其中，Clock组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。 4) 浏览器每秒钟调用tick()方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState()来调度UI更新。 通过调用setState()，React 知道状态已经改变，并再次调用 render()方法来确定屏幕上应当显示什么。这一次，render()方法中的this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新DOM。 5) 一旦Clock组件被从DOM中移除，React会调用componentWillUnmount()这个钩子函数，定时器也就会被清除 注意：构造函数是唯一能够初始化 this.state 的地方。 组件可以选择将其状态作为属性传递给其子组件：12345678function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;&#125;····· &lt;FormattedDate date=&#123;this.state.date&#125; /&gt; 事件处理12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this) &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&apos;root&apos;)); this.handleClick = this.handleClick.bind(this)必须谨慎对待JSX回调函数中的this，类的方法默认是不会绑定this的。如果你忘记绑定 this.handleClick并把它传入onClick, 当你调用这个函数的时候this的值会是undefined 也可以在回调函数中使用箭头函数：&lt;button onClick={(e)=&gt;this.handleClick(e)}&gt; 通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题 条件渲染可以通过用花括号包裹代码在JSX中嵌入任何表达式 ，也包括JavaScript的逻辑与&amp;&amp;，它可以方便地条件渲染一个元素。 1234567891011121314function Mailbox(props)&#123; const mes = props.unreadMessages; return ( &lt;div&gt; &#123;mes.length&gt;0&amp;&amp;&lt;h2&gt;haha&lt;/h2&gt;&#125; &lt;/div&gt; )&#125;const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById(&apos;root&apos;)); 之所以能这样做，是因为在JavaScript中，true&amp;&amp;expression总是返回 expression，而false&amp;&amp;expression总是返回false 元素变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class LoginControl extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;isLoginIn: false&#125;; this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); &#125; handleLogoutClick()&#123; this.setState(&#123;isLoginIn: true&#125;) &#125; handleLoginClick()&#123; this.setState(&#123;isLoginIn: false&#125;) &#125; render()&#123; const isLoginIn = this.state.isLoginIn; let button = null; if(isLoginIn)&#123; button = &lt;LoginOutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125;else&#123; button = &lt;LoginInButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return( &lt;div&gt; &lt;Greeting isLoginIn=&#123;isLoginIn&#125; /&gt; &#123;button&#125;//通过元素变量来渲染 &lt;/div&gt; ) &#125;&#125;function LoginInButton(props)&#123; return( &lt;button onClick=&#123;props.onClick&#125;&gt;LoginIn&lt;/button&gt; );&#125;function LoginOutButton(props)&#123; return( &lt;button onClick=&#123;props.onClick&#125;&gt; LoginOut &lt;/button&gt; );&#125;function UserGreeting(props)&#123; return( &lt;h1&gt;welcome back&lt;/h1&gt; );&#125;function GuestGreeting(props)&#123; return( &lt;h1&gt;please sign up&lt;/h1&gt; );&#125;function Greeting(props)&#123; const isLoginIn = props.isLoginIn; if(isLoginIn)&#123; return &lt;UserGreetin /&gt; &#125;else&#123; return &lt;GuestGreeting /&gt; &#125;&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById(&apos;root&apos;)); 列表&amp;&amp;keys1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key 用key提取组件 12345678910111213141516171819function ListItem(props)&#123; return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;ListItem value=&#123;number&#125; key=&#123;number.toString()&#125; /&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); 提取出一个ListItem组件，应该把key保存在数组中的这个元素上，而不是放在ListItem组件中的元素上。 元素的key在他的兄弟元素之间应该唯一数组元素中使用的key在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键。 1234567891011121314151617181920function Blog(props)&#123; const list=( &lt;ul&gt; &#123;props.posts.map(post=&gt;&lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ); const content=props.posts.map(post=&gt; &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;h4&gt;&#123;post.content&#125;&lt;/h4&gt; &lt;/div&gt; ) return( &lt;div&gt; &#123;list&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; )&#125; 使用PropTypes12345678910111213import PropTypes from &apos;prop-types&apos;;class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;Greeting.propTypes = &#123; name: PropTypes.string&#125;; PropTypes包含一整套验证器，可用于确保你接收的数据是有效的。在这个示例中，我们使用了PropTypes.string。当你给属性传递了无效值时，JavsScript 控制台将会打印警告 限制单个子代使用PropTypes.element你可以指定只传递一个子代 12345678910111213141516import PropTypes from &apos;prop-types&apos;;class MyComponent extends React.Component &#123; render() &#123; const children = this.props.children; return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;MyComponent.propTypes = &#123; children: PropTypes.element.isRequired&#125;; 属性默认值通过配置defaultProps为props定义默认值： 123456789101112class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 为属性指定默认值:Greeting.defaultProps = &#123; name: &apos;Stranger&apos;&#125;; defaultProps用来确保this.props.name在父组件没有特别指定的情况下，有一个初始值 父子组件数据通信父子组件之间的数据通信细分其实还有两种：父与子之间和子与父之间。 在React中，父与子之间的数据通信是通过props属性就行传递的； 而子与父之间的数据通信可以通过父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信;]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F04%2F%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[title: 原生js知识date: 2017-07-09tags: 基本知识 categories: 基本知识#Object对象的一些属性和方法 constructor属性指定创建一个对象的函数。 constructor属性是每个具有原型的对象的原型成员。 这包括除 Global 和 Math 对象之外的所有内部 JavaScript 对象。 constructor 属性包含了对某种函数的引用，此种函数构造了特定对象的实例。1234567function MyObj() &#123; this.number = 1;&#125;var y = new MyObj;if (y.constructor == MyObj) console.log(true)输出true prototype属性为对象的类返回原型的引用 用 prototype 属性为对象的类提供一组基本功能。 对象的新的实例“继承”了赋予该对象的原型的行为。 12345678910111213function array_max()&#123; var i, max = this[0]; for (i = 1; i &lt; this.length; i++) &#123; if (max &lt; this[i]) max = this[i]; &#125; return max;&#125;Array.prototype.max = array_max;var myArray = new Array(7, 1, 3, 11, 25, 9);document.write(myArray.max() 所有内部 JavaScript 对象都有一个只读的 prototype 属性。可将属性和方法添加到原型中，但不能为对象分配其他原型。但是，可以向用户定义的对象分配新的原型 Object.assign();将来自一个或多个源对象中的值复制到一个目标对象。Object.assign(target, …sources)12345678var first = &#123; name: &quot;Bob&quot; &#125;;var last = &#123; lastName: &quot;Smith&quot; &#125;;var person = Object.assign(first, last);console.log(person);// Output:// &#123; name: &quot;Bob&quot;, lastName: &quot;Smith&quot; &#125; 12var obj = &#123; person: &quot;Bob Smith&quot;&#125;;var clone = Object.assign(&#123;&#125;, obj); Object.keys()方法在实际开发中，我们有时需要知道对象的所有属性，原生js给我们提供了一个很好的方法：Object.keys()，该方法返回一个数组123456789101112131415161718var obj = &#123;&apos;a&apos;:&apos;123&apos;,&apos;b&apos;:&apos;345&apos;&#125;;console.log(Object.keys(obj)); //[&apos;a&apos;,&apos;b&apos;]var obj1 = &#123; 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot;&#125;;console.log(Object.keys(obj1)); // console: [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]var obj2 = Object.create(&#123;&#125;, &#123; getFoo : &#123; value : function () &#123; return this.foo &#125; &#125; &#125;);obj2.foo = 1;console.log(Object.keys(obj2)); // console: [&quot;foo&quot;]var obj = &#123; name : &quot;ziksang&quot;,&#125;//声明一个obj对象obj.__proto__.a = 1//在obj的原型上加一个a的属性console.log(Object.keys(obj))&quot;name&quot;/不可以枚举原型上的属性 Object.defineProperty()将属性添加到对象(添加新属性)，或修改现有属性的特性。返回修改属性后的对象 Object.defineProperty(object, propertyname, descriptor)，其中object为要在其上添加或修改属性的对象。 这可能是一个本机JavaScript对象（即用户定义的对象或内置对象）或DOM对象。propertyname是一个包含属性名称的字符串。descriptor是属性描述符，它可以针对数据属性或访问器属性。 示例1:添加数据属性12345678var obj=&#123;&#125;;Object.defineProperty(obj,&quot;haha&quot;,&#123; value:1, writable:true, configurable:true, enumerable:true&#125;)console.log(obj.haha); 添加访问器属性1234567891011121314var obj=&#123;&#125;;Object.defineProperty(obj,&quot;haha&quot;,&#123; set:function(x)&#123; this.hehe = x; &#125;, get:function()&#123; return this.hehe &#125;, configurable:true, enumerable:true&#125;)obj.haha=30;console.log(obj.hehe);结果： 30 Object.create()Object.create(prototype, descriptors)创建一个具有指定原型且可选择性地包含指定属性的对象。prototype是要用作原型的对象。可以为null。 descriptors是包含一个或多个属性描述符的JavaScript对象。“数据属性”是可获取且可设置值的属性。数据属性描述符包含 value 特性，以及 writable、enumerable 和 configurable 特性。如果未指定最后三个特性，则它们默认为 false。只要检索或设置该值，“访问器属性”就会调用用户提供的函数。访问器属性描述符包含set特性和/或 get 特性。 示例12345678910111213141516171819var newObj = Object.create(null, &#123; size: &#123; value: &quot;large&quot;, enumerable: true &#125;, shape: &#123; value: &quot;round&quot;, enumerable: true &#125; &#125;);document.write(newObj.size + &quot;&lt;br/&gt;&quot;);document.write(newObj.shape + &quot;&lt;br/&gt;&quot;);document.write(Object.getPrototypeOf(newObj));// Output:// large// round// null Object.getOwnPropertyDescriptor(object, propertyname)object是指包含属性的对象，propertyname是属性名称。获取指定对象的自身属性描述符。自身属性描述符是指直接在对象上定义（而非从对象的原型继承）的描述符。 123456789101112var obj=&#123;&#125;;obj.haha=&quot;hello&quot;;var discriptor=Object.getOwnPropertyDescriptor(obj,&quot;haha&quot;);discriptor.writable = false;for(var props in discriptor)&#123; console.log(props+&quot; &quot;+discriptor[props])&#125;输出： value hello writable false enumerable true configurable true]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F07%2F28%2FReactJs(2)%2F</url>
    <content type="text"><![CDATA[虚拟DOMdiff算法diff算法只对同一层级的元素进行对比（按层比较）。为了在树之间进行比较，我们首先要能够比较两个节点，在React中即比较两个虚拟DOM节点，当两个节点不同时，应该如何处理。这分为两种情况：（1）节点类型不同 ，（2）节点类型相同，但是属性不同。 (1)节点类型不同 当在树中的同一位置前后输出了不同类型的节点，React直接删除前面的节点，然后创建并插入新的节点。假设我们在树的同一位置前后两次输出不同类型的节点，当一个节点从div变成span时，简单的直接删除div节点，并插入一个新的span节点。这符合我们对真实DOM操作的理解。 需要注意的是，删除节点意味着彻底销毁该节点，而不是再后续的比较中再去看是否有另外一个节点等同于该删除的节点。如果该删除的节点之下有子节点，那么这些子节点也会被完全删除，它们也不会用于后面的比较。这也是算法复杂能够降低到O(n)的原因 上面提到的是对虚拟DOM节点的操作，而同样的逻辑也被用在React组件的比较。 当React在同一个位置遇到不同的组件时，也是简单的销毁第一个组件，而把新创建的组件加上去。这正是应用了第一个假设，不同的组件一般会产生不一样的DOM结构，与其浪费时间去比较它们基本上不会等价的DOM结构，还不如完全创建一个新的组件加上去 (2)相同类型节点的比较 React会对属性进行重设从而实现节点的转换 (3)列表节点提供唯一的key属性可以帮助React定位到正确的节点进行比较，从而大幅减少DOM操作次数，提高了性能。 JSXJSX中使用引号来定义以字符串为值的属性，使用大括号来定义以 JavaScript 表达式为值的属性 React DOM 在渲染之前默认会过滤所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。 深入JSX本质上来讲，JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。 属性使用 JavaScript 表达式 if 语句和 for 循环在 JavaScript 中不是表达式，因此它们不能直接在 JSX 中使用，所以你可以将它们放在周围的代码中（return之前使用）。 字符串常量 默认为 True 123&lt;MyTextBox autocomplete /&gt;等价于&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 一般情况下，我们不建议这样使用，因为它会与 ES6 对象简洁表示法 混淆。比如 {foo} 是 {foo: foo} 的简写，而不是 {foo: true} 123&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 编译为： 12345React.createElement( MyButton, &#123;color: &apos;blue&apos;, shadowSize: 2&#125;, &apos;Click Me&apos;) 子代在包含开始和结束标签的 JSX 表达式中，标记之间的内容作为特殊的参数传递：props.children有几种不同的方法来传递子代: (1)字符串常量:可以在开始和结束标签之间放入一个字符串，则 props.children 就是那个字符串。这对于许多内置HTML元素很有用 (2)嵌套显示组件 (3)JavsScript表达式:将任何 {} 包裹的 JavaScript 表达式作为子代传递 123&lt;MyComponent&gt;foo&lt;/MyComponent&gt;&lt;MyComponent&gt;&#123;&apos;foo&apos;&#125;&lt;/MyComponent&gt; 两者是等价的。 （4）布尔值、Null 和 Undefined 被忽略 1234567891011&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 是等价的。 值得注意的是：React 提供了一些 “falsy” 值 （即， 除了false 外，0，“”，null，undefined 和 NaN），它们依然会被渲染 元素渲染元素是构成 React 应用的最小单位。 元素用来描述你在屏幕上看到的内容：const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick, 1000); 每秒渲染一次界面，React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（7）]]></title>
    <url>%2F2017%2F07%2F10%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(7)%2F</url>
    <content type="text"><![CDATA[手写一个递归函数（考察arguments.callee，以及arguments的解释）arguments.callee表示当前的函数,传入的参数从arguments[0]开始以此类推1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function create()&#123; return function(n)&#123; if(n&lt;=1)&#123; return 1; &#125;else return n*arguments.callee(n-1) &#125;&#125;console.log(create()(4))结果： 24``` callee属性的初始值就是正在被执行的function对象。callee属性是arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或确保函数的封装性，需要注意的是callee拥有length属性，arguments.length是实参长度，arguments.callee.length是形参长度，由此能够判断调用时形参长度是否和实参长度一致## web缓存判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷### Web缓存的类型**1.数据库数据缓存**Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached等。 服务器端缓存。**2.代理服务器缓存**代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等，这里不再详述。**3.CDN缓存**CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。 **4.浏览器端缓存**浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。 **5.Web应用层缓存**应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。### 浏览器缓存页面的缓存状态是由header决定的，header的参数有四种：（1）cache-control 和 max-agecache-control 大概是最广为人知的控制缓存的 Headers 了，这也是最简单的缓存控制策略，即浏览器通过最大生存时间来判断资源的缓存是否有效。如图所见，来自服务器端的`response headers`的`Headers`中有`cache-control: max-age=3600`，这就是告诉浏览器这个资源的生存时间，在这个时间以内，浏览器不需要向服务器端再做任何确认，直接使用即可（2）Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，`Expires=max-age + 请求时间`，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。（3）Last-modified 服务器端文件的最后修改时间，需要和`cache-control`共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送`If-Modified-Since`报头，询问`Last-Modified`时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。(4)If-None-Match/ETag**采用的是`ETag`来判断缓存是否有效**，服务器端会在`response headers`中返回 ETag（文件的 hash），而当资源改变时`ETag`也会发生改变。浏览器在发起请求时在`If-None-Match`字段携带缓存的`ETag`，服务器接到请求后如果一致（即资源没有修改），则返回`304 Not Modified`，否则返回新的资源（200）**H5时代的缓存**## cookie工作原理当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。但在 localStorage 出现之前，cookie被滥用当做了存储工具。什么数据都放在cookie中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然cookie标准还是做了一些限制的：每个域名下的cookie 的大小最大为4KB，每个域名下的cookie数量最多为20个。每个cookie除了name名称和value值这两个属性以外，还有四个属性。这些属性是： expires过期时间、 path路径、 domain域、以及 secure安全。### 跨域请求中 cookie例如让位于a.sodao.com的服务器能够读取b.sodao.com设置的cookie值。方法如下：b.sodao.com的页面创建的cookie把它的path属性设置为&quot;/&quot;，把domain属性设置成**&quot;.sodao.com&quot;**，那么所有位于b.sodao.com的网页和所有位于a.sodao.com的网页，以及位于sodao.com域的其他服务器上的网页都可以访问这个cookie。## jsonp跨域实现 //添加标签的方法 function addScriptTag(url){ var script = document.createElement(‘script’); script.setAttribute(“type”,”text/javascript”); script.src = url; document.body.appendChild(script); } //自定义的回调函数result function result(data) { //我们就简单的获取apple搜索结果的第一条记录中url数据 alert(data.responseData.results[0].unescapedUrl); } //进行jsonp调用 addScriptTag(&quot;http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result&quot;); } ```这是Google的ajax搜索接口：http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=? 其中，q=?这个问号是表示你要搜索的内容，最重要的是第二个callback=?这个是正如其名表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的json数据传入这个方法完成回调。 WebPWebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 ## Ajax如何处理多个异步任务 react-echarts兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js知识（4）]]></title>
    <url>%2F2017%2F07%2F09%2F%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80(3)%2F</url>
    <content type="text"><![CDATA[DOM以及Node节点对象是整个DOM中最主要的数据类型，节点对象代表了文档树中的一个单独的节点，这里的节点可以是：元素节点、属性节点、文本节点以及所有在“Node types[节点类型]”这章中所提到的所有类型的节点。 根节点1.document.documentElement (可以直接访问标签) 2.document.body（它是为HTML页面增加的专有属性，它常用于直接访问标签） Node接口定义的节点类型都包含的特性和方法所有的元素节点的nodeType均为1,在得到nodeType为1的情况下，即可从nodeName中拿到标签的名字。 document对象的nodeType为9,它是HTMLDocument的一个实例，表示整个HTML界面。var html = document.documentElement可以取得对引用。document.body可以取得对标签的引用 可以通过getAttribute()拿到元素标签的属性。 DocumentFragment类型的nodeType为11，在所有的节点类型中，只有DocumentFragment类型在文档中没有标记。DOM规定文档片段（document Fragment）是一种“轻量级”的文档。通常将它作为一个“仓库”来使用，在里面保存将来有可能会增加的文档节点。var Fragment = document.createDocumentFragment() 遍历节点:注：冒号后为返回类型 parentNode : Node firstChild : Node lastChild : Node nextSibling : Node previousSibling : Node childNodes（类数组特性） : NodeList 节点信息:nodeName :String nodeType :number（nodeType==1为元素节点） nodeValue :String 返回一个节点的根元素（文档对象）:ownerDocument : Document 包含了代表一个元素的特性的Attr对象；仅用于Element节点：attributes : NamedNodeMap 获取对象层次中的父对象：parentElement [IE] :Node 修改文档树的方法appendChild(Node newChild) : Node insertBefore(Node newChild, Node refChild) : Node removeChild(Node oldChild): Node replaceChild(Node newChild, Node refChild) : Node 克隆一个节点：cloneNode(boolean deep) : Node 删除一个子节点:removeNode(boolean removeChildren) : Node 判断childNodes包含是否包含节点：hasChildNodes() : boolean 遍历数组中元素返回最多次数array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue) 1234567891011121314var names = [&apos;Alice&apos;, &apos;Bob&apos;, &apos;Tiff&apos;, &apos;Bruce&apos;, &apos;Alice&apos;];var countedNames = names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] = 1; &#125; return allNames;&#125;, &#123;&#125;);结果为：&#123; &apos;Alice&apos;: 2, &apos;Bob&apos;: 1, &apos;Tiff&apos;: 1, &apos;Bruce&apos;: 1 &#125; 选取所有html中出现元素最多的并且返回次数： 1234567891011var resuslt = queryselector(*).reduce(function(allNames,name)&#123; if(allNames[name])&#123; allNames[name]++; &#125; else&#123; allNames[name]=1; &#125; return allNames;&#125;,[])可以得到结果为：[div:3,h1:1...]等 BOMBOM的核心对象是window,它表示浏览器的一个实例。 location对象：提供了与当前窗口中加载的文档有关的信息。因为它既是window对象属性，也是document对象的属性，即document.location==window.location。 其属性包括：hash,host,hostName,pathname,port等 history对象：history对象保存着浏览器用户的上网记录，history是window的对象的属性，因此每个浏览器窗口，每个标签乃至框架都有自己的history对象。使用go()方法可以在在用户的浏览历史中任意跳转。 DOM操作技术动态脚本动态脚本指的是在页面加载时不存在，但将来的某一时刻通过修改DOM动态修改的脚本。 1234567function(url)&#123; var element = document.createElement(&quot;script&quot;); element.type = &quot;text/javascript&quot;; element.src = url; document.body.appendChild(element);&#125; 动态样式所谓动态样式：指在页面加载时不存在的样式；动态样式在页面加载完成后动态添加到页面上。 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; 123456789function appendLink(url)&#123; var link = document.createElement(&quot;link&quot;); link.rel = &quot;stylesheet&quot;; link.type=&quot;text/css&quot;; link.href=url; var head =document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(link);&#125; DOM遍历DOM2遍历模块定义了用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker，它们能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作 NodeIterator类型NodeIterator:NodeIterator是较为简单那的一种类型，可以使用document.createNodeIterator()方法创建NodeIterator类型的新实例。这个方法接受下列4个参数： root：想要作为搜索起点的树中的节点 whatToShow：表示要访问哪些节点的数字代码 filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数 entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展(即为false) whatToshow参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。这个参数的值以常量形式在NodeFilter类型中定义， 如下所示： 1234567891011121314NodeFilter.SHOW_ALL：显示所有类型的节点NodeFilter.SHOW_ELEMENT：显示元素节点NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值NodeFilter.SHOW_TEXT：显示文本节点NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没有用NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用NodeFilter.SH0W_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用NodeFi1ter.SHOW_COMMENT：显示注释节点NodeFilter.SHOW_DOCUMENT：显示文档节点NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没有用NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没有用 例子：创建一个p节点迭代器 12345678var filter=&#123; acceptNode:function(node)&#123; return node.tagName.toLowerCase()==&quot;p&quot;?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP &#125;&#125;var iterator = document.createNodeIterator(root,NodeFilter.SHOW_ELEMENT,filter,false); 此外filter参数也可以是一个函数 1234var filter = function(node)&#123; return node.tagName.toLowerCase()==&quot;p&quot;?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP;&#125; 例如：var iterator = document.createNodeIterator(document,NodeFilter.SHOW_ALL,null,false)可以访问所有节点 NodeFilter中最主要的两个方式是：nextNode()和previousNode();顾名思义nextNode()表示向前一步，previousNodo()表示向后一步。在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点时，nextNode()返回null 示例12345678910111213141516171819&lt;div id=&quot;div1&quot;&gt; &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;world&lt;/p&gt; &lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;var div = document.getElementById(&quot;div1&quot;);var iterator = document.createNodeIterator(div,NodeFilter.SHOW_ELEMENT,null,false);var node = iterator.node;while(node!=null)&#123; console.log(node.tagName); node = iterator.nextNode();&#125; 若只想输出li标签，加一个过滤器 123456var filter =function(node)&#123; return node.tagName.toLowerCase()==&quot;li&quot;?NodeFilter.NODE_SHOW:NodeFilter.NODE_SKIP;&#125; var iterator = documentl.createNodeFilter(div,NodeFilter.SHOW_ELEMENT,filter,false); TreeWalker类型TreeWalker是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法: parentNode()：遍历到当前节点的父节点 firstChild()：遍历到当前节点的第一个子节点 lastChild()：遍历到当前节点的最后一个子节点 nextSibling()：遍历到当前节点的下一个同辈节点 previousSibling()：遍历到当前节点的上一个同辈节点 创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数与document.createNodelterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用TreeWalker来代替NodeIterator TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。使用TreeWalker遍历DOM树，即使不定义过滤器，也可以取得所有元素。 TreeWalker类型还有一个属性，名叫currentNode，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行的起点，如下所示 123var node = walker.nextNode();console.log(node === walker.currentNode);//truewalker.currentNode = document.body; //修改起点]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（5）]]></title>
    <url>%2F2017%2F07%2F07%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(5)%2F</url>
    <content type="text"><![CDATA[flex布局基本概念：采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 容器的属性flex-direction属性决定主轴的方向（即项目的排列方向）：1234.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行: 123.box&#123; flex-wrap: nowrap(不换行) | wrap(换行在第一行下方) | wrap-reverse(换行在第一行上方);&#125; flex-flow justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start(主轴起点) | flex-end | center | space-between(两端对齐，项目之间的间隔都相等) | space-around(每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍);&#125; align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start（交叉轴起点） | flex-end | center | baseline | stretch(如果项目未设置高度或设为auto，将占满整个容器的高度);&#125; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start（与交叉轴起点对齐）| flex-end | center | space-between | space-around | stretch;&#125; 项目的属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。数字越大所占比例越大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 示例1 单项目123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box&#123; width:500px; height:500px; border:1px solid blue; display:flex; justify-content: flex-end;/*center 居中。定义项目在主轴上的对齐方式*/ align-items:flex-end; /*定义在交叉轴上的位置*/ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;haha&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 示例2 多项目123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box&#123; width:500px; height:500px; border:1px solid blue; display:flex; flex-wrap: wrap; align-content: space-between; &#125; .column&#123; display: flex; flex-basis:100%; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;haha&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;hehe&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;hihi&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;lala&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 示例3 网格布局flex 实现圣杯三栏分布 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header&#123; border:1px solid red; &#125; footer &#123; border:1px solid green; &#125; .HolyGrail-body &#123; display: flex; flex: 1; &#125; .HolyGrail-content &#123; flex: 0 0 33.33%; border:1px solid blue; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; flex: 0 0 33.33%; border:1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;header&gt;这里是标题栏&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;div class=&quot;HolyGrail-content&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;HolyGrail-nav&quot;&gt;导航栏&lt;/div&gt; &lt;div class=&quot;HolyGrail-ads&quot;&gt;...&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;这里是角标&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 流式布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header&#123; border:1px solid red; &#125; footer &#123; border:1px solid green; &#125; .HolyGrail-body &#123; display: flex; flex-wrap:wrap; flex: 1; &#125; .HolyGrail-content &#123; box-sizing: border-box; flex: 0 0 33.33%; border:1px solid blue; height:200px; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ box-sizing: border-box; flex: 0 0 33.33%; border:1px solid blue; height:200px; &#125; .HolyGrail-last&#123; border:1px solid green; flex:0 0 30%; height:200px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;header&gt;这里是标题栏&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;div class=&quot;HolyGrail-content&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;HolyGrail-nav&quot;&gt;导航栏&lt;/div&gt; &lt;div class=&quot;HolyGrail-ads&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;HolyGrail-last&quot;&gt;...&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;这里是角标&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 水平垂直居中在不知道容器大小时可以使用1和2方法11234.parent&#123; display:flex; justify-content:center;&#125; 方法2123456789101112131415161718192021&lt;head&gt; &lt;style&gt; .parent&#123; position:relative; width:400px; height:400px; border:1px solid red; &#125; .child&#123; position: absolute; top:200px; left:200px; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;hahjkldsj;flaha&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（6）]]></title>
    <url>%2F2017%2F07%2F05%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(6)%2F</url>
    <content type="text"><![CDATA[伪类和伪元素w3c中的定义：CSS中伪类用于向某些选择器添加特殊的效果。CSS中伪元素用于将特殊的效果添加到某些选择器。 伪类种类有：:active : 将样式添加到被激活的元素:focus :将样式添加到被选中的元素:hover：将样式添加到鼠标浮动的元素上:link：将样式添加到未被访问过的链接:visited,:first-child,:lang; 伪元素种类：：before : 在某元素之前插入某些内容：after : 在某元素之后插入某些内容 优先级样式的优先级：内联样式(在元素中间的style)&gt;内部样式(&lt;style&gt;&lt;/style&gt;)&gt;外部样式（link标签引入） 选择器的优先级： 内联样式的优先级&gt;ID选择器&gt;伪类选择器(:visited,:acitive)&gt;属性选择器&gt;类选择器&gt;类型选择器&gt;通用选择器（*） 注意：当 !important 规则被应用在一个样式声明中时,该样式声明会覆盖CSS中任何其他的声明, 无论它处在声明列表中的哪里 盒子模型和box-sizing盒子模型：content+padding+border+margin box-sizing属性有两个值：content-box和border-box;当属性值为content-box时，维持其原有盒子模型的结构。 当属性值为border-box时，其设置的宽度为content_width+padding+border。可以通过告诉浏览器该元素中的padding和border来确定content的宽，高。 具体示例为：123456.element&#123; box-sizing:border-box; width:200px; padding:10px border:5px&#125; 则此时content-width为170px,而不是盒子模型的230px。 响应式布局：理论上，响应式界面能够适应不同的设备。简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。 这个概念是为解决移动互联网浏览而诞生的。 描述响应式界面最著名的一句话就是“Content is like water”，翻译成中文便是“如果将屏幕看作容器，那么内容就像水一样”。 性能优化的方法（1） 减少http请求次数 （2） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 （3） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 （4） 当需要设置的样式很多时设置className而不是直接操作style 常见会造成内存泄漏的操作内存泄漏指任何对象在不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 （1）setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 （2）闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 不用框架实现三级菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0; padding:0; &#125; li&#123; width:100px; height:30px; border:1px solid red; list-style:none; &#125; //利用相对定位和绝对定位解决位置之间的影响 li&#123; position:relative; &#125; li a&#123; display: block; text-decoration: none; height:30px; line-height: 30px; width:100px; text-align:center; &#125; .level1&#123; position:absolute; top:0; left:100px; &#125; .level2&#123; position: absolute; top:0; left:100px; &#125; .level1&#123; display: none; &#125; .leveel2&#123; display: none; &#125; #nav&gt;li:hover&gt;ul&#123; display: block; &#125; //1.父子元素之间的嵌套 //利用伪类元素实现隐藏和显示 #nav&gt;li:hover&gt;ul&gt;li&gt;ul&#123; display: none; &#125; #nav&gt;li&gt;ul&gt;li:hover&gt;ul&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页面&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt; &lt;ul class=&quot;level1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我们的故事&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;故事1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;故事2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;故事3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我们的团队&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 一个table，点击按钮，实现某一列的刷新1、获取表格的dom节点 2、通过rows和cells定位td单元格 3、通过修改innerHTML123456789101112&lt;body&gt;&lt;table id=&apos;test&apos;&gt; //定义一个table&lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;script&gt; var tb = document.getElementById(&apos;test&apos;);//获取表格的dom节点 var td = tb.rows[0].cells[0];//获取0行0列的td单元格 td.innerHTML = &apos;222&apos;;//动态修改表格的内容为222&lt;/script&gt;&lt;/body&gt; 循环遍历tr以及td，找到你要修改的td，然后修改它的内容给个例子：123for(var i=0;i&lt;table.rows.length;i++)for(var j=0;j&lt;rows.cells.length;i++)table.rows[i].cells[j].innerHTML=&quot;新的内容&quot;; 事件的绑定和移除对于事件的绑定的方法有多种多样，但是在解除绑定事件的时候，就要注意使用的是那种绑定事件的方法，因为不同的绑定方法所对应的解除事件是不同的。 方式1：绑定事件：对象.事件=事件处理函数。解除事件： 对象.事件=null (此方法就是函数的覆盖)1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var btn1= document.getElementById(&quot;btn1&quot;); var btn2 = document.getElementById(&quot;btn2&quot;); btn1.onclick = function()&#123; alert(&quot;btn1事件绑定成功！&quot;); &#125; btn2.onclick = function()&#123; btn1.onclick = null; alert(&quot;btn1所绑定的事件已经被移除！&quot;); &#125;&lt;/script&gt; 方式2：使用 attachEvent 、detachEvent、addEventListener 与 removeEventListener 事件绑定——attachEvent ，addEventListener 使用 attachEvent 和 addEventListenter 的好处就是，可以多次的进行事件的绑定，不向原始的方法那样，前面绑定的事件将会被后面的绑定的事件所覆盖，最后只能执行后面所绑定的函数。 123456789var btn1= document.getElementById(&quot;btn1&quot;); var btn2= document.getElementById(&quot;btn2&quot;); btn1.addEventListener(&quot;click&quot;,function()&#123; console.log(1); &#125;) btn1.addEventListener(&quot;click&quot;,function()&#123; console.log(2); &#125;)结果为：1,2 说明：1) addEventListener 是先绑定先执行，它将按顺序执行我绑定的事件，不会覆盖前面的事件。本质原因是监听事件每次都会生产一个全新的匿名函数，和前面的函数完全不同，自然不会覆盖 2) addEventListener 的第三个参数：布尔值参数是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序 3）attachEvent 只能兼容 IE7，IE8；绑定的事件前面要加“on” 事件移除用removeEventListener (1)在removeEventListener 传入的参数与 addEventListener 传入的参数要一致，看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的与第一个是完全不同的函数。 (2)因为移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除。 (3)在公用函数体存在参数的情况下，不能将带参数的函数体传给 addEventListener 和 romoveEventListener。 正确示例为:123456789&lt;script type=&quot;text/javascript&quot;&gt; var fun = function(e)&#123; e.preventDefault();//阻止事件目标的默认动作 alert(1); &#125; var btn1= document.getElementById(&quot;btn1&quot;); btn1.addEventListener(&apos;click&apos;,fun,false);//事件冒泡阶段 btn1.removeEventListener(&apos;click&apos;,fun,false);&lt;/script&gt; 事件冒泡和事件捕获冒泡捕获过程1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;outA&quot; style=&quot;width:400px; height:400px; background:#ff0000;position:relative;&quot;&gt; &lt;div id=&quot;outB&quot; style=&quot;height:200; background:#0000ff;top:100px;position:relative;&quot;&gt; &lt;div id=&quot;outC&quot; style=&quot;height:100px; background:#00ff00;top:50px;position:relative;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var outA = document.getElementById(&quot;outA&quot;); var outB = document.getElementById(&quot;outB&quot;); var outC = document.getElementById(&quot;outC&quot;); // 使用事件捕获 outA.addEventListener(&apos;click&apos;,function()&#123;console.log(1);&#125;,true); outB.addEventListener(&apos;click&apos;,function()&#123;console.log(2);&#125;,true); outC.addEventListener(&apos;click&apos;,function()&#123;console.log(3);&#125;,true); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; addEventListener第三个参数为true侦听事件为捕获阶段，当点击outc时输出为123，为false时，侦听事件以冒泡进行。点击outc输出为321。 Dom事件流DOM事件流：将事件分为三个阶段：捕获阶段、目标阶段、冒泡阶段。先调用捕获阶段的处理函数，其次调用目标阶段的处理函数，最后调用冒泡阶段的处理函数。 在outC（目标事件上）上注册的事件处理函数，属于DOM事件流中的目标阶段。目标阶段函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。 1234outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target1&quot;);&#125;,false);outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target2&quot;);&#125;,true);outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target3&quot;);&#125;,true);outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target4&quot;);&#125;,false); 所以上述代码按顺序进行执行。 阻止事件冒泡和捕获12345678910outC.addEventListener(&apos;click&apos;,function(event)&#123;alert(&quot;target2&quot;);event.stopPropagation()&#125;,true); outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target1&quot;);&#125;,true); // 事件冒泡 outA.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;bubble1&quot;);&#125;,false); outB.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;bubble2&quot;);&#125;,false); // 事件捕获 outA.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;capture1&quot;);&#125;,true); outB.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;capture2&quot;)&#125;,true); 阻值事件冒泡方法：function(event){event.stopPropagation()} js事件处理程序有哪几种1、HTML事件处理程序1234567&lt;input id=&quot;btn1&quot; value=&quot;按钮&quot; type=&quot;button&quot; onclick=&quot;showmsg();&quot;&gt;&lt;script&gt; function showmsg()&#123; alert(&quot;HTML添加事件处理&quot;); &#125;&lt;/script&gt; 即我们直接在HTML代码中添加事件处理程序，事件处理是直接嵌套在元素里头的，这样有一个毛病：就是html代码和js的耦合性太强，如果哪一天我想要改变js中showmsg，那么我不但要再js中修改，我还需要到html中修改。 2、DOM0级事件处理程序 即为指定对象添加事件处理，看下面的一段代码12345678&lt;input id=&quot;btn2&quot; value=&quot;按钮&quot; type=&quot;button&quot;&gt;&lt;script&gt; var btn2= document.getElementById(&quot;btn2&quot;); btn2.onclick=function()&#123; alert(&quot;DOM0级添加事件处理&quot;); &#125; btn.onclick=null;//如果想要删除btn2的点击事件，将其置为null即可&lt;/script&gt; 3、DOM2级事件处理程序 但是主要涉及到两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。它们都接收三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（是否在捕获阶段处理事件），看下面的一段代码 12345input id=&quot;btn3&quot; value=&quot;按钮&quot; type=&quot;button&quot;&gt;&lt;script&gt; var btn3=document.getElementById(&quot;btn3&quot;); btn3.addEventListener(&quot;click&quot;,showmsg,false);//这里我们把最后一个值置为false，即不在捕获阶段处理，一般来说冒泡处理在各浏览器中兼容性较好&lt;/script&gt; DOM0和DOM2之间的区别 区别：如果定义了两个dom0级事件，dom0级事件会覆盖 dom2不会覆盖，会依次执行 dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖 DOM api的API的扩展querySelector方法1234567var body = document.querySelector(&quot;body&quot;);//取得ID 为&quot;myDiv&quot;的元素var myDiv = document.querySelector(&quot;#myDiv&quot;);//取得类为&quot;selected&quot;的第一个元素var selected = document.querySelector(&quot;.selected&quot;);//取得类为&quot;button&quot;的第一个图像元素var img = document.body.querySelector(&quot;img.button&quot;) querySelectorAll()方法123456//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于getElementsByTagName(&quot;em&quot;)）var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);//取得类为&quot;selected&quot;的所有元素var selecteds = document.querySelectorAll(&quot;.selected&quot;);//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(&quot;p strong&quot;); 事件委托1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; ul&#123; border:1px solid blue; &#125; li&#123; border:1px solid red; &#125; #inner&#123; border:1px solid black; width:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;l2&quot;&gt;&lt;div id=&quot;inner&quot;&gt;2&lt;/div&gt;&lt;/li&gt; &lt;li id=&quot;l3&quot;&gt;3&lt;/li&gt; &lt;li id=&quot;l4&quot;&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul =document.getElementById(&quot;list&quot;); ul.addEventListener(&apos;click&apos;, function(e)&#123; var temp = e.target; while(temp.tagName!=&quot;LI&quot;)&#123; if(temp.tagName==&quot;UL&quot;)&#123; e.target=null; break; &#125; temp = temp.parentNode; &#125; console.log(e,e.target); alert(&apos;success&apos;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用事件流的捕获、冒泡特性，在父元素直接绑定事件。事件委托的最大作用：最大的用处便是监听动态增加的元素 注意：在&lt;li&gt;元素内部还存在子元素时，且事件触发在该子元素上，则委托无效。此时可以通过循环将父节点给到子节点完成事件委托绑定。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（4）]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(4)%2F</url>
    <content type="text"><![CDATA[节点修改API1.appendChild parent.appendChild(child); 2.insertBefore parentNode.insertBefore(newNode, refNode); 3. removeChild var deletedChild = parent.removeChild(childnode);返回删除的节点 4.replaceChild parent.replaceChild(newchild,oldchild); 父子关系APIparentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document，DocumentFragment； childNodes：返回一个实时的NodeList，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等； firstChild：返回第一个子节点，不存在返回null，与之相对应的还有一个firstElementChild； lastChild：返回最后一个子节点，不存在返回null，与之相对应的还有一个lastElementChild； 兄弟关系previousSibling：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。 nextSibling：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下 元素属性型API设置属性setAttribute,element.setAttribute(name,value);1document.getElementsByTagName(&quot;INPUT&quot;)[0].setAttribute(&quot;type&quot;,&quot;button&quot;); 获得属性getAttribute, var value=getAttribute(“id”);获取id的值 ## null和undefined的区别？ null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 http状态码 200 OK 正常返回信息 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） 线程和进程的区别一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 js运行机制详解js是单线程的与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下： （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（3）]]></title>
    <url>%2F2017%2F07%2F02%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(3)%2F</url>
    <content type="text"><![CDATA[## 判断数据类型方法 1.typeof(变量)。typeof用以获取一个变量的类型，typeof一般只能返回如下几个结果：number,boolean,string,function,object,undefined。我们可以使用typeof来获取一个变量是否存在。 12345678typeof(null)&quot;object&quot;typeof(undefined)&quot;undefined&quot;var a =&#123;&#125;;console.log(a instanceof Object) 2.根据constructor来判断。 123var a=&#123;&#125;,b=[];console.log(a.constructor==Object&amp;&amp;b.constructor==Array)结果：true 3.根据toString()方法来判断，是最通用的方法。 1234567var a=&quot;&quot;;console.log(Object.prototype.toString.call(a))结果： [object String]var a=&#123;&#125;,b=[];console.log(Object.prototype.toString.call(b))结果： &apos;[object Array]&apos; 正则方法使用test:pattern.test(string); exec: pattern.exec(string); 123var reg=/&lt;(\w+)(&gt;)/g;reg.exec(&quot;&lt;hksdjfttekj&gt;&quot;) [&quot;&lt;hksdjfttekj&gt;&quot;, &quot;hksdjfttekj&quot;, &quot;&gt;&quot;] exec返回匹配到的数组，第一个参数为匹配项，第二个参数为第一个捕获项，第三个参数为第二个捕获项 match: str.match(pattern)也是返回一个匹配的数组 replace: 示例11234var str = &quot;Apples are round, and apples are juicy.&quot;;var reg=/apples/ig;console.log(str.replace(reg,&apos;organce&apos;))结果 organce are round, and organce are juicy. 示例2当使用replace方法匹配时，假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么 $n 表示插入第 n 个括号匹配的字符串12345678910var re = /(\w+)\s(\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr);var str=&quot;bat hat cat &quot;;var reg=/((t))/ig;console.log(str.replace(reg,&quot;$1$2&quot;)) batt hatt catt 常用正则表达式总结验证数字：^[0-9]*$ 验证n位的数字：^\d{n}$ 验证至少n位数字：^\d{n,}$ 验证m-n位的数字：^\d{m,n}$ 验证零和非零开头的数字：^(0|[1-9][0-9]*)$ 验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 验证由数字、26个英文字母或者下划线组成的字符串：^\w+$ 验证用户密码:^[a-zA-Z]\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线 验证Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+))(.(w+(-w+)))(?S)?$ CDNCDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 跨域资源共享 CORS 详解需要浏览器和服务器同时支持。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求: （1) 请求方法是以下三种方法之一：HEAD，GET，POST （2）HTTP的头信息不超出以下几种字段：Accept；Accept-Language；Content-Language；Last-Event-ID；Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain；凡是不同时满足上面两个条件，就属于非简单请求。 简单请求 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123GET /cors HTTP/1.1；Origin: http://api.bob.com；Host: api.alice.com；Accept-Language: en-US；Connection: keep-alive；User-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。123456789var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。123456789OPTIONS /cors HTTP/1.1Origin: http://api.bob.com； Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.com； Accept-Language: en-USConnection: keep-alive； User-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 CORS与JSONP的使用目的相同，但是比JSONP更强大。 localStorage判断浏览器是否支持 1234if(window.localStorage)&#123; console.log(true)&#125;结果：true 可以通过setItem和getItem方法设置localStorage1234localStorage.setItem(&quot;haha&quot;,&quot;hello&quot;)console.log(localStorage.getItem(&quot;haha&quot;))hello Cookie、sessionStorage 和 localStroragesessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。 sessionStorage 、localStorage 和 cookie 之间的区别： 共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 html5（web sockets等）1 新的Doctype ：尽管使用&lt;!DOCTYPE html&gt;，即使浏览器不懂这句话也会按照标准模式去渲染 2 去掉link和script标签里面的type属性 3 Local Storage ：使用Local Storage可以永久存储大的数据片段在客户端（除非主动删除），目前大部分浏览器已经支持，在使用之前可以检测一下window.localStorage是否存在 4 语义化的header和footer 5 video audio的支持 6 web sockets（提供在一个单独的持久连接提供全双工，双向通信）的优点:能够在客户端和服务端之间发送非常少量的数据，而不必担心http那样的字节开销。注意：同源策略对web sockets不适用，因此可以通过它来打开任意站点的连接。 web sockets只能够发送文本数据，所以对于复杂数据结构，发送之前必须进行序列化步骤。 Label forfor 属性规定 label 与哪个表单元素绑定。 隐式和显式的联系：标记通常以下面两种方式中的一种来和表单控件相联系：将表单控件作为标记标签的内容(放在标签之间)，这样的就是隐式形式;或者为 标签下的 for 属性命名一个目标表单的id，这样就是显式形式。 清除浮动1.在需要清除浮动的父级元素内部的所有浮动元素后添加这样一个标签清除浮动clear:both; 2.使用该方法是只需在需要清除浮动的元素中定义CSS属性：overflow:auto，即可！”zoom:1″用于兼容IE6,也可以用width:100%。不过使用overflow的时候，可能会对页面表现带来影响，而且这种影响是不确定的，你最好是能在多个浏览器上测试你的页面 3.使用after伪对象清除浮动1234567.container:after&#123; display: block; content:&quot;&quot;; height:0; visibility:hidden; clear:both; &#125; 浏览器内核浏览器：IE，Chrome，FireFox，Safari，Opera。 内核：Trident，Gecko，Presto，Webkit。 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和js引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 dom基本操作创建新节点 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入appendChild() removeChild() replaceChild() insertBefore(newNode,nowNode) //在已有的子节点前插入一个新的子节点 查找 getElementsByTagName() //通过标签名称 getElementById() //通过元素Id，唯一性 getElementsByClassName()]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F07%2F01%2FvueJs(4)%2F</url>
    <content type="text"><![CDATA[过滤器(filter)的介绍Vue中过滤器是对于接口返回的字段进行业务(形式)上的转换。 vue实例在一些多页应用中，可以直接建立vue实例，然后通过&lt;script&gt;标签引入。 下面举一个过滤器在中使用的小例子：1234&lt;p&gt;&#123;&#123;data | formateMoney&#125;&#125;&lt;/p&gt;&lt;div v-for=&quot;(item,index) in formateSlice &quot;&gt;//以函数的形式，当有参数是则为formateMoney(value) 1234567891011121314151617181920212223242526272829303132333435363738394041new Vue(&#123; el:&quot;#app&quot;, //所对应需要渲染的部分块 data:&#123; getData:[] &#125;, filters:&#123; formateMoney:function(value)&#123;//这里传入进来的参数即为过滤器前的数值 return value+&quot;处理过程&quot; &#125; &#125;, computed:&#123; formateSplice:function()&#123; return this.getData.slice(0,n) &#125; &#125; mounted:function()&#123; //页面加载完成后所需进行的操作,只使用mounted钩子并不能保证实例已经插入文档，还需要在实例中包含vue.$nextTick this.$nextTick(function()&#123; this.cart(); &#125;) &#125;, methods:&#123; cart:function()&#123; this.$http.get().then(function()&#123; //调用vue-resource方法取数据，利用promise.then( res=&gt;&#123; this.getData=res.data; //这里使用箭头函数的好处在于，箭头函数无this指向，函数内的this指向外部，即函数内层的this和外层的this为同一指向 &#125; )方法完成回调 &#125;) &#125; &#125;,&#125;) vue实例包括一些，实例属性，实例方法，和实例事件使用方法详见官网API教程。 文档碎片在页面中有一个ul，我们随着页面的某一个事件的触发，需要向#box中插入大量的li，正常的写法为： 1234567var oUl = document.querySelectorAll(&apos;#box&apos;)[0]; for(var i=0;i&lt;1000;i++)&#123; var oLi = document.createElement(&apos;li&apos;); var t = document.createTextNode(i+&apos;&apos;); oLi.appendChild(t); oUl.appendChild(oLi);&#125; 这样是可以实现的，但是这样性能就无从提起了，因为每次oUl都重新绘制了一次，因为每次oUl都调用了appendChild方法，所以，就要借助一个叫文档碎片frag的东西，创建一个文档碎片： 1234567891011var frag = document.createDocumentFragment(), oLi = null, t = &apos;&apos;, oUl = document.querySelectorAll(&apos;#box&apos;)[0]; for(var i = 0;i &lt; 10;i++)&#123; oLi = document.createElement(&apos;li&apos;); t = document.createTextNode(i + &apos;&apos;); oLi.appendChild(t); frag.appendChild(oLi); &#125; console.log(frag); 这样也就触发了一次oUl的重新绘制,性能上会大大提高。在为DOM树添加新节点时文档碎片是非常有用的 vue的mvvm源码实现双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view 双向数据绑定原理从m到v: 数据劫持:vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 从v到m(数据绑定关系的识别过程) 在vue中通过在HTML中添加指令的方式，将视图元素与数据的绑定关系进行声明 123&lt;form id=&quot;test&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;/form&gt; 123456var vm = new Vue(&#123; el: &apos;#test&apos;, data: &#123; name: &apos;luobo&apos; &#125;&#125;) 由于双向数据绑定已经建立，因此：执行 vm.name = ‘mickey’ 后，页面上 input 也会更新为显示： mickey。在页面文本框中修改内容为：tang，则通过vm.name 获取的值为：”tang”。那么初始化的过程中，Vue 是如何识别出这种绑定关系的呢？ 具体过程是：在初始化过程中（new Vue() 执行时），主要执行两个步骤： （1）compile：compile 过程中，对于给定的目标元素进行解析，识别出所有绑定在元素（通过 el 属性传入）上的指令。compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 （2）link：link过程中，建立这些指令与对应数据（通过 data 属性传入初始值）的绑定关系，并以数据的初始值进行渲染。绑定关系建立后，就可以双向同步数据了 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 实现思路： 1.实现数据监听器observer,重新定义data，为data上每个属性增加setter,getter以监听数据的变化 2.实现指令解析器compile,扫描模版template，提取每个dom节点中的指令信息，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的节点更新函数。因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中 3.实现directive,通过指令信息实例化对应的directive实例,不同类型的directive拥有不同的刷新函数update 4.实现watcher,作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，让observer的属性监听函数与directive的update函数做一一对应,以实现数据变化后更新视图。 主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退 5.mvvm入口函数，整合以上三者 掘金流程实现MVVM过程： 首先将该任务分成几个子任务： 1、输入框以及文本节点与data中的数据绑定 2、输入框内容变化时，data中的数据同步变化。即view =&gt; model的变化。 3、data中的数据变化时，文本节点的内容同步变化。即model =&gt; view的变化。 要实现任务一，需要对DOM进行编译，这里有一个知识点：DocumentFragment。 （1）DocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到DOM中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用DocumentFragment处理节点，速度和性能远远优于直接操作DOM。Vue进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持）到DocumentFragment中，经过一番处理后，再将DocumentFragment整体返回插入挂载目标。 （2）再来看任务二的实现思路：当我们在输入框输入数据的时候，首先触发input事件（或者keyup、change事件），在相应的事件处理程序中，我们获取输入框的value并赋值给vm实例的text属性。我们会利用defineProperty将data中的text劫持为vm的访问器属性，因此给vm.text赋值，就会触发set方法。在set方法中主要做两件事，第一是更新属性的值]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试（2）]]></title>
    <url>%2F2017%2F07%2F01%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、从输入网址到显示网页的过程分析1、应用层DNS解析域名：客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。 2、浏览器与服务器建立TCP连接（默认端口80）(详细点可以说下三次握手的过程) 3、应用层客户端发送HTTP请求。 4、服务器响应请求：查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码（200-300，成功；304使用缓存）。 5、服务器返回相应文件给浏览器。 6、Tcp连接释放(可以说下四次挥手的过程)。 7、浏览器对HTML文件进行解析构建DOM树 ，构建渲染树 ，js根据DomAPI操作执行绑定事件等，页面显示完成。 三次握手协议SYN：表示同步序号，用来建立连接；SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1 ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 float属性值为:left,right,none;元素会分别左移，右移，直到触碰到容器为止。当块级元素没有设置宽度，但是却设置了float属性(right,left)时，元素的宽度随内容的变化而变化。 清除浮动方法：clear:both;同时设置width:100%(或固定宽度)+overflow:hidden; positionpostion可拥有三种定位形式：静态定位，相对定位，绝对定位，对应的属性值有四个：分别为static(静态定位),relative(相对定位),absolute(绝对定位),fixed(固定定位)，其中最后两种属于绝对定位。 各类定位特点： 相对定位：相对于自身原有位置偏移，仍然处于标准文档流中。 绝对定位：建立了以包含块为基准的的定位，脱离的标准文档流。当一个元素设置了绝对定位但是没有设置宽度，元素的宽度会随着内容而变化。 脱离文档流的操作有： 绝对定位absolute,固定定位fixed，浮动float。 三栏式布局container的宽度固定并垂直居中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;This is my title&lt;/title&gt; &lt;style&gt; #big-box&#123; border:1px solid blue; width:650px; height:400px;/*块级元素定义宽度，高度*/ margin:0 auto;/*元素水平居中*/ /*margin用法可以有1,2,3,4个参数*/ &#125; #header&#123; /*块级元素不设置宽度时，宽度随着内容的变化而变化*/ padding:auto; border:1px solid blue; margin-top:10px; margin-left:10px; margin-right:10px; &#125; #left&#123; border:1px solid blue; margin-left:10px; height:250px; width:175px; float:left; &#125; #main&#123; border:1px solid blue; height:250px; width:250px; margin:0 auto; /*margin-left:10px;margin-right:10px*/通过这种设置让左右两边距离相同 &#125; #right&#123; border:1px solid blue; margin-right:10px; margin-top:-250px; height:250px; width:175px; float:right; &#125; #footer&#123; margin-top:10px; border:1px solid blue; clear:both; margin-left:10px; margin-right:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;big-box&quot;&gt; &lt;p id = &quot;header&quot;&gt;header header header header header header header header header header&lt;/p&gt; &lt;div id=&quot;left&quot;&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;right&quot;&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;/div&gt; &lt;p id = &quot;footer&quot;&gt;footer footer footerfooter footer footerfooter footer footerfooter footer footerfooter footer&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 两栏布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;This is my title&lt;/title&gt; &lt;style&gt; #big-box&#123; display:block; border:1px solid blue; width:640px; height:410px; margin:auto; &#125; #header&#123;/* padding:auto;*/ border:1px solid blue; margin-top:10px; margin-left:10px; margin-right:10px; &#125; #left&#123; border:1px solid blue; margin-left:10px; width:240px; height:265px; float:left; text-align:center; &#125; #left12&#123; height:125px; border:1px solid blue; margin:5px; &#125; #left1&#123; border:1px solid blue; margin:3px; float:left; height:110px; &#125; #left2&#123; border:1px solid blue; margin-left:auto; margin-top:3px; margin-right:3px; height:110px; width:100px; &#125; #left3&#123; border:1px solid blue; margin:5px; height:125px; &#125; #main&#123; border:1px solid blue; margin-left:auto; margin-right:10px; height:265px; width:370px; &#125; #footer&#123; border:1px solid blue; margin-top:10px; margin-left:10px; margin-right:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;big-box&quot;&gt; &lt;p id = &quot;header&quot;&gt;header header header header header header header header header header&lt;/p&gt; &lt;div id=&quot;left&quot;&gt; &lt;div id=&quot;left12&quot;&gt; &lt;div id=&quot;left1&quot;&gt; &lt;p&gt;left1 left1 left1&lt;/p&gt; &lt;p&gt;left1 left1 left1&lt;/p&gt; &lt;p&gt;left1 left1 left1&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;left2&quot;&gt; &lt;p&gt;left2 left2 &lt;/p&gt; &lt;p&gt;left2 left2 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left3&quot;&gt; &lt;p&gt;left3 left3 left3&lt;/p&gt; &lt;p&gt;left3 left3 left3&lt;/p&gt; &lt;p&gt;left3 left3 left3&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;footer&quot;&gt;footer footer footerfooter footer footerfooter footer footerfooter footer footerfooter footer&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html 注意：页面布局从外往里，熟悉相关属性方法，层层思考。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F30%2Fvue(3)%2F</url>
    <content type="text"><![CDATA[Vue基础知识虚拟dom的概念在一个HTML中，DOM节点通常表示如下：1234&lt;ul id=&apos;myId&apos;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt;&lt;ul&gt; DOM 节点也可以表示 JavaScript 中的对象，像这样：1234567Let domNode = &#123; tag: &apos;ul&apos; attributes: &#123; id: &apos;myId&apos; &#125; children: [ // where the LI&apos;s would go ]&#125;; 这就是我们的“虚拟”DOM，更新虚拟节点的开销不大，1domNode.children.push(&apos;&lt;ul&gt;Item 3&lt;/ul&gt;&apos;); 当使用虚拟DOM，而不是直接在代码中调用类似.getElementById的DOM API方法，操作就会像改变JS对象一样非常的简单省时。所有的操作均在虚拟dom中实现，最后一次性完成dom渲染。 Vue2.0的版本对于之前的版本进行了很大的瘦身，如果原生js能够实现的，就舍弃vue，直接用原生js实现。 过滤器(filter)的介绍Vue中过滤器是对于接口返回的字段进行业务(形式)上的转换。 vue实例在一些多页应用中，可以直接建立vue实例，然后通过标签引入。 下面举一个过滤器在中使用的小例子：1234&lt;p&gt;&#123;&#123;data | formateMoney&#125;&#125;&lt;/p&gt;&lt;div v-for=&quot;(item,index) in formateSlice &quot;&gt;//以函数的形式，当有参数是则为formateMoney(value) 1234567891011121314151617181920212223242526272829303132333435363738394041new Vue(&#123; el:&quot;#app&quot;, //所对应需要渲染的部分块 data:&#123; getData:[] &#125;, filters:&#123; formateMoney:function(value)&#123;//这里传入进来的参数即为过滤器前的数值 return value+&quot;处理过程&quot; &#125; &#125;, computed:&#123; formateSplice:function()&#123; return this.getData.slice(0,n) &#125; &#125; mounted:function()&#123; //页面加载完成后所需进行的操作,只使用mounted钩子并不能保证实例已经插入文档，还需要在实例中包含vue.$nextTick this.$nextTick(function()&#123; this.cart(); &#125;) &#125;, methods:&#123; cart:function()&#123; this.$http.get().then(function()&#123; //调用vue-resource方法取数据，利用promise.then( res=&gt;&#123; this.getData=res.data; //这里使用箭头函数的好处在于，箭头函数无this指向，函数内的this指向外部，即函数内层的this和外层的this为同一指向 &#125; )方法完成回调 &#125;) &#125; &#125;,&#125;) vue实例包括一些，实例属性，实例方法，和实例事件使用方法详见官网API教程。 文档碎片在页面中有一个ul，我们随着页面的某一个事件的触发，需要向#box中插入大量的li，正常的写法为： 1234567var oUl = document.querySelectorAll(&apos;#box&apos;)[0]; for(var i=0;i&lt;1000;i++)&#123; var oLi = document.createElement(&apos;li&apos;); var t = document.createTextNode(i+&apos;&apos;); oLi.appendChild(t); oUl.appendChild(oLi);&#125; 这样是可以实现的，但是这样性能就无从提起了，因为每次oUl都重新绘制了一次，因为每次oUl都调用了appendChild方法，所以，就要借助一个叫文档碎片frag的东西，创建一个文档碎片： 1234567891011var frag = document.createDocumentFragment(), oLi = null, t = &apos;&apos;, oUl = document.querySelectorAll(&apos;#box&apos;)[0]; for(var i = 0;i &lt; 10;i++)&#123; oLi = document.createElement(&apos;li&apos;); t = document.createTextNode(i + &apos;&apos;); oLi.appendChild(t); frag.appendChild(oLi); &#125; console.log(frag); 这样也就触发了一次oUl的重新绘制,性能上会大大提高。在为DOM树添加新节点时文档碎片是非常有用的 vue的mvvm源码实现双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view 双向数据绑定原理从m到v: 数据劫持:vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 从v到m(数据绑定关系的识别过程) 在vue中通过在HTML中添加指令的方式，将视图元素与数据的绑定关系进行声明 123&lt;form id=&quot;test&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;/form&gt; 123456var vm = new Vue(&#123; el: &apos;#test&apos;, data: &#123; name: &apos;luobo&apos; &#125;&#125;) 由于双向数据绑定已经建立，因此：执行 vm.name = ‘mickey’ 后，页面上 input 也会更新为显示： mickey。在页面文本框中修改内容为：tang，则通过vm.name 获取的值为：”tang”。那么初始化的过程中，Vue 是如何识别出这种绑定关系的呢？ 具体过程是：在初始化过程中（new Vue() 执行时），主要执行两个步骤： （1）compile：compile 过程中，对于给定的目标元素进行解析，识别出所有绑定在元素（通过 el 属性传入）上的指令。compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 （2）link：link过程中，建立这些指令与对应数据（通过 data 属性传入初始值）的绑定关系，并以数据的初始值进行渲染。绑定关系建立后，就可以双向同步数据了 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 实现思路： 1.实现数据监听器observer,重新定义data，为data上每个属性增加setter,getter以监听数据的变化 2.实现指令解析器compile,扫描模版template，提取每个dom节点中的指令信息，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的节点更新函数。因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中 3.实现directive,通过指令信息实例化对应的directive实例,不同类型的directive拥有不同的刷新函数update 4.实现watcher,作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，让observer的属性监听函数与directive的update函数做一一对应,以实现数据变化后更新视图。 主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退 5.mvvm入口函数，整合以上三者 掘金流程实现MVVM过程： 首先将该任务分成几个子任务： 1、输入框以及文本节点与data中的数据绑定 2、输入框内容变化时，data中的数据同步变化。即view =&gt; model的变化。 3、data中的数据变化时，文本节点的内容同步变化。即model =&gt; view的变化。 要实现任务一，需要对DOM进行编译，这里有一个知识点：DocumentFragment。 （1）DocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到DOM中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用DocumentFragment处理节点，速度和性能远远优于直接操作DOM。Vue进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持）到DocumentFragment中，经过一番处理后，再将DocumentFragment整体返回插入挂载目标。 （2）再来看任务二的实现思路：当我们在输入框输入数据的时候，首先触发input事件（或者keyup、change事件），在相应的事件处理程序中，我们获取输入框的value并赋值给vm实例的text属性。我们会利用defineProperty将data中的text劫持为vm的访问器属性，因此给vm.text赋值，就会触发set方法。在set方法中主要做两件事，第一是更新属性的值]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(9)]]></title>
    <url>%2F2017%2F06%2F29%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(9)%2F</url>
    <content type="text"><![CDATA[装饰者模式装饰者模式能够在不改变对象自身的基础上，在程序运行期间为对象动态的增加新的职责。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。其作用实际就是为对象动态地加入新的职责和行为。 用AOP装饰函数1234567891011121314151617181920Function.prototype.before=function(beforefn)&#123; var self=this; //保存原函数的引用 return function()&#123; beforefn.apply(this,arguments); //执行新函数，且保证this不会被劫持，新的函数的参数也会被原封不动的传入原函数，新函数在原函数之前执行(共用一组参数列表) return self.apply(this,arguments); //执行原函数，并且返回原函数执行结果，并且保证this不会被劫持 &#125;&#125;Function.prototype.after=function(afterfn)&#123; var self=this; //返回一个代理函数，代理函数分别执行新函数与原函数 return function()&#123; var ret=self.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125; 也可以在不污染原型的情况下，做出一些变通，123456789101112var before=function(fn,beforefn)&#123; return function()&#123; beforefn.apply(this,arguments); return fn.apply(this,arguments); &#125;&#125;var a =before(function()&#123;console.log(1)&#125;,function()&#123;console.log(2)&#125;);a=before(a,function()&#123;console.log(5)&#125;);a();结果： 5 2 1 利用AOP装饰函数的技巧，可以把行为依照职责分成粒度更加细的函数，随后将它们装饰合并到一起，有利用一个松耦合高复用的系统。 利用AOP动态改变函数的参数1234567891011121314151617Function.prototype.before=function(fn)&#123; var self=this; return function()&#123; fn.apply(this,arguments); return self.apply(this,arguments); &#125;&#125;var func=function(para)&#123; console.log(para)&#125;func=func.before(function(para)&#123; para.b=&apos;b&apos;;&#125;)func(&#123;a:&apos;a&apos;&#125;)结果：Object &#123;a: &quot;a&quot;, b: &quot;b&quot;&#125; 值得注意的是：Function.prototype.before或者Function.prototype.afte被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会发生丢失。1234567891011121314151617181920Function.prototype.before=function(fn)&#123; var self=this; return function()&#123; fn.apply(this,arguments); return self.apply(this,arguments); &#125;&#125;var func=function(haha)&#123; console.log(haha)&#125;//原函数的属性func.a=&apos;a&apos;func=func.before(function(para)&#123; para.c=&apos;c&apos;;&#125;)func(&#123;b:&apos;b&apos;&#125;)//属性发生了丢失Object &#123;b: &quot;b&quot;, c: &quot;c&quot;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(10)]]></title>
    <url>%2F2017%2F06%2F29%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(10)%2F</url>
    <content type="text"><![CDATA[状态模式状态模式的关键在于区分事物内部的状态，事物内部状态的改变往往会带来行为的改变 通常我们谈到的封装，一般会优先封装状态的行为，但是在状态模式中正好相反，状态模式的关键是将事物的每种状态都封装成单独的类，与此种状态有关的行为也会被封装在这个类的内部。 状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 将这句话拆分开来解释的话就是：将状态封装成独立的类，并将请求委托给当前的状态对象，当对象内部状态发生改变时，会通过改变行为带来不同的变化。我们使用的对象，在不同状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//定义一个Light类（context），随后在Light类的构造函数中创建每个状态类的实例对象，context将持有这些状态对象的引用，以便把请求委托给状态对象。var Light=function()&#123; this.offLightState= new OffLightState(this); this.weakLightState=new WeakLightState(this); this.strongLightState=new StrongLightState(this); this.button=null;&#125;Light.prototype.init=function()&#123; var button =document.createElement(&apos;button&apos;); self=this; this.button=document.body.appendChild(button); this.button.innerHTML=&apos;开关&apos;; this.currState=this.offLightState; this.button.onclick=function()&#123; self.currState.buttonWasPressed(); &#125;&#125;//建立每个状态类var OffLightState=function(light)&#123; this.light=light;&#125;OffLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;weaklight&apos;); this.light.setState(this.light.weakLightState);&#125;var WeakLightState=function(light)&#123; this.light=light;&#125;WeakLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;stronglight&apos;); this.light.setState(this.light.strongLightState);&#125;var StrongLightState=function(light)&#123; this.light=light;&#125;StrongLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;offlight&apos;); this.light.setState(this.light.offLightState);&#125;//设置状态Light.prototype.setState=function(newState)&#123; this.currState.newState;&#125;var light=new Light();light.init(); 状态模式的优点 1.定义了状态和行为之间的关系，并将其封装在一个类中。通过增加新的状态类，很容易增加新的状态和转换。 2.Context中的请求动作和状态类中的封装的行为可以非常容易的独立变化而不相互影响。 1234567891011121314151617181920212223242526272829303132var Light=function()&#123; this.currState=FSM.off; this.button=null;&#125;Light.prototype.init=function()&#123; var button=document.createElement(&apos;button&apos;); self=this; this.button.onclick=function()&#123; //把请求委托给FSM状态机 self.currState.buttonWasPressed.call(self); &#125;&#125;var FSM=&#123; off:&#123; buttonWasPressed:function()&#123; console.log(&apos;关灯&apos;); this.currState=FSM.on; &#125; &#125;, on:&#123; buttonWasPressed:function()&#123; console.log(&apos;开灯&apos;); this.currState=FSM.off; &#125; &#125;&#125;var light=new Light();light.init(); 利用call()方法直接把请求委托给某个字面量对象来执行。 设计原则1.单一职责原则：一个对象(方法)只做一件事情，即将对象划分为较小的粒度使用。 2.最少知识原则：提供中介、只暴露必须的API接口，降低对象之间的耦合。 3.开放-封闭原则：软件实体（模块，类，函数等）应该是可以扩展的但是不可以修改(AOP扩展) 常用的方法来保证开放-封闭原则： 1.用对象的多态性(同一消息对不同对象产生不同效果)来消除条件分支语句。 2.放置挂钩。利用挂钩的结果来决定程序的下一步走向。 3.使用回调函数。回调函数是一种特殊的挂钩，可以把一部分易于变化的部分封装在回调函数里，然后回调函数当做参数传入一个稳定的封闭函数中。当回调函数被执行时，程序就会因为回调函数内部的逻辑不同而产生不同的效果。 写代码需要注意：提炼函数、合并重复条件片段、合理使用循环、传递对象参数代替过长的参数列表、尽量减少参数数量、使用return退出多重循环]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F29%2FVue%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[Vue中组件之间的通信父组件可以通过调用子组件的形式来在父组件的模板中渲染出子组件的内容，当然，父组件也可以通过组件属性，向子组件传递信息。 ## 示例1 父组件向子组件中传递信息 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;hello&gt;&lt;/hello&gt; **//定义message属性，并将属性值传回子组件 &lt;testComponent message=&quot;welcome to the App&quot; &gt;&lt;/testComponent&gt;** &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Hello from &apos;./components/Hello&apos;import TestComponent from &apos;./components/TestComponent&apos;import Store from &apos;./store&apos;export default &#123; name: &apos;app&apos;, data()&#123; return&#123; msg: &apos;Welcome to Your Vue.js App&apos;, &#125; &#125;, components: &#123; Hello, TestComponent &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.finished&#123; text-decoration:underline;&#125;&lt;/style&gt; 子组件中通过props:[]接受属性，此时在子组件即可对接受到的值进行渲染1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;acceptMessage&quot;&gt; acceptMessage&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;testComponent&apos;, data () &#123; return &#123; msg:&apos;Here is testComponent&apos; &#125; &#125;, props:[&quot;message&quot;], methods:&#123; acceptMessage:function()&#123; //直接调用父组件的信息进行渲染 this.msg = this.message; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125; 示例2子组件向父组件中传递信息通过以上可知，父组件是使用props传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！ 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;hello&gt;&lt;/hello&gt; &lt;testComponent message=&quot;welcome to the App&quot; v-on:messageFromChild=&quot;messageFromChildren&quot;&gt;&lt;/testComponent&gt; //自定义事件messageFromChild,即接受到子组件发出事件messageFromcChild后，执行messageFromChildren方法 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Hello from &apos;./components/Hello&apos;import TestComponent from &apos;./components/TestComponent&apos;import Store from &apos;./store&apos;export default &#123; name: &apos;app&apos;, data()&#123; return&#123; msg: &apos;Welcome to Your Vue.js App&apos;, &#125; &#125;, components: &#123; Hello, TestComponent &#125;, methods:&#123; messageFromChildren:function()&#123; this.msg= &quot;I&apos;m child&quot; &#125; &#125;&#125;&lt;/script&gt; 子组件中 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;acceptMessage&quot;&gt; acceptMessage&lt;/button&gt; &lt;button @click=&apos;sendMessage&apos;&gt;sendMessage&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;testComponent&apos;, data () &#123; return &#123; msg:&apos;Here is testComponent&apos; &#125; &#125;, props:[&quot;message&quot;], methods:&#123; acceptMessage:function()&#123; this.msg=this.message; &#125;, sendMessage:function()&#123; //通过点击按钮，触发自定义事件messageFromChild //$emit(a,b)也可以将所需传递的参数b发送到父组件 ** this.$emit(&apos;messageFromChild&apos;);** &#125; &#125;&#125;&lt;/script&gt; 以前的方法中还可以使用$dispatch和$broadcast来向上、向下传递信息，但是它们连同events使用在Vue.2.x中已经被弃用！ 此外，Vue作为一个框架，还有作为数据层面以Ajax(Vue-resource)和服务端交互，还有就是作为单页面应用时路由功能(Vue-router库)。 对于开发中的其他问题，可以查看Vue的官方开发文档，以及Vue的论坛forum.vuejs.org的中文板块]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(8)]]></title>
    <url>%2F2017%2F06%2F28%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(8)%2F</url>
    <content type="text"><![CDATA[职责链模式定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，再将这些对象练成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。 异步的职责链1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Chain=function(fn)&#123; this.fn=fn; this.successor=null;&#125;//指定在链中的下一个节点Chain.prototype.setNextSuccessor=function(successor)&#123; return this.successor=successor;&#125;//传递请求给某节点Chain.prototype.passRequest=function()&#123; var ret = this.fn.apply(this,arguments); if(ret==&apos;nextSuccessor&apos;)&#123; return this.successor&amp;&amp;this.successor.passRequest.apply(this.successor,arguments); &#125;&#125;Chain.prototype.next=function()&#123; return this.successor.passRequest.apply(this.successor,arguments);&#125;var fn1=new Chain(function()&#123; console.log(1); return &apos;nextSuccessor&apos;;&#125;)var fn2=new Chain(function()&#123; console.log(2); var self=this; setTimeout(function()&#123;self.next()&#125;,1000); return &apos;nextSuccessor&apos;&#125;)var fn3=new Chain(function()&#123; console.log(3); return &apos;nextSuccessor&apos;;&#125;)var fn4=new Chain(function()&#123; console.log(4);&#125;)fn1.setNextSuccessor(fn2);fn2.setNextSuccessor(fn3);fn3.setNextSuccessor(fn4);fn1.passRequest();VM835:24 1VM835:29 2VM835:36 3VM835:41 4一秒过后VM835:36 3VM835:41 4 除此之外，也可以用AOP实现职责链。 中介者模式其作用是解除对象与对象之间的紧耦合关系。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; 选择颜色:&lt;select id=&quot;colorSelect&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;红色&lt;option&gt; &lt;option value=&quot;blue&quot;&gt; 蓝色&lt;/option&gt; &lt;/select&gt; 输入购买量:&lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt; 你选择的颜色:&lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt; 你输入的数量:&lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt; &lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和数量&lt;/button&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var colorSelect=document.getElementById(&quot;colorSelect&quot;), numberInput=document.getElementById(&quot;numberInput&quot;), colorInfo=document.getElementById(&quot;colorInfo&quot;), numberInfo=document.getElementById(&quot;numberInfo&quot;), nextBtn=document.getElementById(&apos;nextBtn&apos;); var goods=&#123;&apos;red&apos;:3,&apos;blue&apos;:6&#125;; colorSelect.onchange=function()&#123; var color=this.value, number=numberInput.value, stock=goods[color]; colorInfo.innerHTML=color; if(!color)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot;; return; &#125; if(number&gt;stock)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;库存不足&quot;; return; &#125; nextBtn.disalbed=false; nextBtn.innerHTML=&quot;放入购物车&quot;; &#125; numberInput.oninput=function()&#123; var color=this.value, number=numberInput.value, stock=goods[color]; numberInfo.innerHTML=number; if(color==&quot;&quot;)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot; &#125; if(number&gt;stock)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;库存不足&quot;; &#125;else&#123; nextBtn.disalbed=false; nextBtn.innerHTML=&quot;放入购物车&quot;; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 使用中介者模式改变之后，所有的节点只和中介者进行通信，当下拉框colorSelect和文本输入框numberInput发生了事件变化时，它们仅仅通知中介者它们发生了改变，同时把自身以参数的形式传入中介者，以便中介者辨别是谁发生了改变。12345678910111213141516171819202122232425262728293031var mediator=(function()&#123; var colorSelect=document.getElementById(&quot;colorSelect&quot;), numberInput=document.getElementById(&quot;numberInput&quot;), colorInfo=document.getElementById(&quot;colorInfo&quot;), numberInfo=document.getElementById(&quot;numberInfo&quot;), nextBtn=document.getElementById(&apos;nextBtn&apos;); var goods=&#123;&apos;red&apos;:3,&apos;blue&apos;:4&#125;; return&#123; changed:function(obj)&#123; var color=colorSelect.value, number=numberInput.value, stock=goods[color]; colorInfo.innerHTML=color; if(obj===colorSelect)&#123; colorInfo.innerHTML=color; &#125;else if(obj==numberInput)&#123; numberInfo.innerHTML=number; &#125; if(!color)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot;; return; &#125; &#125; &#125; &#125;)()colorSelect.onchange=function()&#123; console.log(this); mediator.changed(this); &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5基础知识]]></title>
    <url>%2F2017%2F06%2F28%2FH5%E7%94%BB%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Canvas基础知识示例：canvas基本方法使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var cxt=c.getContext(&quot;2d&quot;); //画长方形，参数分别为坐标x,y,width,height cxt.fillStyle=&quot;#00FF00&quot;;//设置填充颜色 cxt.lineWidth=5;// 设置线条宽度 cxt.fillRect(100,100,50,100); //画边框 cxt.strokeStyle=&quot;#FF0000&quot;;//设置线条颜色 &quot;#FF0000&quot;==&quot;rgb(255,0,0)&quot; cxt.strokeRect(0,0,150,75); //画线&amp;&amp;也可用于画复杂图形，例如三角 cxt.beginPath(); cxt.moveTo(50,50); cxt.lineTo(50,60); cxt.closePath(); cxt.stroke(); //画圆 cxt.beginPath(); //6个参数分别为：圆心坐标想x,y，圆的半径，开始角度，结束角度，逆顺时针（逆时针用true,顺时针用false）; //注意：这里的角度以弧度为单位 cxt.arc(230,90,50,0,Math.PI*2,false); cxt.stroke(); cxt.closePath(); //填充圆 cxt.fill(); //清除填充，参数分别为起点坐标x,y,宽度width和高度height cxt.clearRect(230,90,50,50); //画轮廓 cxt.stroke(); &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5基础知识(2)]]></title>
    <url>%2F2017%2F06%2F28%2FH5%E7%94%BB%E5%B8%832%2F</url>
    <content type="text"><![CDATA[Canvas的一些高级功能示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; var canvas=$(&quot;#mycanvas&quot;); var context=canvas.get(0).getContext(&quot;2d&quot;); context.fillRect(40,40,100,100); &#125;) &lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var cxt=c.getContext(&quot;2d&quot;); cxt.fillStyle=&quot;rgb(255,0,0)&quot;; //红色压栈 cxt.save(); cxt.fillRect(50,50,100,100); cxt.fillStyle=&quot;rgb(0,255,0)&quot;; //绿色压栈 cxt.save(); cxt.fillRect(200,50,100,100); //自动取出栈中的最后状态,绿色 cxt.restore(); cxt.fillRect(350,50,100,100); //红色 cxt.restore(); cxt.fillRect(50,200,100,100); //平移 cxt.fillRect(0,0,20,20); cxt.translate(150,150); //平移后的显示，之后所有操作均带有平移属性 cxt.fillRect(0,0,20,20); //之后的所有操作均带有旋转属性 cxt.rotate(0.7854);//旋转45度(Math.PI/4); cxt.fillRect(150,150,40,40); //合成 cxt.fillStyle=&quot;rgb(63,169,245)&quot;; cxt.fillRect(200,50,100,100); cxt.globalAlpha=0.5; cxt.fillStyle=&quot;rgb(255,123,172)&quot;; cxt.fillRect(250,100,100,100); //阴影 cxt.shadowBlur=20; cxt.shadowColor=&quot;rgb(0,0,0)&quot;; cxt.fillRect(10,10,50,50);s &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js基础]]></title>
    <url>%2F2017%2F06%2F28%2FReactJs%2F</url>
    <content type="text"><![CDATA[基础知识示例11234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .test&#123; color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; var Hello=React.createClass(&#123; render:function()&#123; var styleObject=&#123;color:&apos;blue&apos;,fontSize:&apos;50px&apos;&#125; return &lt;div className=&quot;test&quot;&gt;&#123;this.props.title&#125; hello &#123;this.props.name&#125;&lt;/div&gt; &#125; &#125;) React.render(&lt;Hello name=&quot;world&quot; title=&quot;first one&quot; /&gt;, document.getElementById(&quot;root&quot;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件的声明周期三个状态（每个状态封装了自己的hook函数）： 1.Mounted:指的是React Components被render解析生成对应的DOM节点，并被插入浏览器的DOM结构的一个过程 2.Updating:指的是一个mounted的React Components被重新render的过程。方法是比较相邻两次render()时的state,当state发送改变且影响DOM结构时，重建渲染DOM树 3.Unmounted:指的是mounted的组件被移除，从DOM树中移除DOM节点 Mounted状态的hook函数顺序：getDefaultProps()=&gt;getInitialState()=&gt;componentWillMount=&gt;render=&gt;componentDidMount Updating的过程：componentWillReceiveProps（接受新的props，在函数体内比较老旧props,从而执行一些类似于修改state的操作）=&gt;shouldComponentUpdate（接收到新的props和state之后判断是否有必要去更新dom结构，返回true需要更新，反之亦然）=&gt;componentWillUpdate=&gt;render=&gt;componentDidUpdate Unmounting过程：componentWillUnmount 示例212345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; var Hello=React.createClass(&#123; render:function()&#123; alert(&quot;ing&quot;); return &lt;div style=&#123;this.state&#125;&gt; this is a test&lt;/div&gt; &#125;, getInitialState:function()&#123; return&#123; opacity:0.5, color:&apos;blue&apos;, fontSize:&apos;44px&apos; &#125; &#125;, componentWillMount:function()&#123; alert(&quot;will&quot;) &#125;, componentDidMount:function()&#123; window.setTimeout(function()&#123; this.setState(&#123;opacity:1,color:&apos;red&apos;,fontSize:&apos;54px&apos;&#125;); &#125;.bind(this),1000) &#125; &#125;) React.render(&lt;Hello /&gt;, document.getElementById(&quot;root&quot;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果是以此出现：”will”, “ing”,一秒过后 出现”ing”并且样式改变。 以上例子是通过给一个初始state并且设置更改state的方法改变样式。这里还涉及了this的对外绑定，否则应在setTimeout()的函数内将this传递给一个的新的变量。这里需要知道props和state的区别，props是属于调用方，结构上为parent所有，state为当前组件所拥有，是可变的。 示例3（事件侦听）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/react@latest/dist/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@latest/dist/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- 因为通过this.refs.test拿到的并非是真实的DOM节点而是react component，对于真实DOM节点操作需要调用React.findDOMNode()方法--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; var Click=React.createClass(&#123; handlerClick:function(event)&#123; var real = React.findDOMNode(this.refs.test) if(real.style.display==&apos;none&apos;)&#123; real.style.display=&apos;inline&apos;; &#125; else&#123; real.style.display=&apos;none&apos;; &#125; //event事件 event.preventDefault(); event.stopPropagation(); &#125;, render:function()&#123; return &lt;div&gt; &lt;button onClick=&#123;this.handlerClick&#125;&gt;显示|隐藏&lt;/button&gt;&lt;span ref=&quot;test&quot;&gt;测试&lt;/span&gt;&lt;/div&gt; &#125; &#125;) var Input=React.createClass(&#123; getInitialState:function()&#123; return &#123; inputText:&apos;&apos; &#125; &#125;, handlerChange:function(event)&#123; this.setState(&#123;inputText:event.target.value&#125;); event.preventDefault(); event.stopPropagation(); &#125;, render:function()&#123; //设置初始state，并在元素中绑定state状态进行重新渲染 return &lt;div&gt;&lt;input type=&quot;text&quot; onChange=&#123;this.handlerChange&#125; /&gt;&lt;span&gt;&#123;this.state&#125;&lt;/span&gt;&lt;/div&gt; &#125; &#125;) React.render(&lt;div&gt;&lt;Click /&gt;&lt;Input /&gt;&lt;/div&gt;, document.getElementById(&quot;root&quot;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789React.createClass(&#123; componentWillMount: function () &#123;&#125;, componentDidMount: function () &#123;&#125;, componentWillReceiveProps: function () &#123;&#125;, shouldComponentUpdate: function () &#123;&#125;, componentWillUpdate: function () &#123;&#125;, componentDidUpdate: function () &#123;&#125;, componentWillUnmount: function () &#123;&#125;&#125;); 记住的Update阶段的几个方法: componentWillReceiveProps(newProps): 该方法在component接收到新属性，且还没有将新属性设置到this.props的时候调用，自带参数newProps指向变更的新属性，旧属性依然可以通过this.props访问，当在这个方法中调用this.setState的时候可以避免component的额外渲染。因为属性变化会引起状态变化，反过来却不存在，一般当component的state需要根据props进行变换的时候。在接收到newProps的时候先根据一定的关联关系处理得到state，再调用this.setState(state)。当要根据new props来对state执行更新操作时，使用componentWillReceiveProps方法 componentWillUpdate(newProps, newState): 该方法在component即将执行更新渲染时执行,在该方法中需要避免调用this.setState方法，否则会引起控件渲染死循环。因为这里手动更新了，又要触发shouldComponentUpdate , componentWillUpdate等等生命周期函数, 如此便会在componentWillUpdate这里陷入死循环 注意：render()函数渲染时必须是有一个最外层的包裹元素，React.render()方法中渲染组件也是如此。 render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F28%2FVue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[脚手架搭建1.windows上安装git、node 2.利用命令行安装Vue,这里注意可以借助淘宝的npm国内镜像，使用cnpm替代npm加速下载，安装速度。 3.具体命令行为： //全局安装 vue-cli$ cnpm install –、global vue-cli// 创建一个基于 webpack 模板的新项目$ vue init webpack my-project// 安装依赖，走你$ cd my-project$ cnpm install$ cnpm run dev 安装过程中可能出现问题包括:node或者npm版本不够，或者端口8080被占用等情况，可自行网搜解决。 todoList示例通过todoList的示例，了解基本Vue的api使用。这里只展示了父组件APP.Vue(项目的入口)和子组件Hello.Vue的代码结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//template为展示界面&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; //引入组件 Hello &lt;hello&gt;&lt;/hello&gt; &lt;!-- v-on用于绑定事件--&gt; &lt;button v-on:click=&quot;doSomething&quot;&gt;Click me!&lt;/button&gt; &lt;!-- v-bind用于绑定属性,常用于绑定class,以下展示的为&#123;类名：布尔值的形式&#125; 当:class=&quot;[classA,classB]&quot;时，为绑定两个类名，且此时，被绑定的类名需要在数据中给予声明。--&gt; &lt;--v-for用于循环输出数据--&gt; **这里注意：Vue1.0和2.0中对于V-for的索引使用方式是不同的，2.0中，若要出现索引，则v-for=&quot;(item,index) in items&quot;然后在接下来的使用中直接写index即可。** &lt;ul &gt; &lt;li v-for=&quot;item in items&quot; v-bind:class=&quot;&#123;finished: item.isFinish&#125;&quot; @click=&quot;changed(item)&quot;&gt;&#123;&#123;item.label&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 用 v-model 指令在表单控件元素上创建双向数据绑定,获取表单中的数据值 --&gt; &lt;!-- 事件的侦听有多种，以下为侦听输入enter所执行的操作 --&gt; &lt;input v-model=&quot;newItem&quot; v-on:keyup.enter=&quot;addNewItem&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入组件import Hello from &apos;./components/Hello&apos;import Store from &apos;./store&apos;//export default&#123;&#125;方法相当于 new Vue(&#123;&#125;)的方式。export default &#123;//组件对外显示的名称 name: &apos;app&apos;,//ES6中的表达方式，等效于 data:function()&#123;&#125; data()&#123; return&#123; msg: &apos;Welcome to Your Vue.js App&apos;, haha:&apos;&lt;spna&gt;really!&lt;/span&gt;haha tomorrow&apos;, a:1, show:false, isShow:true, items:Store.fetch(), newItem:[] &#125; &#125;,//组件必须注册，才能使用 components: &#123; Hello &#125;,//事件方法 methods:&#123; doSomething:function()&#123; this.a++; &#125;, changed:function(item)&#123; item.isFinish=! item.isFinish; &#125;, addNewItem:function()&#123; this.items.push(&#123;label:this.newItem,isFinish:false&#125;) this.newItem=&apos;&apos;; &#125; &#125;,//侦听事件变化，事件变化时驱动方法 watch:&#123; //简写模式 a :function(val,oldVal)&#123; console.log(val,oldVal); &#125;, items:&#123; handler: function()&#123; Store.save(this.items) &#125;, //深度侦听键值的变化 deep:true &#125; &#125;&#125;&lt;/script&gt;//所有的样式全部包括在&lt;style&gt;标签下&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.finished&#123; text-decoration:underline;&#125;&lt;/style&gt; 子组件示例子组件Hello 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;!-- 模板指令是html和vue之间的粘合剂 --&gt; &lt;!-- v-on用于时间绑定 v-on:click==@click --&gt; &lt;!-- 模板命令v-if v-show是通过布尔值用来控制模块的隐藏 --&gt; &lt;!-- 区别在于v-if是不渲染，而v-show是通过css属性的display:none;来隐藏属性 --&gt; &lt;!-- &lt;p v-if=&quot;isShow&quot;&gt;hello p element&lt;/p&gt; &lt;p v-show=&quot;show&quot;&gt; hi p element &lt;/p&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- vue.js中我们只是去关心抽象出来的数据，并不去关心这些数据实现的过程(这个过程交给vue来做) --&gt;&lt;script&gt;// export&#123;&#125;对象出来的东西会在 new Vue(&#123;&#125;)中自动生成一个属于自己的属性export default &#123;//对外暴露组件名，这里需要注意 name: &apos;hello&apos;, data () &#123; return &#123; msg:&apos;hello everyone&apos; &#125; &#125;,&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 123456789const STORAGE_KEY = &apos;todo-vuejs&apos;export default&#123; fetch()&#123; return JSON.parse(window.localStorage.getItem(STORAGE_KEY||&apos;[]&apos;)) &#125;, save(item)&#123; return window.localStorage.setItem(STORAGE_KEY,JSON.stringify(item)) &#125;&#125;]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(7)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(7)%2F</url>
    <content type="text"><![CDATA[享元模式享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 享元模式要求将对象的属性划分为内部状态与外部状态(这里的状态通常指属性)。其目标是尽量减少共享对象的数量。具体的内部对象是指独立于具体的场景，通常不会改变，外部对象是指取决于具体场景，并且根据外部场景的变化，外部状态不能被共享。 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里面获取。如果对象池是没有空闲对象，则新建一个新的对象，当获取出的对象完成了它的职责之后，再次进入池子等待被获取。1234567891011121314151617181920212223242526272829303132333435363738var toolFactory=(function()&#123; var toolPool=[]; return&#123; create:function()&#123; if(toolPool.length==0)&#123; var div=document.creat(&apos;div&apos;); document.body.appendChild)(div); return div; &#125;else&#123; return toolPool.shift(); &#125; &#125;, recover:function(toolDom)&#123; return toolPool.push(toolDom); &#125; &#125;&#125;))()var arr=[];//创建两个节点for(var i=0,str;str=[&apos;a&apos;,&apos;b&apos;][i++];)&#123; var toolTip=toolFactore.create(); toopTip.innerHTML=str; arr.push(toopTip);&#125;//回收进对象池for(var j=0,tooptip;tooptip=arr[i++];)&#123; toolFactory.recover(tooptip);&#125;//再次创建节点时可以直接从对象池里面获取for(var k=0,str;str=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;][i++];)&#123; var toopTip=toolFactory.create(); toopTip.innerHTML=str;&#125; 通用的对象池12345678910111213141516171819202122232425var toolFactory=function(fn)&#123; var toolPool=[]; return&#123; create:function()&#123; if(toolPool.length==0)&#123; return fn.apply(this.arguments); &#125;else&#123; return toolPool.shift(); &#125; &#125;, recover:function(obj)&#123; return toolPool.push(obj); &#125; &#125;&#125;var finalFactory=toolFactory(function()&#123; var div = document.create(&apos;div&apos;); document.body.appendChild(div); return div;&#125;)var tooltip=finalFactory.create();tooltip.innerHTML=&apos;a&apos;;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(4)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)%2F</url>
    <content type="text"><![CDATA[代理模式定义：为一个对象或提供一个代用品或占位符，以便控制对它的访问 代理模式分为保护代理和虚拟代理。保护代理是用于控制不同权限对象对目标对象的访问。虚拟代理会把一些开销很大的对象，延迟到真正需要它的再去创建。 代理的意义实现单一职责原则。即，就一个类（通常也包括对象和函数），应该仅有一个引起它变化的原因。 如果一个对象承担了多项职责，意味着将这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。 示例加载一张图片：1234567891011var myImage=(funciton()&#123; var imgNode=document.creatElement(&apos;img&apos;); document.body.appendChild(imgNode); return&#123; setSrc:function(src)&#123; imgNode.src=src &#125; &#125;&#125;)()myImage.setSrc(&quot;..........&quot;) 增加代理之后，将预加载与图片加载分离：12345678910111213var proxyImage=(function()&#123; var img=new Image; img.onload=function()&#123; myImage.setSrc(this.src); &#125; return&#123; setSrc:function(src)&#123; myImage.setSrc(&apos;本地的loading图片&apos;); img.src=src; &#125; &#125;&#125;)()proxyImage.setSrc(&apos;真正图片&apos;)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(6)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(6)%2F</url>
    <content type="text"><![CDATA[# 模板方法模式 模板方法模式是一种只需要使用继承就可以实现的简单模式 通常该方法由两个部分组成：第一部分是抽象父类，第二部分是具体的实现子类。通常在父类中封装了子类的算法框架，包括一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也就继承了整个算法结构。 在模板方法中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。 示例：冲泡茶和冲泡咖啡的过程大致可以总结为以下几个步骤： 1.把水煮沸 2.用沸水冲泡 3.将冲泡好的导入杯子中 4.加其他调料 于是可以这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var Beverage = function()&#123;&#125;;Beverage.prototype.boilWater=function&#123; console.log(&apos;冲水&apos;);&#125;Beverage.prototype.brew=funciton()&#123;&#125;;Beverage.prototype.pourInCup=function()&#123;&#125;;Beverage.prototype.addCondiments=funciton()&#123;&#125;;Beverage.prototype.init=function()&#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); &#125;//***********************************************************************对于咖啡和茶，用不同的子类继承该父类var Coffee=funciton()&#123;&#125;;Coffee.prototype=new Beverage();接下来可以调用Beverage的原型方法，并加入自己的不同之处Coffee.prototype.brew=function()&#123; console.log(&apos;用水冲咖啡&apos;);&#125;Coffee.prototype.pourInCup=function()&#123; console.log(&apos;把咖啡倒进杯子&apos;);&#125;Coffee.prototype.addCondiments=function()&#123; console.log(&apos;加糖&apos;);&#125;var coffee = new Coffee();coffee.init();//******************************************************************var Tea=function()&#123;&#125;;Tea.prototype=new Beverage();Tea.prototype.brew=function()&#123; console.log(&apos;用水冲茶&apos;)&#125;Tea.prototype=function()&#123; console.log(&apos;把茶倒入杯子中&apos;);&#125;Tea.prototype=function()&#123; console.log(&apos;加入柠檬&apos;);&#125;var tea=new Tea();tea.init(); 这里，真正的模板方法是Beverage.prototype.init()。因为该方法中封装了子类的算法框架，它作为一个算法框架，知道子类以何种顺序去执行那些算法。在Beverage.prototype.init()方法中，算法的每一个步骤都清晰的呈现在眼前。 js中在父类中有些抽象方法只是被声明，但是并没有具体的实现方法，如果在子类中忘记重写，显然不是我们所需要的。解决方法可以有：1234567Beverage.prototype.brew=funciton()&#123; throw new Error(&apos;子类必须重写brew方法&apos;)&#125;;Beverage.prototype.pourInCup=function()&#123; throw new Error(&apos;子类必须重写pourInCup方法&apos;)&#125; 让Beverage.prototype.brew()等方法抛出一个异常。 应用场景Web开发中在构建UI组件的过程可以用到模板模式： 1.初始化一个div容器 2.通过ajax请求拉取相应的数据 3.把数据渲染到div容器里，完成组件的构造 4.通知用户组件渲完毕 钩子方法模板封装子类的算法框架适合用于大多数子类，但是如果有些特别‘个性’子类，就需要让子类可以跳出模板的约束。这时，可以用钩子方法来隔离变化，究竟需不需要钩子则由子类决定。12345678910111213141516171819202122232425262728293031Beverage.prototype.customWantCondiments=function()&#123; return true;&#125;Beverage.prototype.addCondiments=funciton()&#123;&#125;;Beverage.prototype.init=function()&#123; this.boilWater(); this.brew(); this.pourInCup(); if(this.customWantCondiments())&#123; this.addCondiments(); &#125; &#125;var Coffee=funciton()&#123;&#125;;Coffee.prototype=new Beverage();Coffee.prototype.addCondiments=function()&#123; console.log(&apos;加糖&apos;);&#125;Coffee.prorotype.customWantConiments=function()&#123; window.confirm(&apos;要加调料吗？&apos;)&#125;var coffee = new Coffee();coffee.init(); ‘好莱坞原则’允许低层组件将自己挂钩到高层组件中，而高层组件会决定在什么时候，以何种方式去使用这些低层组件。而模板方法模式就是该原则的一个重要体现，当我们用模板方法模式来进行编码时，就意味着我们放弃了对自己的控制权，而改为父类通知子类哪些方法应该在什么时候被调用。而作为子类，只是负责提供一些设计上的细节。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(5)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(5)%2F</url>
    <content type="text"><![CDATA[观察者模式(发布-订阅模式)它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。 js中一般使用注册回调函数的形式来代替传统的观察者模式，并且arguments可以很方便地表示参数列表，因而一般用推模型使用Function.prototype.apply方法将所有参数都推送给订阅者。 观察者模式优点：时间上解耦，对象之间的解耦。 命令模式应用场景：有时候需要向某些对象发送请求，但是不知道请求的接受者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接受者消除彼此之间的耦合关系。 js中的利用闭包实现命令模式：123456789101112131415161718192021var setCommand=function(button,command)&#123; button.onclick=function()&#123; command.execute; &#125;&#125;var MenuBar=&#123; refresh:function()&#123; console.log(&apos;刷新菜单界面&apos;) &#125;&#125;var RefreshMenuBarCommand=function(receiver)&#123; return &#123; execute:function()&#123; receiver.refresh; &#125; &#125;&#125;var RefreshMenuBarCommand=RefreshMenuBarCommand(MenuBar);setCommand(button1,RefreshMenuBarCommand); 宏命令通过宏命令，一次可以执行一批命令12345678910111213141516171819202122232425262728293031323334var closeDoorCommand=&#123; execute:function()&#123; console.log(&apos;1&apos;); &#125;&#125;var openDoorCommand=&#123; execute:function()&#123; console.log(&apos;2&apos;); &#125;&#125;var openWindow=&#123; execute:function()&#123; console.log(&apos;3&apos;); &#125;&#125;var MacroCommand=funciton()&#123; return&#123; commandList:[], add:funciton(command)&#123; this.commandList.push(command) &#125;, execute:function()&#123; for(var i=-0,command;command=this.commandList[i++];)&#123; command.execute; &#125; &#125; &#125; &#125;var macroCommand=MacroCommand();macroCommand.add(closeDoorCommand);macroCommand.add(openDoorCommand);macorCommand.add(openWindow);macroCommand.execute; 组合模式组合模式就是用小的对象来构建更大的对象，而这些小的子对象本身也许来自更小的对象。上一节中的宏命令即为一个组合模式的例子。 注意1.组合模式不是父子关系，组合模式把对象的请求委托给它包含的所有叶对象。 2.组合模式除了要求组合对象和叶对象拥有相同的接口，还要求对一组叶对象的操作必须具有一致性。 3.可以用职责连模式来提高组合模式的性能]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(3)]]></title>
    <url>%2F2017%2F06%2F26%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)%2F</url>
    <content type="text"><![CDATA[单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局节点。 js中的单例模式是为了避免全局变量的使用，降低全局变量带来的污染。具体方法有： 1.使用命名空间 2.使用闭包封装私有变量 惰性单例定义：仅仅在需要时候才创建对象实例。 通用的惰性单例模式：123456var getSingle = function(fn)&#123; var result; return function()&#123; return result||(fn.apply(this,arguments)); &#125;&#125; 策略模式定义：定义一系列算法，把它们一个个封装起来。将算法的使用和算法的实现分离开来12345678910var stratgies=&#123; &quot;s&quot;:function(salary)&#123;return salary*4&#125;, &quot;A&quot;:function(salary)&#123;return salary*5&#125;, &quot;B&quot;:function(salary)&#123;return salary*6&#125;&#125;;var calculate=function(level,salary)&#123; return stratgies[level](salary);&#125;calculate(&quot;A&quot;,4000);20000 示例利用策略模式将表单提交重构12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;post&quot;&gt; 用户名:&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt; 密码:&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt; 手机号:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var registerForm = document.getElementById(&apos;registerForm&apos;); registerForm.onsubmit=function()&#123; if(registerForm.userName.value===&quot;&quot;)&#123; alert(&apos;用户名不能为空&apos;) return false; &#125; if(registerForm.password.value==&quot;&quot;)&#123; alert(&apos;密码不能为空&apos;); return false; &#125; if(!/^1[3|5|8][0-9]&#123;9&#125;$/.test(registerForm.phoneNumber.value))&#123; alert(&apos;手机号码不对&apos;); return false; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 重构后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form id=&quot;registerForm&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 手机号:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; //***********************************策略对象*************************************************** var strategies=&#123; isEmpty:function(value,errorMsg)&#123; if(value==&quot;&quot;)&#123; return errorMsg; &#125; &#125;, isMobile:function(value,errorMsg)&#123; if(!/1[3|5|8][0-9]&#123;9&#125;/.test(value))&#123; return errorMsg; &#125; &#125; &#125; //**********************************Validator类，作为context,负责接收用户的请求并委托给strategy对象************** var validator=function()&#123; this.cache=[]; &#125; validator.prototype.add=function(dom,rule,errorMsg)&#123; var self=this; var arr=[]; this.cache.push(function()&#123; arr.unshift(dom.value); arr.push(errorMsg); return strategies[rule].apply(dom,arr); &#125;) &#125;; validator.prototype.start=function()&#123; for(var i=0,validatorFunc;validatorFunc=this.cache[i++];)&#123; var msg=validatorFunc(); if(msg)&#123; return msg; &#125; &#125; &#125; //**************************客户调用代码******************************************** var registerForm = document.getElementById(&apos;registerForm&apos;); var validataFunc=function() &#123; var validator=new validator(); validator.add(registerForm.userName,&apos;isEmpty&apos;,&apos;用户名不能为空&apos;); validator.add(registerForm.phoneNumber,&apos;isMobile&apos;,&apos;手机号码格式不正确&apos;); var errorMsg=validator.start(); return errorMsg; &#125; registerForm.onsubmit=function()&#123; var errorMsg=validataFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http基础知识]]></title>
    <url>%2F2017%2F06%2F26%2Fhttp%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Http基础知识介绍定义：基于文本的、用来在因特网中传输数据的协议。基于tcp/ip协议。Web的开发者们至少应该关注HTTP请求的两个方面：1.请求的目的是获取资源 2.HTTP是一个无状态的协议。 1.资源 访问资源首先需要使用URL。它指明了要使用的协议、服务器地址、要在服务器访问的特定文件。 HTTP中资源具体而言就是：作为对象请求的响应，服务器总是会往客户端(用户代理)返回一些东西。这些东西可能是直接响应，也可能是间接响应。直接响应会把请求的资源返回，例如一张图片、一个HTML文档。间接响应会返回请求在指定资源上执行的结果，例如是一个告知操作成功失败的界面，或者一个状态码。 2.无状态 HTTP是一种无状态协议，因为每个请求/响应周期都是独立的，服务器无法通过HTTP协议来判断多个请求是否来自同一个用户代理。因此，许多web服务器引入了‘会话’(Session)的概念。‘会话概念’的引入使得服务器可以得以在多个请求之间存放状态。通常，不通的会话是通过客户端和服务器之间反复传递一二独一无二的秘钥(通常称为会话ID)，通常使用cookies来维护会话ID。 会话的实现机制：cookie与session是各种教材，网上文章所介绍到的与HTTP会话相关的两个内容。这两者较常见的解释是：cookie存在在浏览器，session存储在服务器中。但实际上这是一种不严谨的说法。实际上会话的实现机制是：首先，用户端向服务端发送一个请求，服务端接收到请求（这里忽悠无须会话控制的情况）后，初始化会话，生成相应的会话信息，核心是会话ID，把会话ID发送给客户端，客户端接收到这个会话ID，把它存储起来，下一次发送请求的时候，附带着这个会话ID一起发送给服务端，服务端只要根据这个会话ID，就知道是谁**了。 对于如何存储会话ID，服务端与客户端是不同的，服务端存储会话ID有多种方式，常见的有本地存储，如：普通文本，文本名就是会话ID。对于文件系统，同一目录下，同一文件名只允许唯一一个文件，那么使用会话ID作为文件名是可以做到唯一确定会话的。除了本地文件存储，还可以使用memcache、redis、或者Mysql之类的数据库存储，即使用第三方数据库进行存储。只有一个原则：存储的会话ID必须是唯一的。客户端对于会话信息的存储就是使用“域”，不同的域拥有独立的会话。客户端以域相关信息作为文件标识符创建会话文件（客户端存储）对会话信息进行存储，其中域与会话ID结合就能唯一确定服务端，并且确定会话。浏览器是最常见的HTTP客户端，浏览器存储会话信息，是使用cookie文件的，里面保存着cookie信息，而服务端返回的会话ID也存储在里面。会话ID存储在cookie文件中是一般情况下的，而cookie信息是作为HTTP头发送给服务端的，也就是说这种情况下，会话ID是附带在请求头中。粗糙地，可理解为服务端返回给客户端的会话ID是存储在COOKIE文件中的 cookie&amp;&amp;sessionCookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，从而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。 客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在客户端内存中，称为临时Cookie，浏览器关闭后这个Cookie对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。 请求类型原理实际上，客户端可以往服务器发送的请求有8种。不同的请求类型根据其在请求中指定的发送方法来辨别。HTTP请求方法有包括：GET,HEAD,POST,PUT,DELETE,TRACE,OPTIONS,CONNECT。常用的有get,post,head方法。一般来说，get一般用于获取/查询资源信息，而post一般用于更新资源信息。 1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 (1)这里所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 * 注意：这里安全的含义仅仅是指是非修改信息。 (2)幂等的意味着对同一URL的多个请求应该返回同样的结果 2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求 方法的区别原理性的问题，我们再从表面现像上面看看GET和POST的区别： 1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连。POST把提交的数据则放置在是HTTP包的包体中。 2.POST的安全性要比GET的安全性高，在地址栏看不到。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存 3.GET方式提交的数据是有限制的（因为其参数通过URL传递，而浏览器对于URL的长度限制为1024个字节），这里的限制是特定的浏览器和服务器对它的限制。理论上POST没有限制，可传较大量的数据。 HTTP消息格式一个HTTP周期由请求和响应构成，因此HTTP消息格式分为请求消息格式和响应消息格式，通常情况下，浏览器或者Ajax的XMLHttpRequest对象会为我们格式化这些消息。 请求消息格式： 1.起始行。定义使用的方法，资源和协议。字段之间用一个空格隔开。 2.首部行(可以没有也可以多个)。每行规定一个首部，包含首部名、冒号、至少一个空白字符，以及首部值。 3.一个可选的请求消息正文。它的解释方法取决于它的使用方法。 示例： 123456789101112131415161718192021222324********请求头*******POST /some/path/folder/haha.html HTTP/1.1&lt;CRLF&gt;Host: www.haha.com: 80&lt;CRLF&gt;//必须是域名，不能是IP地址Connection: keep-alive//告诉服务器客户端可以接受什么类型文件Accept: text/html,application/xhtml+xml//指定了客户端提交给服务器的数据类型，这里multipart/form-data(二进制数据)是其中一种Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryqrt*******（随机的边界分割符）User-Agent: somebody&apos;s browser &lt;CRLF&gt;//浏览器类型********请求主体********************-------WebKitFormBoundaryqrt*******Content-Disposition: 提交数据-------WebKitFormBoundaryqrt*******如果是文件上传的话 响应消息格式:1.起始行。定义使用的协议、响应状态码和一个原因字符串(状态码解释)。 2.首部行(可以没有也可以多个)。每行规定一个首部，包含首部名、冒号、至少一个空白字符，以及首部值。 3.返回的数据。它的解释取决于所使用的方法。 示例： 1234567891011HTTP/1.1 200 OK&lt;CRLF&gt;Content-type: text/html&lt;CRLF&gt;Content-length: 55&lt;CRLF&gt;&lt;html&gt; &lt;body&gt; haha here! &lt;/body&gt;&lt;/html&gt; HTTP中的状态码有很多，常见的有200-OK,403-Forbidden(禁止访问),404-Not Found(文件找不到),500-Internal Server Error 使用Ajax生成请求示例 12345678new Ajax.Request(&apos;/the/server/side/resource&apos;,&#123; method:&apos;post&apos;, requestHeaders: [ &apos;x-headerName1&apos;,&apos;headValue1&apos;, &apos;x-headerName2&apos;,&apos;headValue2&apos; ], poseBody: Form.serialize(document.someForm)&#125;) 这段代码中第一个参数定义了资源地址，另外一个参数对象则定义了方法、请求首部和要发送的POST正文。 通过Ajax获取响应利用Ajax的XMLHttpRequest对象获取响应，并允许使用该对象的一些方法和属性对响应进行处理。 方法属性列表： responseText:成功请求后的响应文本。 responseXML:此属性包含一个XML DOM，仅仅当响应首部中规定的内容类型为text/html时有效。 status: 响应状态码 statusText: 状态原因消息 getAllHeaders():返回所有响应的首部 getHeader(name):返回指定响应首部 HTTP协议1.0与HTTP协议1.1的主要区别在于引入connection:keep-alive,使得连接中断后仍然能够保证一段时间的连接。其他的区别还包括：支持持久连接，虚拟主机，代理连接]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式基础(2)]]></title>
    <url>%2F2017%2F06%2F26%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)%2F</url>
    <content type="text"><![CDATA[闭包闭包在js中的作用：1.封装变量 2.延续局部变量的寿命。 通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。 闭包的作用： （1）匿名自执行函数：实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包 123456789101112131415var data= &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(data); (2)结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可 (3)封装变量 (4)实现类和继承 12345678910111213141516171819202122232425262728function Person()&#123; var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person(); p.setName(&quot;Tom&quot;); alert(p.getName()); var Jack = function()&#123;&#125;; //继承自Person Jack.prototype = new Person(); //添加私有方法 Jack.prototype.Say = function()&#123; alert(&quot;Hello,my name is Jack&quot;); &#125;; var j = new Jack(); j.setName(&quot;Jack&quot;); j.Say(); alert(j.getName()); 利用闭包解决onclick时间被异步触发123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++) &#123; node[i].onclick=function()&#123; console.log(i); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 无论点击那个div,都会出现5，因为for循环早已结束，而onclick为异步调用。 解决方法 将每次循环的i值封闭起来。当在事件函数中顺着作用域链从内而外查找变量i时，会先找到被封闭在闭包环境中的i12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++) &#123; (function(i)&#123; node[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i) &#125;&lt;/script&gt;&lt;/html&gt;结果：2 3 闭包优缺点： 优点：将变量封闭在闭包中，是因为后续可能依然还会用到。 缺点：会带来内存泄漏的问题。 高阶函数充分条件： 1.函数可以作为一个参数被传递 函数作为参数传递案例包括：1.回调函数；2.Array.prototype.sort()方法 2.函数可以作为返回值输出。 1.判断数据类型 1234567891011121314151617181920Object.prototype.toString.call([1]);&quot;[object Array]&quot;Object.prototype.toString.call(&#123;a:1&#125;);&quot;[object Object]&quot;Object.prototype.toString.call(&apos;haha&apos;);&quot;[object String]&quot;Object.prototype.toString.call(1);&quot;[object Number]&quot;Object.prototype.toString.call(true);&quot;[object Boolean]&quot;Object.prototype.toString.call(undefined);&quot;[object Undefined]&quot;Object.prototype.toString.call(null);&quot;[object Null]&quot; 3.实现AOP编程 js中的AOP实现一般是将一个函数‘动态织入’另外一个函数。 123456789101112131415161718192021222324252627282930313233343536Function.prototype.before = function(beforefn)&#123; var self=this; //保存原函数的引用 return function()&#123; beforefn.apply(this,arguments); //修正this，执行新函数 return self.apply(this,arguments);//修正this，执行原函数 &#125;&#125;var func=function()&#123;console.log(2)&#125;;func = func.before(function()&#123;console.log(3)&#125;);func()结果：3 2Function.prototype.before = function(beforefn)&#123; var self=this; return function()&#123; beforefn.apply(null,arguments); return self.apply(null,arguments); &#125;&#125;;Function.prototype.after = function(afterfn)&#123; var self = this; return function()&#123; self.apply(this,arguments); return afterfn.apply(this,arguments); &#125;&#125;var func=function()&#123;console.log(2)&#125;;func = func.before(function()&#123;console.log(3)&#125;).after(function()&#123;console.log(1)&#125;);func() 3 2 1]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式基础(1)]]></title>
    <url>%2F2017%2F06%2F25%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 封装 1.封装数据：Js中并没有提供private,public,protected等关键字来提供访问权限，只能后依赖变量的作用域特性，而且只能模拟出public和private两种数据封装特性。除了ES6中的let属性，一般可以通过函数来创建作用域。 2.封装实现：封装使得对象内部的变化对外是透明的，其他对象不关心对象内部的实现。封装使得对象之间的耦合变松散，对象之间只通过api接口通信。 3.封装的作用：把系统中稳定不变的部分和容易变化的部分分离开，在系统演变过程中，只需替换那些容易变化的部分。 二. 原型模式和基于原型继承的js对象系统 js中不存在类的概念，对象也并非从类中创建出来，所有的js对象都是从某个对象上克隆出来的。如果对象A是由对象B克隆出来的，则成B为A的原型。 原型编程的规则:1.所有数据都是对象 事实上，js中的根对象是Object.prototype对象，所有的对象都是从他克隆出来的。Object.prototype的原型是null。 123var obj=&#123;&#125;;console.log(Object.getPrototypeOf(obj)===Object.prototype);VM217:2 true 2.要得到一个对象，不是通过实例化类，而是找到一个对象作为他的原型 js中的函数既可以作为普通函数被调用，可以作为构造器函数被调用，当用new运算符来调用函数时，此时函数是一个构造器。用运算符来创建对象的过程中，实际上也是先克隆Object.prototype对象，再进行一些额外的其他操作。 3.对象会记住它的原型 对象会记住它的构造器原型 12345678910var a= new Object();console.log(a.__proto__===Object.prototype);VM353:2 truefunction haha()&#123;return &apos;hahha&apos;&#125;;var a = new haha();console.log(a.__proto__===haha.prototype);VM507:5 true 4.如果对象无法响应某个请求，它会把这个请求委托给它自己的原型 这规则是原型继承的精髓所在，当一个对象无法响应某个请求的时候，会把这个请求顺的原型链传递下去。 虽然js中的对象最初都是由Object.prototype对象克隆出来的，但是对象构造器的原型并不局限于Object.prototype，也可以有选择性的把对象a的构造器原型指向对象b,从而达到继承的效果。12345678910111213var a=function()&#123;&#125;var A=new a();var obj=&#123;name:&apos;haha&apos;&#125;;a.prototype=obj;console.log(A.name);VM658:5 var a=function()&#123;&#125;var obj=&#123;name:&apos;haha&apos;&#125;;a.prototype=obj;var A=new a();console.log(A.name);VM659:6 haha 三. this、call、apply的作用 thisjs中的this总是指向一个对象，具体指向哪个对象，是在运行时基于函数的执行环境而动态绑定的，而非函数声明时的环境 this的指向1.作为对象的方法调用 当函数作为对象的方法被调用时，this指向该对象。123var obj =&#123;a:1,getA:function()&#123;console.log(this==obj)&#125;&#125;;obj.getA();VM200:1 true 2.作为普通函数调用123456789var obj =&#123;a:1,getA:function()&#123;console.log(this==obj)&#125;&#125;;var getB=obj.getA;getB();VM229:1 falsevar obj =&#123;a:1,getA:function()&#123;console.log(this)&#125;&#125;;var getB=obj.getA;getB();VM236:1 Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; 当函数不作为对象的属性被调用时，也就是常说的普通函数方式，此时的this总是指向全局对象 3.构造器调用12345var a =function()&#123;this.name = &apos;haha&apos;&#125;;var b = new a;console.log(b.name);VM209:4 haha 当用new调用函数时，该函数会返回一个对象，通常情况下，构造器里面的this指向返回的这个对象 但是，如果构造器显示的返回一个object类型的对象，则此次运算结果返回这个显示对象12345678var a =function()&#123; this.name = &apos;haha&apos;; return &#123;name:&apos;hehe&apos;&#125;&#125;var b = new a();console.log(b.name);VM308:6 hehe 4.Funcition..prototype.call和Function.prototype.apply调用。 与普通函数相比，call()和apply()方法可以动态的改变传入函数的this。1234var obj1=&#123;name:&apos;haha&apos;,getName:function()&#123;return this.name&#125;&#125;;var obj2=&#123;name:&apos;heihei&apos;&#125;;console.log(obj1.getName.apply(obj2));VM500:3 heihei apply &amp;&amp; callapply()与call()方法唯一不同处在于传入参数的形式不同。 apply()接受两个参数，第一个参数是传递给这个函数用来绑定函数内部this的值，第二个参数可以数组或者类数组（传递给这个函数的所有参数），apply()方法把这个数组中的元素作为参数传递给被调用的函数。 call()方法接受的参数数量不固定，与apply()相同的是，第一个参数也是参数代表函数体内的this的指向，之后的每一个参数依次被传入函数。123456789101112131415var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.apply(null, [1,2,3]);6var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, [1,2,3]);1,2,3undefined undefinedvar fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, 1,2,3);6var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, 1,2,4,9);7 如果函数第一个参数指向null,则默认函数体内的this指向默认的宿主对象，在浏览器中是window:123var fun = function(a,b,c)&#123;console.log(this)&#125;;fun.call(null, 1,2,4,9);Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; apply()与call()用途1.改变this的指向1234var getName=function()&#123;return this.name;&#125;var obj1=&#123;name:&apos;hahh&apos;&#125;;getName.call(obj1);&quot;hahh&quot; 将函数getName的this指向对象obj1; 2.使用其他对象的方法 1.借用构造函数： 123456var A=function(name)&#123;this.name=name&#125;;var B=function()&#123;A.apply(this,arguments);&#125;B.prototype.getName=function()&#123;return this.name;&#125;;var b=new B(&apos;heihei&apos;);console.log(b.getName());heihei 2.对于函数的参数列表arguments(一个类数组对象)，并非一个真正的数组。可以通过apply()或者call()方法来增加所需用到的方法。1234567891011121314151617(function()&#123;Array.prototype.push.apply(arguments,[3]);console.log(arguments);&#125;)(1,2);[1, 2, 3, callee: function, Symbol(Symbol.iterator): function](function()&#123;Array.prototype.push.call(arguments,3);console.log(arguments);&#125;)(1,2);[1, 2, 3, callee: function, Symbol(Symbol.iterator): function]var a=&#123;&#125;;Array.prototype.push.call(a,&apos;haha&apos;);console.log(a);Object &#123;0: &quot;haha&quot;, length: 1&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的设计模式]]></title>
    <url>%2F2017%2F06%2F17%2Fjs%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[函数声明&amp;&amp;函数表达式函数声明Function Declaration 可以定义命名的函数变量，而无需给变量赋值。Function Declaration 是一种独立的结构，不能嵌套在非功能模块中。可以将它类比为 Variable Declaration（变量声明）。就像 Variable Declaration 必须以var开头一样，Function Declaration 必须以function开头。 eg123function test()&#123; return 3&#125; 函数声明时，函数名在自身作用域和父作用域内是可获取的（否则就取不到函数了）。 函数表达式Function Expression 将函数定义为表达式语句（通常是变量赋值）的一部分。通过 Function Expression 定义的函数可以是命名的，也可以是匿名的。Function Expression 不能以function开头 eg1234567891011var a = function()&#123; return 3;&#125;var a = function test()&#123; return 3&#125;(function test()&#123; return 3;&#125;)(); 两者的区别JavaScript 解释器中存在一种变量声明被提升hoisting的机制，也就是说变量（函数）的声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。 eg:Q1123456789101112function bling()&#123; function test()&#123; return 3 &#125;; return test(); function test()&#123; return 8; &#125; &#125;console.log(bling());结果为:8 由于函数声明的变量提升，该程序经过解释器解释后为 1234567891011 function bling()&#123; function test()&#123; return 3 &#125;; function test()&#123; return 8; &#125; return test(); &#125; eg:Q21234567891011function foo()&#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125;console.log(foo());结果为:3 该程序经过解释器解释后为：1234567function foo()&#123;//变量声明提升var bar = undefined;var bar = undefined;bar = function()&#123;return 3&#125;;return bar();&#125; eg:Q3123456789101112console.log(foo());function foo()&#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125;结果为:3这次是函数foo()的声明提升了 eg:Q4123456789101112function foo()&#123; return bar(); var bar = function() &#123; return 3; &#125;; var bar = function() &#123; return 8; &#125;;&#125;console.log(foo());结果为：Uncaught TypeError: bar is not a function因为这里没有函数提升]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(5)]]></title>
    <url>%2F2017%2F06%2F17%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5%20end)%2F</url>
    <content type="text"><![CDATA[高级算法1 动态规划动态规划的解决方案与递归相反，它是通过从底部开始解决一个个小问题，然后合并成一个大的解决方案,从而解决一个大的问题 示例 1fiboancci 对比 递归方法12345678910function recurFib(n)&#123; if(n&lt;2)&#123; return n; &#125; else &#123; return recurFib(n-1)+ recurFib(n-2); &#125;&#125;recurFib(10);55 动态规划方法12345678910111213141516171819function recurFib(n)&#123; var value=[]; for(var i=0;i&lt;=n;i++)&#123; value[i]=0; &#125; if(n==1||n==2)&#123; return 1; &#125; else &#123; value[1]=1; value[2]=1; for(var j=3;j&lt;=n;j++)&#123; value[j]=value[j-1]+value[j-2]; &#125; return value[n] &#125;&#125;recurFib(10);55 示例 2寻找公共子字符串的动态规划实现12345678910111213141516171819202122232425262728293031323334353637383940function lcs(word1,word2)&#123; var max = 0; var index = 0; var lcsarr = new Array(word1.length+1); for(var i=0;i&lt;word1.length+1;i++)&#123; lcsarr[i]=new Array(word2.length+1); for(var j=0;j&lt;word2.length+1;j++)&#123; lcsarr[i][j]=0; &#125; &#125; for(var i=0; i&lt;=word1.length;i++)&#123; for(var j=0; j&lt;=word2.length;j++)&#123; if(i==0||j==0)&#123; lcsarr[i][j]=0; &#125;else&#123; if(word1[i-1]==word2[j-1])&#123; lcsarr[i][j]=lcsarr[i-1][j-1]+1; &#125;else&#123; lcsarr[i][j]=0; &#125; &#125; if(max&lt;lcsarr[i][j])&#123; max = lcsarr[i][j]; index = i; &#125; &#125; &#125; var str = &apos;&apos;; if(max==0)&#123; return &quot;&quot;; &#125;else&#123; for(var i=index-max;i&lt;=max;i++)&#123; str =str + word2[i] &#125; return str; &#125;&#125;lcs(&apos;abbcc&apos;,&apos;dbbcc&apos;);结果:&quot;bbcc&quot; 示例3背包的问题利用贪婪算法解决，贪婪算法核心思想为解决找到局部次优解。 解决部分背包问题的方案： 1.设背报容量为W，物品价格为v,物品重量为w。 2.根据v/w的比例对物品排序。 3.按比例降序方法来建立对应数组。 4.尽可能的放过多的物品。12345678910111213141516171819function ksack(values,weights,capacity)&#123; var load=0; var i=0; var w=0; while(load&lt;capacity&amp;&amp;i&lt;values.length)&#123; if(weights[i]&lt;=(capacity-load))&#123; w = w + values[i]; load = load + weights[i]; &#125;else&#123; var r=(capacity-load)/weights[i]; w = w + r * values[i]; load = load +weights[i]; &#125; i++; &#125;return w;&#125;ksack([13,10,11,4,5],[9,7,8,3,4],16);23 背包问题的递归方法123456789101112131415function ksack(capacity,size,value,n)&#123; if(n==0||capacity==0)&#123; return 0; &#125; if(size[n-1]&gt;capacity)&#123; return ksack(capacity,size,value,n-1); &#125;else&#123; return max(value[n-1]+ksack(capacity-size[n-1],size,value,n-1),ksack(capacity,size,value,n-1)) &#125;&#125;function max(a,c)&#123; return (a&gt;c)?a:c;&#125;ksack(16,[3,4,7,8,9],[4,5,10,11,13],5)23]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2017%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[平衡二叉树平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。其公式为F(n)=F(n-1)+F(n-2)+11是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。平衡二叉树的常用实现的算法有红黑树、AVL、替罪羊树、Treap、伸展树等。 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高 红黑树的基本操作(一) 左旋和右旋红黑树的基本操作（二）插入和删除见文章：！[]http://www.cnblogs.com/PerkinsZhu/p/5824015.html 快速排序但数据量一旦超过几万，插入和冒泡的性能会非常差。这时时间复杂度的渐进优势就表现出来了。 平均情况下快速排序的时间复杂度是Θ(nlgn)，最坏情况是n2，但通过随机算法可以避免最坏情况。由于递归调用，快排的空间复杂度是Θ(lgn) **快速排序算法其实很简单，采用分治策略。步骤如下： (1)选取一个基准元素（pivot） (2)比pivot小的放到pivot左边，比pivot大的放到pivot右边 (3)对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2**]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(3)]]></title>
    <url>%2F2017%2F06%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(3)%2F</url>
    <content type="text"><![CDATA[二叉树与二叉查找树树是一种非线性的数据结构，以分层的方式存储数据。二叉树由节点构成，在这里需要定义一个Node对象123456789function Node(data,left,right)&#123; this.data = data; this.left = left; this.right = right; this.show = show;&#125;function show()&#123; return this.data;&#125; 在这里可以创建一个类来表示二叉查找树(BST),该类的构造函数将根节点初始化为null,以此创建一个空节点。此外，还有一个insert()方法，用来向树中增加新节点。1234function BST()&#123; this.root = null; this.insert = insert;&#125; 具体的insert()方法实现思想： (1)判断有无根节点，如果没有根节点，将插入点直接设为根节点，结束。 (2)如何已有根节点，将根节点设为当前节点，比较待插数据与根节点的大小，如果小于当前节点，设新的当前节点为原节点的做节点，否则设为右节点。 (3)知道当前节点的做节点或右节点为空时，插入数据，完成算法。具体实现：12345678910111213141516171819202122232425262728function insert(data)&#123; var n = new Node(data,null,null); if(this.root==null)&#123; this.root = n; &#125; else&#123; var current = this.root; var parent; while(true)&#123; parent = current; if(current.data&gt;data)&#123; current = current.left; if(current==null)&#123; parent.left = n; break; &#125; &#125; else&#123; current = current.right; if(current==null)&#123; parent.right = n; break; &#125; &#125; &#125; &#125;&#125; 常用的遍历二叉查找树的方法有三种：中序、先序，后序。中序：即为升序排列。左，中，右先序：从最左边开始：中，左，右。后序：从最左边开始：左，右，中。]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(4)]]></title>
    <url>%2F2017%2F06%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(4)%2F</url>
    <content type="text"><![CDATA[排序算法简单排序算法1 冒泡排序1234567891011121314151617function bubble(arr)&#123; var length = arr.length; var temp; for(var i =0; i&lt;length;i++)&#123; for(var j=length-1;j&gt;i;j--)&#123; if(arr[i]&lt;=arr[j])&#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var a = [3,2,4,1];bubble(a);结果为:[4, 3, 2, 1] 2 选择排序1234567891011121314151617function select(arr)&#123; var length = arr.length; var temp; var min for(var i =0; i&lt;length-2;++i)&#123; min = i; for(var j=i+1;j&lt;length-1;++j)&#123; if(arr[j]&lt;=arr[min])&#123; min = j; &#125; temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr;&#125; 高级排序算法1 希尔排序希尔排序在插入排序的基础上做了一些改变，它会首先比较距离较远的元素而非距离较近的元素。然后不断缩小元素之间的比较距离直到处理到数据集末尾，这时候算法开始比较相邻元素。1234567891011121314151617181920212223function shellSort(arr)&#123;var length = arr.length;var h=1;while(h&lt;length/3)&#123; h = 3*h +1;&#125;while(h&gt;=1)&#123; for(var i=h; i&lt;length;i++)&#123; for(var j=i;j&gt;=h&amp;&amp;arr[j]&lt;arr[j-h];j=j-h)&#123; if(arr[j]&lt;arr[j-h])&#123; temp = arr[j]; arr[j] = arr[j-h]; arr[j-h] = temp; &#125; &#125; &#125; h=(h-1)/3;&#125;return arr;&#125;var a =[92,31,5,96,44,88,34,57,44,72,20,83,4,623,12,12,932,54];shellSort(a);结果为： [4, 5, 12, 12, 20, 31, 34, 44, 44, 54, 57, 72, 83, 88, 92, 96, 623, 932] 2 快速排序首先在列表中选择一个基准值，数据围绕基准值进行分类，将小于基准值的放在基准值的左边，大于基准值的放在基准值的右边。快速排序对于大型数据集合非常实用，在处理小型数据集合时性能反而会下降12345678910111213141516171819function fastSort(arr)&#123;if(arr.length==0)&#123; return[];&#125;var lesser = [];var greater = [];var standard = arr[0];for(var i=1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;standard)&#123; lesser.push(arr[i]) &#125;else&#123; greater.push(arr[i]); &#125;&#125;return fastSort(lesser.concat(standard,fastSort(greater))&#125;var a =[68,80,12,95,70,97,27,88,93];fastSort(a);结果：[12, 27, 68, 70, 80, 88, 93, 95, 97]]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(2)]]></title>
    <url>%2F2017%2F06%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(2)%2F</url>
    <content type="text"><![CDATA[栈js中实现一个栈的低层数据结构是数组。 利用栈的几种情况示例1:数制之间的相互转换12345678910111213141516function chang(num,base)&#123; var arr=[]; var result = &quot;&quot;; do&#123; arr.push(num%base); num = num/base; &#125;while(num&gt;=1); arr.reverse(); for(var i=0;i&lt;arr.length;i++)&#123; result = result + arr[i]; &#125; return result;&#125;var haha = chang(256,8);console.log(haha);结果:400 示例2:判断回文123456789101112function back(s)&#123; var regexp=/[a-z]/gi;//全局匹配不区分大小写 var arr=s.match(regexp); var arrRevs=arr.reverse(); if(arr.join(&apos;&apos;)==arrRevs.join(&apos;&apos;))&#123; return true; &#125; return false;&#125;var str = &apos;A man, a plan, a canal: Panama&apos;; console.log(back(str));结果：true 队列队列先进先出，可以利用js中的push()和shift()方法从尾部增加，从头部删除。 利用队列的示例基数排序基数排序的基本原理：从个位，十位，百位的数字依次进行排序。12345678910111213141516171819202122232425262728293031323334353637383940414243//sort函数功能将数组根据个位或者十位的大小进行分组function sort(nums,digital,queue)&#123; for(var i=0;i&lt;nums.length;i++) &#123; if(digital==1)&#123; queue[nums[i]%10].push(nums[i]); &#125; else&#123; queue[Math.floor(nums[i]/10)].push(nums[i]); &#125; &#125; &#125;//将前面的排序结果选出，准备下次排序function out(queue)&#123; var arr=[]; for(var i=0;i&lt;10;i++)&#123; if(queue[i].length!=0)&#123; var h=queue[i].length; for(var j=0;j&lt;h;j++)&#123; arr.push(queue[i].shift()); &#125; &#125; &#125; return arr;&#125;var nums=[45,72,93,51,21,16,70,41,27,31];var queues=[];for(var i =0;i&lt;10;i++)&#123; queues[i]=[];&#125;sort(nums,1,queues);console.log(queues[1]);var temp = out(queues);console.log(temp);sort(temp,10,queues);var result = out(queues);console.log(result);结果: [51, 21, 41, 31] [70, 51, 21, 41, 31, 72, 93, 45, 16, 27] [16, 21, 27, 31, 41, 45, 51, 70, 72, 93] 链表一种不同于数组的一种底层存储的数据结构基于对象的列表包含两个类，分别为Node类和LinkedLise类；Node类的构造函数有两个属性1234function Node(element)&#123; this.element = element; this.next = null;&#125; LinkedList类的构造函数只有一个属性，此外还包含链表中的一些方法1234567function()&#123; this.head=new Node(&apos;head&apos;); this.find=find; this.insert=insert; this.remove=remove; this.display=display; &#125; 散列使用散列存储数据时，通过一个高效的散列函数将键映射到一个数字，这个数字的长度是0到散列表的长度。当散列对于多个输入同时产生同样的输出时，就会产生碰撞。解决散列表的碰撞问题的方法有1.开链法2.线性探测法。开链法：实现散列表的底层数组中，每个数组元素有都是一个新的数据结构，比如数组，这样就能存储多个键。线性探测法：检查散列表的下一个位置是否为空，如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空位置为止。 两种方法比较当数据量比较大的时候，存储数据使用数组比较大时，使用线性探测法比较好(数组大小是待存数据的两倍或两倍以上时)，其他使用开链法比较好。]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法]]></title>
    <url>%2F2017%2F06%2F14%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组数组中常用方法1. 判断数组方法 js中数组对外类型显示为object,因而判断数组的方式可以是调用Array.isArray();来判断数组。 示例1: var arr=[];console.log(Array.isArray(arr)) 结果:true 2.查找元素方法 数组查找方法有indexOf();该函数返回第一个与参数相同的元素的索引位置。laseIndexOf()该函数返回参数相同元素的最后的索引位置。 示例2:12var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];console.log(a.indexOf(&apos;you&apos;),a.lastIndexOf(&apos;you&apos;));结果:0 6 3. 数组的字符串表示 数组的字符串表示方法有join()和toString(); 示例3:123456var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];a.join();结果:&quot;you,need,to,live,a,life,you,will,remember&quot;var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];a.toString();结果:&quot;you,need,to,live,a,life,you,will,remember&quot;var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];a.join(&apos;&apos;);结果:s&quot;youneedtolivealifeyouwillremember&quot; 4. 从已有数组创建新的数组 concat()以及splice()方法都可以从已有数组中创建新的数组 示例4:123456789101112131415161718192021var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];a.concat(b);结果:[&quot;you&quot;, &quot;need&quot;, &quot;to&quot;, &quot;live&quot;, &quot;a&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;, &quot;I&quot;, &quot;remember&quot;, &quot;that&quot;, &quot;she&quot;, &quot;told&quot;, &quot;me&quot;]删除数组元素var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];a.splice(3);结果:[&quot;live&quot;, &quot;a&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;]var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];console.log(a.splice(3,2),a);结果: [&quot;live&quot;, &quot;a&quot;] (7) [&quot;you&quot;, &quot;need&quot;, &quot;to&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;]增加数组元素var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];console.log(a.splice(3,1,&apos;haha&apos;),a);结果:[&quot;live&quot;] (9) [&quot;you&quot;, &quot;need&quot;, &quot;to&quot;, &quot;haha&quot;, &quot;a&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;] 5.也可以利用push(),unshift(),pop(),shift()方法改变数组 push()方法从数组尾部添加一个元素，pop()方法从尾部删除一个元素，unshift()方法从头部增加一个元素，shift()方法从头部删除一个元素，以上方法均为返回该元素。 6. 迭代器方法 迭代器方法接受一个函数作为参数，对数组中每个元素应用该函数。 (1)不生成新数组的迭代器方法 forEach()方法接受一个函数作为参数，对数组中每个元素应用该函数。123456[1,24,4].forEach(function(n)&#123; console.log(n*n)&#125;);结果:157616 every()方法接受一个返回值为布尔类型的函数，对数组中每个元素使用该该函数，每个元素返回结果都为true时，该方法返回true，否则返回false123456function even(num)&#123; if(num%2==0) return true&#125;;[1,24,3].every(even);结果:false some()方法与every()方法类似，但是只要某个元素满足条件返回true,则该方法返回true12345function even(num)&#123; if(num%2==0) return true&#125;;[1,24,3].some(even); reduce()接受一个函数，返回一个值。它会从一个累加值开始，不断地对累加值和数组中的后续元素调用该函数12345function SUM(sum,currentValue)&#123; return sum+currentValue&#125;;[1,24,3].reduce(SUM)结果:28 (2)生成新数组的迭代器方法 map()方法与forEach()方法类型，只是返回一个新的数组1234var nums=[1,24,4];var newarr=nums.map(function(n)&#123;return(n*n)&#125;);console.log(nums,newarr);结果:[1, 24, 4] [1, 576, 16] filter()方法与every()方法类似，但是其返回的为满足条件为true时的新数组12345678910function grade(nums)&#123; if(nums&gt;60) return true&#125;;for(var i=0;i&lt;10;i++)&#123; var marks=[]; marks[i]=Math.floor(Math.random()*101);&#125;marks.filter(grade);结果:[97]]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中应该掌握的知识2.0]]></title>
    <url>%2F2017%2F06%2F12%2FJS%E4%B8%AD%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%862.0%2F</url>
    <content type="text"><![CDATA[柯里化(Currying)函数柯里化的含义:对于每一个逻辑参数，柯里化函数会逐渐返回已配置的函数，直到所有的参数用完。 示例1：123456789function Currying(n) &#123; return function(d)&#123; return n/d; &#125; &#125;;var result = Currying(10);result(2);结果:5 示例2:1234567891011function Currying(fun)&#123; return function(secondPara)&#123; return function(firstPara)&#123; return fun(firstPara,secondPara); &#125; &#125;&#125;function div(n,d)&#123;return n/d&#125;; var result = Currying(div)(2); result(10);结果:5]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中应该掌握的知识]]></title>
    <url>%2F2017%2F06%2F11%2FJS%E4%B8%AD%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[执行环境和作用域执行环境（环境）：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象。变量对象：环境中定义的所有变量和函数都保存在这个对象中。 每个函数都有自己的执行环境。当执行函数时，函数的环境会压栈，当函数执行完毕之后，退栈。把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的结构：1.当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。2.作用域的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境** 闭包相关知识闭包的定义：闭包是值有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式：就是在一个函数内部创建另外一个函数。 当执行某个函数时，会创建调用一个执行环境及相应的作用域链。然后，使用arguments和其他的命名参数的值来初始化函数的活动对象（active Object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位。。。。直到作为作用域的终点的全局执行环境。 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 在函数内部定义的函数会将外部函数（包含该内部函数的函数）的活动对象添加到它的作用域链中。作用域链的这种配置机制会引出一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。 1234567function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); element.onclick =function()&#123; console.log(element.id); &#125;&#125; 以上代码创建一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用，由匿名函数保持对assignHandler的引用。因此它所占的内存永远不会被回收。出现内存泄漏的现象。 函数调用之闭包:示例1:123456789101112131415var haha=&apos;hello&apos;; function test(n)&#123; var haha=&apos;hi&apos;; return function(n)&#123; return haha+n; &#125; &#125;console.log(test());结果: function (n)&#123; return haha+n; &#125; var result1 = test(); console.log(result1(&apos;123&apos;))结果: hi123 当然这里的参数n可以是任何类型，数组，对象，函数等。此外，需要注意JS中对于函数的调用和引用的不同 示例2:1234567891011121314151617var haha=&apos;hello&apos;; function test(n)&#123; var haha=&apos;hi&apos;; return function(n)&#123; return haha+n; &#125; &#125;console.log(test);var result1 = test;console.log(result1(&apos;123&apos;))结果: function test(n)&#123; var haha=&apos;hi&apos;; return function(n)&#123; return haha+n; &#125; &#125; 创建一个闭包可以在js中模仿一个块级作用域，要点如下： (1)创建并立即调用一个函数，这样既可以执行其中代码，又不会在内存中留下对该函数的引用。 (2)结果就是函数内部所有变量都被立即销毁——除非将某些变量赋值给了包含作用域中的变量。 apply和call的具体使用 obj.call(thisObj, arg1, arg2, ...); obj.apply(thisObj, [arg1, arg2, ...]); 两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj“继承”了obj的属性和方法。可以看出call和apply是为了动态改变this而出现的。 绑定后会立即执行函数。两者之间唯一区别是apply接受的是数组参数，call接受的是连续参数。 使用示例:示例3:1234567891011121314function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125;add(5,3); //8add.call(sub, 5, 3); //结果8add.apply(sub, [5, 3]); //结果8sub(5, 3); //2sub.call(add, 5, 3); //结果2sub.apply(add, [5, 3]); //结果2 调用原生对象的方法 对象a类似array，但不具备array的slice等方法。使用call绑定，这时候就可以调用slice方法。 示例4:12345var a = &#123;0:1, 1:&quot;yjc&quot;, length: 2&#125;; a.slice(); //结果TypeError: a.slice is not a functionArray.prototype.slice.call(a);//结果[1, &quot;yjc&quot;] js中实现继承的方法简单的原型链核心：拿父类实例来充当子类原型对象 123456789101112131415161718function Super()&#123; this.val = 1; this.arr = [1];&#125;function Sub()&#123; // ...&#125;Sub.prototype = new Super(); // 核心var sub1 = new Sub();var sub2 = new Sub();sub1.val = 2;sub1.arr.push(2);alert(sub1.val); // 2alert(sub2.val); // 1alert(sub1.arr); // 1, 2alert(sub2.arr); // 1, 2 优点：简单 缺点：修改sub1.arr后sub2.arr也变了，因为来自原型对象的引用属性是所有实例共享的。 借用构造函数123456789101112131415function Super(val)&#123; this.val = val; this.arr = [1]; this.fun = function()&#123; // ... &#125;&#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ...&#125;var sub1 = new Sub(1);var sub2 = new Sub(2); 核心：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型） 缺点：无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸 组合继承基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数实现对实例属性的继承 1234567891011121314151617function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心var sub1 = new Sub(1);var sub2 = new Sub(2); 把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Super.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Sub.prototype = new Super();继承父类函数，实现函数复用 优点：（1）不存在引用属性共享问题（2）可传参（3）函数可复用 缺点：子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的。。。又是内存浪费 拷贝for in 继承]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（1）]]></title>
    <url>%2F2017%2F01%2F14%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[行内元素有哪些？块级元素有哪些？CSS的盒模型？行内元素有：a b span I b em img input select strong;块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p;盒模型：由内到外：margin border padding width;2.CSS引入的方式有哪些? link和@import的区别是?（1） i. 使用 LINK标签将样式规则写在.css的样式文件中，再以&lt;link&gt;标签引入。 例如:&lt;link rel=stylesheet type=&quot;text/css&quot; href=&quot;example.css&quot;&gt;ii. 使用@import引入跟link方法很像，但必须放在… 中 例如:&lt;STYLE TYPE=&quot;text/css&quot;&gt;&lt;!-- @import url(css/example.css);--&gt;&lt;/STYLE&gt;iii. 使用STYLE标签将样式规则写在&lt;STYLE&gt;...&lt;/STYLE&gt;标签之中。iv. 使用STYLE属性 v. 使用&lt;span&gt;&lt;/span&gt;标记引入样式（2）两者区别：加载顺序的差别。当一个页面被加载的时候，link引用的css会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。@import可以在css中再次引入其他样式表，比如可以创建一个主样式表，在主样式表中再引入其他的样式表，这样做有一个缺点，会对网站服务器产生过多的HTTP请求，以前是一个文件，而现在却是两个或更多文件了，服务器的压力增大 前端页面由哪三层构成，分别是什么？作用是什么？ 网页分成三个层次，即：结构层、表示层、行为层。网页的结构层(structural layer)由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”网页的表示层(presentation layer) 由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。网页的行为层(behavior layer)负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript语言和DOM主宰的领域 H5&amp;css3在HTML5平台上，视频，音频，图象，动画，以及同电脑的交互都被标准化。HTML5的技术概览： HTML5新增和移除的元素 HTML5新增了很多多媒体和交互性元素如video, audio，在HTML4当中如果要嵌入一个视频或是音频的话需要引入一大段的代码，还有兼容各个浏览器，而HTML5只需要通过引入一个标签就可以，就像img标签一样方便。 HTML5对表单的支持 HTML5提供了强大的控件类型如url, email, date, tel等，强大的约束属性，如required表示必填，文件上传的accept属性，以及一些表单重复元素模型的支持，HTML5在提交表单的时候还可 以设置提交的方式为XML提交方式，这样服务器端接收到的数据将是XML格式，HTML5的表单被定义为“Web Forms 2.0” CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器 CSS3对于动画的支持 CSS3支持的动画类型有：transform(变换)、transition(过渡)和animation(动画)。你可以对特定的属性设置transition，transiton和animation的区别不大，animation的动画是自己定义的，面向的更多的是脚本开发者，往往更加复杂 如何理解HTML结构的语意化？i. 去掉或样式丢失的时候能让页面呈现清晰的结构ii. 屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页iii. PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）iv. 搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重，页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记v. W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率 谈谈以前端角度出发做好SEO需要考虑什么？ i.了解搜索引擎如何抓取网页和如何索引网页 &amp;nbsp;&amp;nbsp;你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot或叫web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。ii. Meta标签优化 &nbsp;&nbsp;主要包括主题(Title)，网站描述(Description)，和关键词(Keywords)。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。iii.如何选取关键词并在网页中放置关键词 &nbsp;&nbsp;搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。iv.了解主要的搜索引擎 &nbsp;虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。 v.主要的互联网目录 &nbsp;&nbsp;Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。vi.按点击付费的搜索引擎 &nbsp;搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。vii.搜索引擎登录 &nbsp;&nbsp;网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。viii.链接交换和链接广泛度（Link Popularity） &nbsp;&nbsp;网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。ix.标签的合理使用 经常遇到的浏览器的兼容性有哪些？怎么会出现？解决方法是什么？兼容性处理要点i. DOCTYPE影响CSS处理ii. FF: 设置padding后,div会增加height和width，但IE不会，故需要用!important多设一个height和widthiii. FF: 支持!important，IE则忽略，可用!important为 FF 特别设置样式iv. div 的垂直居中问题: vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行v. 在mozilla firefox和IE中的BOX模型解释不一致导致相差2px解决方法： &amp;nbsp;&amp;nbsp;div{margin:30px!important;margin:28px;} 注意这两个margin的顺序一定不能写反，!important这个属性IE不能识别，但别的浏览器可以识别。 所以在IE下其实解释成这样： div{maring:30px;margin:28px} 重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important; 浏览器差异i.ul和ol列表缩进问题 &nbsp;&nbsp;消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px; 其中margin属性对IE有效，padding属性对FireFox有效。 [注] 经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。ii.CSS透明问题 &nbsp;&nbsp;IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。 &nbsp;&nbsp;FF：opacity:0.6。 [注] 最好两个都写，并将opacity属性放在下面。iii.CSS圆角问题 IE：ie7以下版本不支持圆角。 iv.cursor:hand VS cursor:pointer 问题说明：firefox不支持hand，但ie支持pointer ，两者都是手形指示。 解决方法：统一使用pointerv.字体大小定义不同 对字体大小small的定义不同，Firefox中为13px，而IE中为16px，差别挺大。 解决方法：使用指定的字体大小如14px。 并列排列的多个元素（图片或者链接）的div和div之间，代码中的空格和回车在firefox中都会被忽略，而IE中却默认显示为空格（约3px） ajax是什么？ajax的交互模型？同步和异步的区别？如何解决跨域问题？ajax(动态网站静态化)伴随的goole 的推动，越来越多的站点开始使用了，在开大ajax(动态网站静态化)程序的时候会遇到很多的问题，主要有以下几个方面： i. 跨浏览器问题ii. 历史后退状态问题iii. 跨域问题跨浏览器的问题因为现在有很多的开元的框架已经解决了，我们无需为此而烦恼。历史后退状态问题我们可以使用一个数组来保存历史纪录，然后把这些数据村到历史对象中去，中的也可以解决，并且还有很多的开元框架给与支持，这样问题就不是很大 跨域的问题就不是很好的解决，但是还是有办法的，一下给出一些基本的解决方案供大家选择： i.使用代理，你可以使用web端的程序编写代理程序，把所有的ajax(动态网站静态化)请求的数据进行转发，web程序可以使php(做为现在的主流 开发语言)，jsp(SUN企业级应用的首选)，asp等所有的编程语言。相信大家对这种方式一定很熟悉，这里就不详细的介绍了 ii.使用iframe的方式来定时的刷新页面，这种方式只是取得数据来显示，并不能真正的和求得的数据进行交互，转化成本页面的动态数据，不是很可取，应用也不是很多。 iii.使用apache(Unix平台最流行的WEB服务器平台)的代理功能，主要就是apache(Unix平台最流行的WEB服务器平台)的方向代理，或者是url从定向，你也可以把其他的站点直接的挂在自己的网站上，这样的方式可能会友邦权的问题，多的九部介绍了，有兴趣的本有可以自己实践以下 iv.使用标签的方式，这样的话就可以保正使用真正的ajax(动态网站静态化)来跨域，并且可以使用返回来的数据，在我们的后台程序处理后的到的结果都直接的用javascript 的方式返回，在我们的html中直接的使用返回数据的变量就可以了]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-promise]]></title>
    <url>%2F2017%2F01%2F13%2FES6-promise%2F</url>
    <content type="text"><![CDATA[含义：Promise是一个对象，从它可以获取异步操作的消息。它有两个特点： 1.对象的状态不受外界影响：Promise对象代表一个异步操作，有三种状态：pending（进行中），Resolved（已完成），Rejected(已失败)。只有异步操作的结果才能决定当前是哪一种状态，其他操作都无法改变这个状态。 2.一旦状改变就不会再变。一旦状态幼pending转变为Resolved或者Rejected之后，就不会再变，会一直保持这个结果。 优点：有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise的基本实现:1234567var promise = new Promise(function(resolve,reject)&#123; if(异步操作成功)&#123;| resolve(value) &#125;else reject(error)&#125;) Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数 12promise.then(function(value)&#123;&#125;,function(error)&#123;&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Rejected时调用。其中，第二个函数是可选的，不一定要提供。 示例1123456789101112function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;timeout(1000).then(() =&gt; &#123; console.log(&quot;haha&quot;);&#125;);Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;haha 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 示例212345678910var promise=new Promise((resolve,reject)=&gt;&#123; console.log(1); resolve();&#125;);promise.then(()=&gt;&#123;console.log(2)&#125;);console.log(3);VM505:2 1VM505:6 3VM505:5 2 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);结果：2 1 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给then方法的回调函数。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 1234567891011121314var promise = new Promise(function(resolve, reject) &#123;// console.log(&quot;haha&quot;);// resolve(4); throw new Error(&apos;test&apos;);&#125;);promise.then((value)=&gt;&#123;console.log(value)&#125;).catch(function(error) &#123; console.log(error);&#125;);结果：Error: test at &lt;anonymous&gt;:4:9 at Promise (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:15 若在此之前调用resolve()方法，则不会catch到错误，因为得到Resolved状态后，状态不会再改变。 Promise.all()Promise.all方法接受一个数组作为参数Promise.all([p1,p2,p3])，p1、p2、p3都是 Promise 实例。 p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Demo：同时并发现象（一次性计算10个数）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function add(a, b, cb)&#123; setTimeout(function()&#123; cb(a + b); &#125;, 1000);&#125;function addQ(a, b)&#123; return new Promise((resolve, reject) =&gt; &#123; add(a, b, function(result) &#123; resolve(result); &#125;); &#125;);&#125; let running = false, i = 0, task = [];let timerID = setInterval(() =&gt; &#123; if(running) &#123; return; &#125; running = true;// 任务结束条件 if(i == 10) &#123; running = false; clearInterval(timerID); Promise.all(tasks) .then((results) =&gt; &#123; console.log(results); &#125;); &#125; //任务可以继续 let task = addQ(i, 2) .then((result) =&gt; &#123; return addQ(3, result); &#125;) .then((result) =&gt; &#123; return addQ(4, result); &#125;) .then((result) =&gt; &#123; running = false; return result; &#125;); tasks.push(task); i++;&#125;, 200);add(1, 2, function(result)&#123; add(result, 3, function(result)&#123; add(result, 4, function(result)&#123; console.log(result); &#125;); &#125;);&#125;);]]></content>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Git命令]]></title>
    <url>%2F2017%2F01%2F12%2Fcommon-knowledge%2F</url>
    <content type="text"><![CDATA[Git需要掌握的命令：git branch（列出所有本地分支） git init （在当前目录新建一个git代码库） git add -a （添加指定文件到暂时存在的地方） git commit （可以将已经标识的内容提交到本地仓库） git commit -a （提交工作区从上次commit之后的变化，直接到仓库内） git commit -m （提交暂存区到仓库内） git checkout -b 分支名称 （可以创建自己的分支，一般情况下分支名称用你的名字拼音） git remote add 源名称 https网址 （在本地初始化的仓库中配置远程服务器地址和源名称） git checkout 分支名称 （切换至本地已经存在的分支） git push 源名称（origin） 分支名称 （将本地分支名称发送到远程服务器） git pull 源名称 分支名称 （将远程服务器指定分支下载到本地，如果与当前分支有冲突需合并） git merge 分支名称 （将指定的分支合并到当前分支） git clone [url] （下载一个项目和他的整个历史代码） git status （显示有变更的文件） git log （查看当前分支的历史版本） *.gitignore文件可以标记当前路径中哪些文件可以不进行git管理。为了避免将依赖代码和自己开发代码一起审核的混乱，我们一般会忽略node_modules和bower_components目录，同时也会忽略.DS_STORE这种操作系统缓存文件。 node.js含义：nodejs 是一个将Google V8 Javascript引擎与封装给Javascript使用的系统API集合，nodejs还提供了npm包管理工具来管理依赖包关系，cnpm是npm工具的国内版本，下载速度更快。 Npm含义：npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）。 npm init命令可以初始化当前路径，建立package.json，通过npm install 包名称可以将工具安装到当前目录的node_modules中，通过sudo npm install -g 包名称可以讲工具安装到全局（也就是任意目录下均可以使用）；通过–save,–save-dev参数分别可以将依赖包标记为运行时依赖和开发阶段依赖。 Cnmp的含义：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 Bower的含义：bower init命令可以初始化当前路径的前端包依赖，建立bower.json，通过bower install包名称可以安装前端包到bower_components目录中； 通过–save,–save-dev参数分别可以将依赖包标记为运行时依赖和开发阶段依赖。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js知识]]></title>
    <url>%2F2017%2F01%2F12%2F%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[删除自身元素12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=&quot;J_container&quot;&gt; &lt;div class=&quot;record-head&quot;&gt; &lt;div class=&quot;head id&quot;&gt;序号&lt;/div&gt;&lt;div class=&quot;head name&quot;&gt;姓名&lt;/div&gt;&lt;div class=&quot;head sex&quot;&gt;性别&lt;/div&gt;&lt;div class=&quot;head tel&quot;&gt;电话号码&lt;/div&gt;&lt;div class=&quot;head province&quot;&gt;省份&lt;/div&gt;&lt;div class=&quot;head&quot;&gt;操作&lt;/div&gt; &lt;/div&gt; &lt;ul id=&quot;J_List&quot;&gt; &lt;li&gt;&lt;div class=&quot;id&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;name&quot;&gt;张三&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt;&lt;div class=&quot;tel&quot;&gt;13788888888&lt;/div&gt;&lt;div class=&quot;province&quot;&gt;浙江&lt;/div&gt;&lt;div class=&quot;user-delete&quot; &gt;删除&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;id&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;name&quot;&gt;李四&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;女&lt;/div&gt;&lt;div class=&quot;tel&quot;&gt;13788887777&lt;/div&gt;&lt;div class=&quot;province&quot;&gt;四川&lt;/div&gt;&lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;id&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;name&quot;&gt;王二&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt;&lt;div class=&quot;tel&quot;&gt;13788889999&lt;/div&gt;&lt;div class=&quot;province&quot;&gt;广东&lt;/div&gt;&lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt;// 此处也可换成ES6的写法function Contact()&#123; this.init();&#125;var _ul = document.getElementsByTagName(&apos;ul&apos;)[0];var _li = _ul.getElementsByTagName(&apos;li&apos;);var _delete = document.getElementsByClassName(&quot;user-delete&quot;);// console.log(_li[1].parentNode.removeChild(_li[1]));// console.log(_li[0].childNodes[5]===_delete[0])for(var i=0;i&lt;_li.length;i++)&#123; _delete[i].onclick=function()&#123; this.parentNode.parentNode.removeChild(this.parentNode); &#125;&#125;//删除元素自己本身，利用this.parentNode.removeChild(this);//删除元素父类，利用this.parentNode.parentNode.removeChild(this.parentNode); &lt;/script&gt; 原生Ajax的实现1.1234567var xmlHttp;function createxmlHttpRequest()&#123;if(window.ActiveXObject)&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;else if(window.XMLHttpRequest) xmlHttp=new XMLHttpRequest();&#125; 2.GET方法 1234567891011121314151617function doGet(url)&#123;//注意在传参数值的时候最好使用encodeURI处理一下，防止乱码 createxmlHttpRequest(); xmlHttp.open(&quot;GET&quot;,url); xmlHttp.send(null); xmlHttp.onreadystatechange=function()&#123; if(xmlHttp.readyState==4&amp;&amp;xmlHttp.status==200)&#123; //0 代表未初始化。 还没有调用 open 方法 //1 代表正在加载。 open方法已被调用，但send方法还没有被调用 //2 代表已加载完毕。send 已被调用，但是尚未接受到响应 //3 代表交互中。服务器正在发送响应，已经接受到部分响应 //4 代表完成。响应发送完毕 alert(&apos;success&apos;); &#125;else&#123; alert(&apos;fail&apos;); &#125; &#125;&#125; 在接受到响应之前还可以调用abort()方法来取消异步请求。 其中url的格式为： 1.传递的参数必须在？后指定，多个参数时用&amp;分隔。 2.GET方法请求同一URL时会有缓存，通过参数是否一致来判断 3.解决缓存问题，价格时间戳即可，使得每次的参数不一致 具体方式：1url+Math.random() 2.POST方法 12345678910111213function doPost(url,data)&#123;//注意在传参数值的时候最好使用encodeURI处理一下，防止乱码 createxmlHttpRequest(); xmlHttp.open(&quot;POST&quot;,url); xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlHttp.send(data); xmlHttp.onreadystatechange=function()&#123; if(xmlHttp.readyState==4&amp;&amp;xmlHttp.status==200)&#123; alert(&apos;success&apos;); &#125;else&#123; alert(&apos;fail&apos;); &#125; &#125;&#125; 这里注意： 1.POST方法没有缓存 2.POST方法发送数据量大 3.Ajax无法发送文件 4.readyState改变时触发onreadystatechange事件，4为完成。 5.status是返回状态，200便是成功，404是找不到页面 6.responseText是返回的数据，为字符串格式 JsonJSON(JavaScript Object Notation, JS 对象标记） JSON 和 JS 对象互转 要实现从对象转换为 JSON 字符串，使用 JSON.stringify() 方法：1var json = JSON.stringify(&#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;); //结果是 &apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos; 要实现从 JSON 转换为对象，使用 JSON.parse() 方法：1var obj = JSON.parse(&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;); //结果是 &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125; 优点：书写简单，一目了然；符合JavaScript原生语法，可以由解释引擎直接处理，不用另外添加解析代码。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习经历]]></title>
    <url>%2F2017%2F01%2F12%2Fyopu%2F</url>
    <content type="text"><![CDATA[前端发布（打版本到服务器）打开项目文件（此文件不能做任何添加和改动，复制文件命名）git pull origin masterrun deploy:prod （命令结束之后会在文件夹下生成一个新文件dist目录）桌面上找到服务器进去（user01软件）选择左边的站点进入/root/var/www/html删除除了pmn以外的文件复制dist中的所有文件到/var/www/html内]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
</search>