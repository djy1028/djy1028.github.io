<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(9)]]></title>
    <url>%2F2017%2F06%2F29%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(9)%2F</url>
    <content type="text"><![CDATA[装饰者模式装饰者模式能够在不改变对象自身的基础上，在程序运行期间为对象动态的增加新的职责。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。其作用实际就是为对象动态地加入新的职责和行为。 用AOP装饰函数1234567891011121314151617181920Function.prototype.before=function(beforefn)&#123; var self=this; //保存原函数的引用 return function()&#123; beforefn.apply(this,arguments); //执行新函数，且保证this不会被劫持，新的函数的参数也会被原封不动的传入原函数，新函数在原函数之前执行(共用一组参数列表) return self.apply(this,arguments); //执行原函数，并且返回原函数执行结果，并且保证this不会被劫持 &#125;&#125;Function.prototype.after=function(afterfn)&#123; var self=this; //返回一个代理函数，代理函数分别执行新函数与原函数 return function()&#123; var ret=self.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125; 也可以在不污染原型的情况下，做出一些变通，123456789101112var before=function(fn,beforefn)&#123; return function()&#123; beforefn.apply(this,arguments); return fn.apply(this,arguments); &#125;&#125;var a =before(function()&#123;console.log(1)&#125;,function()&#123;console.log(2)&#125;);a=before(a,function()&#123;console.log(5)&#125;);a();结果： 5 2 1 利用AOP装饰函数的技巧，可以把行为依照职责分成粒度更加细的函数，随后将它们装饰合并到一起，有利用一个松耦合高复用的系统。 利用AOP动态改变函数的参数1234567891011121314151617Function.prototype.before=function(fn)&#123; var self=this; return function()&#123; fn.apply(this,arguments); return self.apply(this,arguments); &#125;&#125;var func=function(para)&#123; console.log(para)&#125;func=func.before(function(para)&#123; para.b=&apos;b&apos;;&#125;)func(&#123;a:&apos;a&apos;&#125;)结果：Object &#123;a: &quot;a&quot;, b: &quot;b&quot;&#125; 值得注意的是：Function.prototype.before或者Function.prototype.afte被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会发生丢失。1234567891011121314151617181920Function.prototype.before=function(fn)&#123; var self=this; return function()&#123; fn.apply(this,arguments); return self.apply(this,arguments); &#125;&#125;var func=function(haha)&#123; console.log(haha)&#125;//原函数的属性func.a=&apos;a&apos;func=func.before(function(para)&#123; para.c=&apos;c&apos;;&#125;)func(&#123;b:&apos;b&apos;&#125;)//属性发生了丢失Object &#123;b: &quot;b&quot;, c: &quot;c&quot;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(10)]]></title>
    <url>%2F2017%2F06%2F29%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(10)%2F</url>
    <content type="text"><![CDATA[状态模式状态模式额关键在于区分事物内部的状态，事物内部状态的改变往往会带来行为的改变。 通常我们谈到的封装，一般会优先封装状态的行为，但是在状态模式中正好相反，状态模式的关键是将事物的每种状态都封装成单独的类，与此种状态有关的行为也会被封装在这个类的内部。 状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 将这句话拆分开来解释的话就是：将状态封装成独立的类，并将请求委托给当前的状态对象，当对象内部状态发生改变时，会通过改变行为带来不同的变化。我们使用的对象，在不同状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//定义一个Light类（context），随后在Light类的构造函数中创建每个状态类的实例对象，context将持有这些状态对象的引用，以便把请求委托给状态对象。var Light=function()&#123; this.offLightState= new OffLightState(this); this.weakLightState=new WeakLightState(this); this.strongLightState=new StrongLightState(this); this.button=null;&#125;Light.prototype.init=function()&#123; var button =document.createElement(&apos;button&apos;); self=this; this.button=document.body.appendChild(button); this.button.innerHTML=&apos;开关&apos;; this.currState=this.offLightState; this.button.onclick=function()&#123; self.currState.buttonWasPressed(); &#125;&#125;//建立每个状态类var OffLightState=function(light)&#123; this.light=light;&#125;OffLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;weaklight&apos;); this.light.setState(this.light.weakLightState);&#125;var WeakLightState=function(light)&#123; this.light=light;&#125;WeakLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;stronglight&apos;); this.light.setState(this.light.strongLightState);&#125;var StrongLightState=function(light)&#123; this.light=light;&#125;StrongLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;offlight&apos;); this.light.setState(this.light.offLightState);&#125;//设置状态Light.prototype.setState=function(newState)&#123; this.currState.newState;&#125;var light=new Light();light.init(); 状态模式的优点 1.定义了状态和行为之间的关系，并将其封装在一个类中。通过增加新的状态类，很容易增加新的状态和转换。 2.Context中的请求动作和状态类中的封装的行为可以非常容易的独立变化而不相互影响。 1234567891011121314151617181920212223242526272829303132var Light=function()&#123; this.currState=FSM.off; this.button=null;&#125;Light.prototype.init=function()&#123; var button=document.createElement(&apos;button&apos;); self=this; this.button.onclick=function()&#123; //把请求委托给FSM状态机 self.currState.buttonWasPressed.call(self); &#125;&#125;var FSM=&#123; off:&#123; buttonWasPressed:function()&#123; console.log(&apos;关灯&apos;); this.currState=FSM.on; &#125; &#125;, on:&#123; buttonWasPressed:function()&#123; console.log(&apos;开灯&apos;); this.currState=FSM.off; &#125; &#125;&#125;var light=new Light();light.init(); 利用call()方法直接把请求委托给某个字面量对象来执行。 设计原则1.单一职责原则：一个对象(方法)只做一件事情，即将对象划分为较小的粒度使用。 2.最少知识原则：提供中介、只暴露必须的API接口，降低对象之间的耦合。 3.开放-封闭原则：软件实体（模块，类，函数等）应该是可以扩展的但是不可以修改(AOP扩展) 常用的方法来保证开放-封闭原则： 1.用对象的多态性(同一消息对不同对象产生不同效果)来消除条件分支语句。 2.放置挂钩。利用挂钩的结果来决定程序的下一步走向。 3.使用回调函数。回调函数是一种特殊的挂钩，可以把一部分易于变化的部分封装在回调函数里，然后回调函数当做参数传入一个稳定的封闭函数中。当回调函数被执行时，程序就会因为回调函数内部的逻辑不同而产生不同的效果。 写代码需要注意：提炼函数、合并重复条件片段、合理使用循环、传递对象参数代替过长的参数列表、尽量减少参数数量、使用return退出多重循环]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(8)]]></title>
    <url>%2F2017%2F06%2F28%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(8)%2F</url>
    <content type="text"><![CDATA[职责链模式定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，再将这些对象练成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。 异步的职责链1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Chain=function(fn)&#123; this.fn=fn; this.successor=null;&#125;//指定在链中的下一个节点Chain.prototype.setNextSuccessor=function(successor)&#123; return this.successor=successor;&#125;//传递请求给某节点Chain.prototype.passRequest=function()&#123; var ret = this.fn.apply(this,arguments); if(ret==&apos;nextSuccessor&apos;)&#123; return this.successor&amp;&amp;this.successor.passRequest.apply(this.successor,arguments); &#125;&#125;Chain.prototype.next=function()&#123; return this.successor.passRequest.apply(this.successor,arguments);&#125;var fn1=new Chain(function()&#123; console.log(1); return &apos;nextSuccessor&apos;;&#125;)var fn2=new Chain(function()&#123; console.log(2); var self=this; setTimeout(function()&#123;self.next()&#125;,1000); return &apos;nextSuccessor&apos;&#125;)var fn3=new Chain(function()&#123; console.log(3); return &apos;nextSuccessor&apos;;&#125;)var fn4=new Chain(function()&#123; console.log(4);&#125;)fn1.setNextSuccessor(fn2);fn2.setNextSuccessor(fn3);fn3.setNextSuccessor(fn4);fn1.passRequest();VM835:24 1VM835:29 2VM835:36 3VM835:41 4一秒过后VM835:36 3VM835:41 4 除此之外，也可以用AOP实现职责链。 中介者模式其作用是解除对象与对象之间的紧耦合关系。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; 选择颜色:&lt;select id=&quot;colorSelect&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;红色&lt;option&gt; &lt;option value=&quot;blue&quot;&gt; 蓝色&lt;/option&gt; &lt;/select&gt; 输入购买量:&lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt; 你选择的颜色:&lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt; 你输入的数量:&lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt; &lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和数量&lt;/button&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var colorSelect=document.getElementById(&quot;colorSelect&quot;), numberInput=document.getElementById(&quot;numberInput&quot;), colorInfo=document.getElementById(&quot;colorInfo&quot;), numberInfo=document.getElementById(&quot;numberInfo&quot;), nextBtn=document.getElementById(&apos;nextBtn&apos;); var goods=&#123;&apos;red&apos;:3,&apos;blue&apos;:6&#125;; colorSelect.onchange=function()&#123; var color=this.value, number=numberInput.value, stock=goods[color]; colorInfo.innerHTML=color; if(!color)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot;; return; &#125; if(number&gt;stock)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;库存不足&quot;; return; &#125; nextBtn.disalbed=false; nextBtn.innerHTML=&quot;放入购物车&quot;; &#125; numberInput.oninput=function()&#123; var color=this.value, number=numberInput.value, stock=goods[color]; numberInfo.innerHTML=number; if(color==&quot;&quot;)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot; &#125; if(number&gt;stock)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;库存不足&quot;; &#125;else&#123; nextBtn.disalbed=false; nextBtn.innerHTML=&quot;放入购物车&quot;; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 使用中介者模式改变之后，所有的节点只和中介者进行通信，当下拉框colorSelect和文本输入框numberInput发生了事件变化时，它们仅仅通知中介者它们发生了改变，同时把自身以参数的形式传入中介者，以便中介者辨别是谁发生了改变。12345678910111213141516171819202122232425262728293031var mediator=(function()&#123; var colorSelect=document.getElementById(&quot;colorSelect&quot;), numberInput=document.getElementById(&quot;numberInput&quot;), colorInfo=document.getElementById(&quot;colorInfo&quot;), numberInfo=document.getElementById(&quot;numberInfo&quot;), nextBtn=document.getElementById(&apos;nextBtn&apos;); var goods=&#123;&apos;red&apos;:3,&apos;blue&apos;:4&#125;; return&#123; changed:function(obj)&#123; var color=colorSelect.value, number=numberInput.value, stock=goods[color]; colorInfo.innerHTML=color; if(obj===colorSelect)&#123; colorInfo.innerHTML=color; &#125;else if(obj==numberInput)&#123; numberInfo.innerHTML=number; &#125; if(!color)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot;; return; &#125; &#125; &#125; &#125;)()colorSelect.onchange=function()&#123; console.log(this); mediator.changed(this); &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(5)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(5)%2F</url>
    <content type="text"><![CDATA[观察者模式(发布-订阅模式)它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。 js中一般使用注册回调函数的形式来代替传统的观察者模式，并且arguments可以很方便地表示参数列表，因而一般用推模型使用Function.prototype.apply方法将所有参数都推送给订阅者。 观察者模式优点：时间上解耦，对象之间的解耦。 命令模式应用场景：有时候需要向某些对象发送请求，但是不知道请求的接受者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接受者消除彼此之间的耦合关系。 js中的利用闭包实现命令模式：123456789101112131415161718192021var setCommand=function(button,command)&#123; button.onclick=function()&#123; command.execute; &#125;&#125;var MenuBar=&#123; refresh:function()&#123; console.log(&apos;刷新菜单界面&apos;) &#125;&#125;var RefreshMenuBarCommand=function(receiver)&#123; return &#123; execute:function()&#123; receiver.refresh; &#125; &#125;&#125;var RefreshMenuBarCommand=RefreshMenuBarCommand(MenuBar);setCommand(button1,RefreshMenuBarCommand); 宏命令通过宏命令，一次可以执行一批命令12345678910111213141516171819202122232425262728293031323334var closeDoorCommand=&#123; execute:function()&#123; console.log(&apos;1&apos;); &#125;&#125;var openDoorCommand=&#123; execute:function()&#123; console.log(&apos;2&apos;); &#125;&#125;var openWindow=&#123; execute:function()&#123; console.log(&apos;3&apos;); &#125;&#125;var MacroCommand=funciton()&#123; return&#123; commandList:[], add:funciton(command)&#123; this.commandList.push(command) &#125;, execute:function()&#123; for(var i=-0,command;command=this.commandList[i++];)&#123; command.execute; &#125; &#125; &#125; &#125;var macroCommand=MacroCommand();macroCommand.add(closeDoorCommand);macroCommand.add(openDoorCommand);macorCommand.add(openWindow);macroCommand.execute; 组合模式组合模式就是用小的对象来构建更大的对象，而这些小的子对象本身也许来自更小的对象。上一节中的宏命令即为一个组合模式的例子。 注意1.组合模式不是父子关系，组合模式把对象的请求委托给它包含的所有叶对象。 2.组合模式除了要求组合对象和叶对象拥有相同的接口，还要求对一组叶对象的操作必须具有一致性。 3.可以用职责连模式来提高组合模式的性能]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(4)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)%2F</url>
    <content type="text"><![CDATA[代理模式定义：为一个对象或提供一个代用品或占位符，以便控制对它的访问。 代理模式分为保护代理和虚拟代理。保护代理是用于控制不同权限对象对目标对象的访问。虚拟代理会把一些开销很大的对象，延迟到真正需要它的再去创建。 代理的意义实现单一职责原则。即，就一个类（通常也包括对象和函数），应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，意味着将这些职责耦合到了一起，这种耦合会导致脆弱和迪内聚的设计。 示例加载一张图片：12345678910var myImage=(funciton()&#123; var imgNode=document.creatElement(&apos;img&apos;); document.body.appendChild(imgNode); return&#123; setSrc:function(src)&#123; imgNode.src=src &#125; &#125;&#125;)()myImage.setSrc(&quot;..........&quot;) 增加代理之后，将预加载与图片加载分离：12345678910111213var proxyImage=(function()&#123; var img=new Image; img.onload=function()&#123; myImage.setSrc(this.src); &#125; return&#123; setSrc:function(src)&#123; myImage.setSrc(&apos;本地的loading图片&apos;); img.src=src; &#125; &#125;&#125;)()proxyImage.setSrc(&apos;真正图片&apos;)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(7)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(7)%2F</url>
    <content type="text"><![CDATA[享元模式享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 享元模式要求将对象的属性划分为内部状态与外部状态(这里的状态通常指属性)。其目标是尽量减少共享对象的数量。具体的内部对象是指独立于具体的场景，通常不会改变，外部对象是指取决于具体场景，并且根据外部场景的变化，外部状态不能被共享。 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里面获取。如果对象池是没有空闲对象，则新建一个新的对象，当获取出的对象完成了它的职责之后，再次进入池子等待被获取。1234567891011121314151617181920212223242526272829303132333435363738var toolFactory=(function()&#123; var toolPool=[]; return&#123; create:function()&#123; if(toolPool.length==0)&#123; var div=document.creat(&apos;div&apos;); document.body.appendChild)(div); return div; &#125;else&#123; return toolPool.shift(); &#125; &#125;, recover:function(toolDom)&#123; return toolPool.push(toolDom); &#125; &#125;&#125;))()var arr=[];//创建两个节点for(var i=0,str;str=[&apos;a&apos;,&apos;b&apos;][i++];)&#123; var toolTip=toolFactore.create(); toopTip.innerHTML=str; arr.push(toopTip);&#125;//回收进对象池for(var j=0,tooptip;tooptip=arr[i++];)&#123; toolFactory.recover(tooptip);&#125;//再次创建节点时可以直接从对象池里面获取for(var k=0,str;str=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;][i++];)&#123; var toopTip=toolFactory.create(); toopTip.innerHTML=str;&#125; 通用的对象池12345678910111213141516171819202122232425var toolFactory=function(fn)&#123; var toolPool=[]; return&#123; create:function()&#123; if(toolPool.length==0)&#123; return fn.apply(this.arguments); &#125;else&#123; return toolPool.shift(); &#125; &#125;, recover:function(obj)&#123; return toolPool.push(obj); &#125; &#125;&#125;var finalFactory=toolFactory(function()&#123; var div = document.create(&apos;div&apos;); document.body.appendChild(div); return div;&#125;)var tooltip=finalFactory.create();tooltip.innerHTML=&apos;a&apos;;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(6)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(6)%2F</url>
    <content type="text"><![CDATA[# 模板方法模式 模板方法模式是一种只需要使用继承就可以实现的简单模式。 通常该方法由两个部分组成：第一部分是抽象父类，第二部分是具体的实现子类。通常在父类中封装了子类的算法框架，包括一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也就继承了整个算法结构。 在模板方法中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。 示例：冲泡茶和冲泡咖啡的过程大致可以总结为以下几个步骤： 1.把水煮沸 2.用沸水冲泡 3.将冲泡好的导入杯子中 4.加其他调料 于是可以这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var Beverage = function()&#123;&#125;;Beverage.prototype.boilWater=function&#123; console.log(&apos;冲水&apos;);&#125;Beverage.prototype.brew=funciton()&#123;&#125;;Beverage.prototype.pourInCup=function()&#123;&#125;;Beverage.prototype.addCondiments=funciton()&#123;&#125;;Beverage.prototype.init=function()&#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); &#125;//***********************************************************************对于咖啡和茶，用不同的子类继承该父类var Coffee=funciton()&#123;&#125;;Coffee.prototype=new Beverage();接下来可以调用Beverage的原型方法，并加入自己的不同之处Coffee.prototype.brew=function()&#123; console.log(&apos;用水冲咖啡&apos;);&#125;Coffee.prototype.pourInCup=function()&#123; console.log(&apos;把咖啡倒进杯子&apos;);&#125;Coffee.prototype.addCondiments=function()&#123; console.log(&apos;加糖&apos;);&#125;var coffee = new Coffee();coffee.init();//******************************************************************var Tea=function()&#123;&#125;;Tea.prototype=new Beverage();Tea.prototype.brew=function()&#123; console.log(&apos;用水冲茶&apos;)&#125;Tea.prototype=function()&#123; console.log(&apos;把茶倒入杯子中&apos;);&#125;Tea.prototype=function()&#123; console.log(&apos;加入柠檬&apos;);&#125;var tea=new Tea();tea.init(); 这里，真正的模板方法是Beverage.prototype.init()。因为该方法中封装了子类的算法框架，它作为一个算法框架，知道子类以何种顺序去执行那些算法。在Beverage.prototype.init()方法中，算法的每一个步骤都清晰的呈现在眼前。 js中在父类中有些抽象方法只是被声明，但是并没有具体的实现方法，如果在子类中忘记重写，显然不是我们所需要的。解决方法可以有：1234567Beverage.prototype.brew=funciton()&#123; throw new Error(&apos;子类必须重写brew方法&apos;)&#125;;Beverage.prototype.pourInCup=function()&#123; throw new Error(&apos;子类必须重写pourInCup方法&apos;)&#125; 让Beverage.prototype.brew()等方法抛出一个异常。 应用场景Web开发中在构建UI组件的过程可以用到模板模式： 1.初始化一个div容器 2.通过ajax请求拉取相应的数据 3.把数据渲染到div容器里，完成组件的构造 4.通知用户组件渲完毕 钩子方法模板封装子类的算法框架适合用于大多数子类，但是如果有些特别‘个性’子类，就需要让子类可以跳出模板的约束。这时，可以用钩子方法来隔离变化，究竟需不需要钩子则由子类决定。12345678910111213141516171819202122232425262728293031Beverage.prototype.customWantCondiments=function()&#123; return true;&#125;Beverage.prototype.addCondiments=funciton()&#123;&#125;;Beverage.prototype.init=function()&#123; this.boilWater(); this.brew(); this.pourInCup(); if(this.customWantCondiments())&#123; this.addCondiments(); &#125; &#125;var Coffee=funciton()&#123;&#125;;Coffee.prototype=new Beverage();Coffee.prototype.addCondiments=function()&#123; console.log(&apos;加糖&apos;);&#125;Coffee.prorotype.customWantConiments=function()&#123; window.confirm(&apos;要加调料吗？&apos;)&#125;var coffee = new Coffee();coffee.init(); ‘好莱坞原则’允许低层组件将自己挂钩到高层组件中，而高层组件会决定在什么时候，以何种方式去使用这些低层组件。而模板方法模式就是该原则的一个重要体现，当我们用模板方法模式来进行编码时，就意味着我们放弃了对自己的控制权，而改为父类通知子类哪些方法应该在什么时候被调用。而作为子类，只是负责提供一些设计上的细节。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式基础(2)]]></title>
    <url>%2F2017%2F06%2F26%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)%2F</url>
    <content type="text"><![CDATA[闭包闭包在js中的作用：1.封装变量 2.延续局部变量的寿命 利用闭包解决onclick时间被异步触发123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++) &#123; node[i].onclick=function()&#123; console.log(i); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 无论点击那个div,都会出现5，因为for循环早已结束，而onclick为异步调用。 解决方法 将每次循环的i值封闭起来。当在事件函数中顺着作用域链从内而外查找变量i时，会先找到被封闭在闭包环境中的i12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++) &#123; (function(i)&#123; node[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i) &#125;&lt;/script&gt;&lt;/html&gt;结果：2 3 闭包优缺点： 优点：将变量封闭在闭包中，是因为后续可能依然还会用到。缺点：会带来内存泄漏的问题。 高阶函数充分条件： 1.函数可以作为一个参数被传递 函数作为参数传递案例包括：1.回调函数 2.Array.prototype.sort()方法 2.函数可以作为返回值输出。 1.判断数据类型1234567891011121314151617181920Object.prototype.toString.call([1]);&quot;[object Array]&quot;Object.prototype.toString.call(&#123;a:1&#125;);&quot;[object Object]&quot;Object.prototype.toString.call(&apos;haha&apos;);&quot;[object String]&quot;Object.prototype.toString.call(1);&quot;[object Number]&quot;Object.prototype.toString.call(true);&quot;[object Boolean]&quot;Object.prototype.toString.call(undefined);&quot;[object Undefined]&quot;Object.prototype.toString.call(null);&quot;[object Null]&quot; 3.实现AOP编程 js中的AOP实现一般是将一个函数‘动态织入’另外一个函数。123456789101112131415161718192021222324252627282930313233Function.prototype.before = function(beforefn)&#123; var self=this; //保存原函数的引用 return function()&#123; beforefn.apply(this,arguments); //修正this，执行新函数 return self.apply(this,arguments);//修正this，执行原函数 &#125;&#125;var func=function()&#123;console.log(2)&#125;;func = func.before(function()&#123;console.log(3)&#125;);func()结果：3 2Function.prototype.before = function(beforefn)&#123; var self=this; return function()&#123; beforefn.apply(null,arguments); return self.apply(null,arguments); &#125;&#125;;Function.prototype.after = function(afterfn)&#123; var self = this; return function()&#123; self.apply(this,arguments); return afterfn.apply(this,arguments); &#125;&#125;var func=function()&#123;console.log(2)&#125;;func = func.before(function()&#123;console.log(3)&#125;).after(function()&#123;console.log(1)&#125;);func() 3 2 1]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(3)]]></title>
    <url>%2F2017%2F06%2F26%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)%2F</url>
    <content type="text"><![CDATA[单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局节点。 js中的单例模式是为了避免全局变量的使用，降低全局变量带来的污染。具体方法有： 1.使用命名空间 2.使用闭包封装私有变量 惰性单例定义：仅仅在需要时候才创建对象实例。 通用的惰性单例模式：123456var getSingle = function(fn)&#123; var result; return function()&#123; return result||(fn.apply(this,arguments)); &#125;&#125; 策略模式定义：定义一系列算法，把它们一个个封装起来。将算法的使用和算法的实现分离开来。12345678910var stratgies=&#123; &quot;s&quot;:function(salary)&#123;return salary*4&#125;, &quot;A&quot;:function(salary)&#123;return salary*5&#125;, &quot;B&quot;:function(salary)&#123;return salary*6&#125;&#125;;var calculate=function(level,salary)&#123; return stratgies[level](salary);&#125;calculate(&quot;A&quot;,4000);20000 示例利用策略模式将表单提交重构12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;post&quot;&gt; 用户名:&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt; 密码:&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt; 手机号:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var registerForm = document.getElementById(&apos;registerForm&apos;); registerForm.onsubmit=function()&#123; if(registerForm.userName.value===&quot;&quot;)&#123; alert(&apos;用户名不能为空&apos;) return false; &#125; if(registerForm.password.value==&quot;&quot;)&#123; alert(&apos;密码不能为空&apos;); return false; &#125; if(!/^1[3|5|8][0-9]&#123;9&#125;$/.test(registerForm.phoneNumber.value))&#123; alert(&apos;手机号码不对&apos;); return false; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 重构后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form id=&quot;registerForm&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 手机号:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; //***********************************策略对象*************************************************** var strategies=&#123; isEmpty:function(value,errorMsg)&#123; if(value==&quot;&quot;)&#123; return errorMsg; &#125; &#125;, isMobile:function(value,errorMsg)&#123; if(!/1[3|5|8][0-9]&#123;9&#125;/.test(value))&#123; return errorMsg; &#125; &#125; &#125; //**********************************Validator类，作为context,负责接收用户的请求并委托给strategy对象************** var validator=function()&#123; this.cache=[]; &#125; validator.prototype.add=function(dom,rule,errorMsg)&#123; var self=this; var arr=[]; this.cache.push(function()&#123; arr.unshift(dom.value); arr.push(errorMsg); return strategies[rule].apply(dom,arr); &#125;) &#125;; validator.prototype.start=function()&#123; for(var i=0,validatorFunc;validatorFunc=this.cache[i++];)&#123; var msg=validatorFunc(); if(msg)&#123; return msg; &#125; &#125; &#125; //**************************客户调用代码******************************************** var registerForm = document.getElementById(&apos;registerForm&apos;); var validataFunc=function() &#123; var validator=new validator(); validator.add(registerForm.userName,&apos;isEmpty&apos;,&apos;用户名不能为空&apos;); validator.add(registerForm.phoneNumber,&apos;isMobile&apos;,&apos;手机号码格式不正确&apos;); var errorMsg=validator.start(); return errorMsg; &#125; registerForm.onsubmit=function()&#123; var errorMsg=validataFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式基础(1)]]></title>
    <url>%2F2017%2F06%2F25%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 封装 1.封装数据：Js中并没有提供private,public,protected等关键字来提供访问权限，只能后依赖变量的作用域特性，而且只能模拟出public和private两种数据封装特性。除了ES6中的let属性，一般可以通过函数来创建作用域。 2.封装实现：封装使得对象内部的变化对外是透明的，其他对象不关心对象内部的实现。封装使得对象之间的耦合变松散，对象之间只通过api接口通信。 3.封装的作用：把系统中稳定不变的部分和容易变化的部分分离开，在系统演变过程中，只需替换那些容易变化的部分。 二. 原型模式和基于原型继承的js对象系统 js中不存在类的概念，对象也并非从类中创建出来，所有的js对象都是从某个对象上克隆出来的。如果对象A是由对象B克隆出来的，则成B为A的原型。 原型编程的规则: 1.所有数据都是对象。 事实上，js中的根对象是Object.prototype对象，所有的对象都是从他克隆出来的。Object.prototype的原型是null。123var obj=&#123;&#125;;console.log(Object.getPrototypeOf(obj)===Object.prototype);VM217:2 true 2.要得到一个对象，不是通过实例化类，而是找到一个对象作为他的原型 js中的函数既可以作为普通函数被调用，可以作为构造器函数被调用，当用new运算符来调用函数时，此时函数是一个构造器。用运算符来创建对象的过程中，实际上也是先克隆Object.prototype对象，再进行一些额外的其他操作。 3.对象会记住它的原型 对象会记住它的构造器原型12345678910var a= new Object();console.log(a.__proto__===Object.prototype);VM353:2 truefunction haha()&#123;return &apos;hahha&apos;&#125;;var a = new haha();console.log(a.__proto__===haha.prototype);VM507:5 true 4.如果对象无法响应某个请求，它会把这个请求委托给它自己的原型 这规则是原型继承的精髓所在，当一个对象无法响应某个请求的时候，会把这个请求顺的原型链传递下去。 虽然js中的对象最初都是由Object.prototype对象克隆出来的，但是对象构造器的原型并不局限于Object.prototype，也可以有选择性的把对象a的构造器原型指向对象b,从而达到继承的效果。12345678910111213var a=function()&#123;&#125;var A=new a();var obj=&#123;name:&apos;haha&apos;&#125;;a.prototype=obj;console.log(A.name);VM658:5 var a=function()&#123;&#125;var obj=&#123;name:&apos;haha&apos;&#125;;a.prototype=obj;var A=new a();console.log(A.name);VM659:6 haha 三. this、call、apply的作用 thisjs中的this总是指向一个对象，具体指向哪个对象，是在运行时基于函数的执行环境而动态绑定的，而非函数声明时的环境。 this的指向1.作为对象的方法调用 当函数作为对象的方法被调用时，this指向该对象。123var obj =&#123;a:1,getA:function()&#123;console.log(this==obj)&#125;&#125;;obj.getA();VM200:1 true 2.作为普通函数调用123456789var obj =&#123;a:1,getA:function()&#123;console.log(this==obj)&#125;&#125;;var getB=obj.getA;getB();VM229:1 falsevar obj =&#123;a:1,getA:function()&#123;console.log(this)&#125;&#125;;var getB=obj.getA;getB();VM236:1 Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; 当函数不作为对象的属性被调用时，也就是常说的普通函数方式，此时的this总是指向全局对象 3.构造器调用12345var a =function()&#123;this.name = &apos;haha&apos;&#125;;var b = new a;console.log(b.name);VM209:4 haha 当用new调用函数时，该函数会返回一个对象，通常情况下，构造器里面的this指向返回的这个对象 但是，如果构造器显示的返回一个object类型的对象，则此次运算结果返回这个显示对象1234567var a =function()&#123;this.name = &apos;haha&apos;;return &#123;name:&apos;hehe&apos;&#125;&#125;var b = new a();console.log(b.name);VM308:6 hehe 4.Funcition..prototype.call和Function.prototype.apply调用。 与普通函数相比，call()和apply()方法可以动态的改变传入函数的this。12345var obj1=&#123;name:&apos;haha&apos;,getName:function()&#123;return this.name&#125;&#125;;var obj2=&#123;name:&apos;heihei&apos;&#125;;console.log(obj1.getName.apply(obj2));console.log(obj1.getName.apply(obj2));VM500:3 heihei apply &amp;&amp; callapply()与call()方法唯一不同处在于传入参数的形式不同。 apply()接受两个参数，第一个参数是传递给这个函数用来绑定函数内部this的值，第二个参数可以数组或者类数组（传递给这个函数的所有参数），apply()方法把这个数组中的元素作为参数传递给被调用的函数。 call()方法接受的参数数量不固定，与apply()相同的是，第一个参数也是参数代表函数体内的this的指向，之后的每一个参数依次被传入函数。123456789101112131415var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.apply(null, [1,2,3]);6var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, [1,2,3]);1,2,3undefinedundefinedvar fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, 1,2,3);6var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, 1,2,4,9);7 如果函数第一个参数指向null,则默认函数体内的this指向默认的宿主对象，在浏览器中是window:123var fun = function(a,b,c)&#123;console.log(this)&#125;;fun.call(null, 1,2,4,9);Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; apply()与call()用途1.改变this的指向1234var getName=function()&#123;return this.name;&#125;var obj1=&#123;name:&apos;hahh&apos;&#125;;getName.call(obj1);&quot;hahh&quot; 将函数getName的this指向对象obj1; 2.使用其他对象的方法 1.借用构造函数：123456var A=function(name)&#123;this.name=name&#125;;var B=function()&#123;A.apply(this,arguments);&#125;B.prototype.getName=function()&#123;return this.name;&#125;;var b=new B(&apos;heihei&apos;);console.log(b.getName());heihei 2.对于函数的参数列表arguments(一个类数组对象)，并非一个真正的数组。可以通过apply()或者call()方法来增加所需用到的方法。1234567891011121314151617(function()&#123;Array.prototype.push.apply(arguments,[3]);console.log(arguments);&#125;)(1,2);[1, 2, 3, callee: function, Symbol(Symbol.iterator): function](function()&#123;Array.prototype.push.call(arguments,3);console.log(arguments);&#125;)(1,2);[1, 2, 3, callee: function, Symbol(Symbol.iterator): function]var a=&#123;&#125;;Array.prototype.push.call(a,&apos;haha&apos;);console.log(a);Object &#123;0: &quot;haha&quot;, length: 1&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>