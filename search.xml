<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F04%2F%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80(2)%2F</url>
    <content type="text"><![CDATA[title: 原生js知识date: 2017-07-09tags: 基本知识 categories: 基本知识#Object对象的一些属性和方法 constructor属性指定创建一个对象的函数。 constructor属性是每个具有原型的对象的原型成员。 这包括除 Global 和 Math 对象之外的所有内部 JavaScript 对象。 constructor 属性包含了对某种函数的引用，此种函数构造了特定对象的实例。1234567function MyObj() &#123; this.number = 1;&#125;var y = new MyObj;if (y.constructor == MyObj) console.log(true)输出true prototype属性为对象的类返回原型的引用 用 prototype 属性为对象的类提供一组基本功能。 对象的新的实例“继承”了赋予该对象的原型的行为。 12345678910111213function array_max()&#123; var i, max = this[0]; for (i = 1; i &lt; this.length; i++) &#123; if (max &lt; this[i]) max = this[i]; &#125; return max;&#125;Array.prototype.max = array_max;var myArray = new Array(7, 1, 3, 11, 25, 9);document.write(myArray.max() 所有内部 JavaScript 对象都有一个只读的 prototype 属性。 可将属性和方法添加到原型中，但不能为对象分配其他原型。 但是，可以向用户定义的对象分配新的原型 Object.assign();将来自一个或多个源对象中的值复制到一个目标对象。Object.assign(target, …sources)12345678var first = &#123; name: &quot;Bob&quot; &#125;;var last = &#123; lastName: &quot;Smith&quot; &#125;;var person = Object.assign(first, last);console.log(person);// Output:// &#123; name: &quot;Bob&quot;, lastName: &quot;Smith&quot; &#125; 12var obj = &#123; person: &quot;Bob Smith&quot;&#125;;var clone = Object.assign(&#123;&#125;, obj); Object.keys()方法在实际开发中，我们有时需要知道对象的所有属性，原生js给我们提供了一个很好的方法：Object.keys()，该方法返回一个数组123456789var obj = &#123;&apos;a&apos;:&apos;123&apos;,&apos;b&apos;:&apos;345&apos;&#125;;console.log(Object.keys(obj)); //[&apos;a&apos;,&apos;b&apos;]var obj1 = &#123; 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot;&#125;;console.log(Object.keys(obj1)); // console: [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]var obj2 = Object.create(&#123;&#125;, &#123; getFoo : &#123; value : function () &#123; return this.foo &#125; &#125; &#125;);obj2.foo = 1;console.log(Object.keys(obj2)); // console: [&quot;foo&quot;] Object.defineProperty()将属性添加到对象，或修改现有属性的特性。返回修改属性后的对象 Object.defineProperty(object, propertyname, descriptor)，其中object为要在其上添加或修改属性的对象。 这可能是一个本机JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。propertyname是一个包含属性名称的字符串。descriptor是属性描述符，它可以针对数据属性或访问器属性。 示例1:添加数据属性12345678var obj=&#123;&#125;;Object.defineProperty(obj,&quot;haha&quot;,&#123; value:1, writable:true, configurable:true, enumerable:true&#125;)console.log(obj.haha); 添加访问器属性1234567891011121314var obj=&#123;&#125;;Object.defineProperty(obj,&quot;haha&quot;,&#123; set:function(x)&#123; this.hehe = x; &#125;, get:function()&#123; return this.hehe &#125;, configurable:true, enumerable:true&#125;)obj.haha=30;console.log(obj.hehe);结果： 30 Object.create()Object.create(prototype, descriptors)创建一个具有指定原型且可选择性地包含指定属性的对象。prototype是要用作原型的对象。可以为null。 descriptors是包含一个或多个属性描述符的 JavaScript对象。“数据属性”是可获取且可设置值的属性。数据属性描述符包含 value 特性，以及 writable、enumerable 和 configurable 特性。如果未指定最后三个特性，则它们默认为 false。只要检索或设置该值，“访问器属性”就会调用用户提供的函数。访问器属性描述符包含set特性和/或 get 特性。 示例12345678910111213141516171819var newObj = Object.create(null, &#123; size: &#123; value: &quot;large&quot;, enumerable: true &#125;, shape: &#123; value: &quot;round&quot;, enumerable: true &#125; &#125;);document.write(newObj.size + &quot;&lt;br/&gt;&quot;);document.write(newObj.shape + &quot;&lt;br/&gt;&quot;);document.write(Object.getPrototypeOf(newObj));// Output:// large// round// null Object.getOwnPropertyDescriptor(object, propertyname)object是指包含属性的对象，propertyname是属性名称。获取指定对象的自身属性描述符。自身属性描述符是指直接在对象上定义（而非从对象的原型继承）的描述符。 123456789101112var obj=&#123;&#125;;obj.haha=&quot;hello&quot;;var discriptor=Object.getOwnPropertyDescriptor(obj,&quot;haha&quot;);discriptor.writable = false;for(var props in discriptor)&#123; console.log(props+&quot; &quot;+discriptor[props])&#125;输出： value hello writable false enumerable true configurable true]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（7）]]></title>
    <url>%2F2017%2F07%2F10%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(7)%2F</url>
    <content type="text"><![CDATA[手写一个递归函数（考察arguments.callee，以及arguments的解释）arguments.callee表示当前的函数,传入的参数从arguments[0]开始以此类推12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function create()&#123; return function(n)&#123; if(n&lt;=1)&#123; return 1; &#125;else return n*arguments.callee(n-1) &#125;&#125;console.log(create()(4))结果： 24``` callee属性的初始值就是正在被执行的function对象。callee属性是arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或确保函数的封装性，需要注意的是callee拥有length属性，arguments.length是实参长度，arguments.callee.length是形参长度，由此能够判断调用时形参长度是否和实参长度一致## web缓存判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷### Web缓存的类型**1.数据库数据缓存**Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached等。 服务器端缓存。**2.代理服务器缓存**代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等，这里不再详述。**3.CDN缓存**CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。 **4.浏览器端缓存**浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。 **5.Web应用层缓存**应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。### 浏览器缓存页面的缓存状态是由header决定的，header的参数有四种：（1）cache-control 和 max-agecache-control 大概是最广为人知的控制缓存的 Headers 了，这也是最简单的缓存控制策略，即浏览器通过最大生存时间来判断资源的缓存是否有效。如图所见，来自服务器端的`response headers`的`Headers`中有`cache-control: max-age=3600`，这就是告诉浏览器这个资源的生存时间，在这个时间以内，浏览器不需要向服务器端再做任何确认，直接使用即可（2）Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，`Expires=max-age + 请求时间`，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。（3）Last-modified 服务器端文件的最后修改时间，需要和`cache-control`共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送`If-Modified-Since`报头，询问`Last-Modified`时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。(4)If-None-Match/ETag采用的是`ETag`来判断缓存是否有效，服务器端会在`response headers`中返回 ETag（文件的 hash），而当资源改变时`ETag`也会发生改变。浏览器在发起请求时在`If-None-Match`字段携带缓存的`ETag`，服务器接到请求后如果一致（即资源没有修改），则返回`304 Not Modified`，否则返回新的资源（200）**H5时代的缓存**本地存储localstorage的作用主要使Web页面能够通过浏览器提供的set/get接口，存储一些自定义的信息到本地硬盘，并且在单次访问或以后的访问过程中随时获取或修改。LocalStorage是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；LocalStorage是以页面域名划分的，如果有多个等价域名之间的LocalStorage不互通，则会造成缓存多份浪费## cookie工作原理当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。但在 localStorage 出现之前，cookie被滥用当做了存储工具。什么数据都放在cookie中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然cookie标准还是做了一些限制的：每个域名下的cookie 的大小最大为4KB，每个域名下的cookie数量最多为20个。每个cookie除了name名称和value值这两个属性以外，还有四个属性。这些属性是： expires过期时间、 path路径、 domain域、以及 secure安全。### 跨域请求中 cookie例如让位于a.sodao.com的服务器能够读取b.sodao.com设置的cookie值。方法如下：b.sodao.com的页面创建的cookie把它的path属性设置为&quot;/&quot;，把domain属性设置成**&quot;.sodao.com&quot;**，那么所有位于b.sodao.com的网页和所有位于a.sodao.com的网页，以及位于sodao.com域的其他服务器上的网页都可以访问这个cookie。## jsonp跨域实现 //添加标签的方法 function addScriptTag(url){ var script = document.createElement(‘script’); script.setAttribute(“type”,”text/javascript”); script.src = url; document.body.appendChild(script); } //自定义的回调函数result function result(data) { //我们就简单的获取apple搜索结果的第一条记录中url数据 alert(data.responseData.results[0].unescapedUrl); } //进行jsonp调用 addScriptTag(&quot;http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result&quot;); } ```这是Google的ajax搜索接口：http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=? q=?这个问号是表示你要搜索的内容，最重要的是第二个callback=?这个是正如其名表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的json数据传入这个方法完成回调。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（5）]]></title>
    <url>%2F2017%2F07%2F07%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(5)%2F</url>
    <content type="text"><![CDATA[flex布局基本概念：采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 容器的属性flex-direction属性决定主轴的方向（即项目的排列方向）：123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行: 123.box&#123; flex-wrap: nowrap(不换行) | wrap(换行在第一行下方) | wrap-reverse(换行在第一行上方);&#125; flex-flow justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start(主轴起点) | flex-end | center | space-between(两端对齐，项目之间的间隔都相等) | space-around(每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍);&#125; align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start（交叉轴起点） | flex-end | center | baseline | stretch(如果项目未设置高度或设为auto，将占满整个容器的高度);&#125; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start（与交叉轴起点对齐）| flex-end | center | space-between | space-around | stretch;&#125; 项目的属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。数字越大所占比例越大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 示例1 单项目123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box&#123; width:500px; height:500px; border:1px solid blue; display:flex; justify-content: flex-end;/*center 居中。定义项目在主轴上的对齐方式*/ align-items:flex-end; /*定义在交叉轴上的位置*/ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;haha&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 示例2 多项目123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box&#123; width:500px; height:500px; border:1px solid blue; display:flex; flex-wrap: wrap; align-content: space-between; &#125; .column&#123; display: flex; flex-basis:100%; justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;haha&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;hehe&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;hihi&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;lala&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 示例3 网格布局flex 实现圣杯三栏分布 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header&#123; border:1px solid red; &#125; footer &#123; border:1px solid green; &#125; .HolyGrail-body &#123; display: flex; flex: 1; &#125; .HolyGrail-content &#123; flex: 0 0 33.33%; border:1px solid blue; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; flex: 0 0 33.33%; border:1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;header&gt;这里是标题栏&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;div class=&quot;HolyGrail-content&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;HolyGrail-nav&quot;&gt;导航栏&lt;/div&gt; &lt;div class=&quot;HolyGrail-ads&quot;&gt;...&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;这里是角标&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 流式布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body &#123; display: flex; min-height: 100vh; flex-direction: column; &#125; header&#123; border:1px solid red; &#125; footer &#123; border:1px solid green; &#125; .HolyGrail-body &#123; display: flex; flex-wrap:wrap; flex: 1; &#125; .HolyGrail-content &#123; box-sizing: border-box; flex: 0 0 33.33%; border:1px solid blue; height:200px; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ box-sizing: border-box; flex: 0 0 33.33%; border:1px solid blue; height:200px; &#125; .HolyGrail-last&#123; border:1px solid green; flex:0 0 30%; height:200px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;header&gt;这里是标题栏&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;div class=&quot;HolyGrail-content&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;HolyGrail-nav&quot;&gt;导航栏&lt;/div&gt; &lt;div class=&quot;HolyGrail-ads&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;HolyGrail-last&quot;&gt;...&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;这里是角标&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 水平垂直居中在不知道容器大小时可以使用1和2方法11234.parent&#123; display:flex; justify-content:center;&#125; 方法2123456789101112131415161718192021&lt;head&gt; &lt;style&gt; .parent&#123; position:relative; width:400px; height:400px; border:1px solid red; &#125; .child&#123; position: absolute; top:200px; left:200px; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;hahjkldsj;flaha&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（6）]]></title>
    <url>%2F2017%2F07%2F05%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(6)%2F</url>
    <content type="text"><![CDATA[伪类和伪元素w3c中的定义：CSS中伪类用于向某些选择器添加特殊的效果。CSS中伪元素用于将特殊的效果添加到某些选择器。 伪类种类有：:active : 将样式添加到被激活的元素:focus :将样式添加到被选中的元素:hover：将样式添加到鼠标浮动的元素上:link：将样式添加到未被访问过的链接:visited,:first-child,:lang; 伪元素种类：：before : 在某元素之前插入某些内容：after : 在某元素之后插入某些内容 优先级样式的优先级：内联样式(在元素中间的style)&gt;内部样式(&lt;style&gt;&lt;/style&gt;)&gt;外部样式（link标签引入） 选择器的优先级： 内联样式的优先级&gt;ID选择器&gt;伪类选择器(:visited,:acitive)&gt;属性选择器&gt;类选择器&gt;类型选择器&gt;通用选择器（*） 注意：当 !important 规则被应用在一个样式声明中时,该样式声明会覆盖CSS中任何其他的声明, 无论它处在声明列表中的哪里 盒子模型和box-sizing盒子模型：content+padding+border+margin box-sizing属性有两个值：content-box和border-box;当属性值为content-box时，维持其原有盒子模型的结构。 当属性值为border-box时，其设置的宽度为content-width+padding+border。可以通过告诉浏览器该元素中的padding和border来确定content的宽，高。 具体示例为：123456.element&#123; box-sizing:border-box; width:200px; padding:10px border:5px&#125; 则此时content-width为170px,而不是盒子模型的230px。 响应式布局：理论上，响应式界面能够适应不同的设备。简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。 这个概念是为解决移动互联网浏览而诞生的。 描述响应式界面最著名的一句话就是“Content is like water”，翻译成中文便是“如果将屏幕看作容器，那么内容就像水一样”。 性能优化的方法（1） 减少http请求次数 （2） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 （3） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 （4） 当需要设置的样式很多时设置className而不是直接操作style 常见会造成内存泄漏的操作内存泄漏指任何对象在不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 （1）setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 （2）闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 不用框架实现三级菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0; padding:0; &#125; li&#123; width:100px; height:30px; border:1px solid red; list-style:none; &#125; //利用相对定位和绝对定位解决位置之间的影响 li&#123; position:relative; &#125; li a&#123; display: block; text-decoration: none; height:30px; line-height: 30px; width:100px; text-align:center; &#125; .level1&#123; position:absolute; top:0; left:100px; &#125; .level2&#123; position: absolute; top:0; left:100px; &#125; .level1&#123; display: none; &#125; .leveel2&#123; display: none; &#125; #nav&gt;li:hover&gt;ul&#123; display: block; &#125; //1.父子元素之间的嵌套 //利用伪类元素实现隐藏和显示 #nav&gt;li:hover&gt;ul&gt;li&gt;ul&#123; display: none; &#125; #nav&gt;li&gt;ul&gt;li:hover&gt;ul&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页面&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt; &lt;ul class=&quot;level1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我们的故事&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;故事1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;故事2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;故事3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我们的团队&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 一个table，点击按钮，实现某一列的刷新1、获取表格的dom节点 2、通过rows和cells定位td单元格 3、通过修改innerHTML123456789101112&lt;body&gt;&lt;table id=&apos;test&apos;&gt; //定义一个table&lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;script&gt; var tb = document.getElementById(&apos;test&apos;);//获取表格的dom节点 var td = tb.rows[0].cells[0];//获取0行0列的td单元格 td.innerHTML = &apos;222&apos;;//动态修改表格的内容为222&lt;/script&gt;&lt;/body&gt; 循环遍历tr以及td，找到你要修改的td，然后修改它的内容给个例子：123for(var i=0;i&lt;table.rows.length;i++)for(var j=0;j&lt;rows.cells.length;i++)table.rows[i].cells[j].innerHTML=&quot;新的内容&quot;; 事件的绑定和移除对于事件的绑定的方法有多种多样，但是在解除绑定事件的时候，就要注意使用的是那种绑定事件的方法，因为不同的绑定方法所对应的解除事件是不同的。 方式1：绑定事件：对象.事件=事件处理函数。解除事件： 对象.事件=null (此方法就是函数的覆盖)1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var btn1= document.getElementById(&quot;btn1&quot;); var btn2 = document.getElementById(&quot;btn2&quot;); btn1.onclick = function()&#123; alert(&quot;btn1事件绑定成功！&quot;); &#125; btn2.onclick = function()&#123; btn1.onclick = null; alert(&quot;btn1所绑定的事件已经被移除！&quot;); &#125;&lt;/script&gt; 方式2：使用 attachEvent 、detachEvent、addEventListener 与 removeEventListener 事件绑定——attachEvent ，addEventListener 使用 attachEvent 和 addEventListenter 的好处就是，可以多次的进行事件的绑定，不向原始的方法那样，前面绑定的事件将会被后面的绑定的事件所覆盖，最后只能执行后面所绑定的函数。 123456789var btn1= document.getElementById(&quot;btn1&quot;); var btn2= document.getElementById(&quot;btn2&quot;); btn1.addEventListener(&quot;click&quot;,function()&#123; console.log(1); &#125;) btn1.addEventListener(&quot;click&quot;,function()&#123; console.log(2); &#125;)结果为：1,2 说明：1) addEventListener 是先绑定先执行，它将按顺序执行我绑定的事件。 2) addEventListener 的第三个参数：布尔值参数是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序 3）attachEvent 只能兼容 IE7，IE8；绑定的事件前面要加“on” 事件移除用removeEventListener (1)在removeEventListener 传入的参数与 addEventListener 传入的参数要一致，看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的与第一个是完全不同的函数。 (2)因为移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除。 (3)在公用函数体存在参数的情况下，不能将带参数的函数体传给 addEventListener 和 romoveEventListener。 正确示例为:123456789&lt;script type=&quot;text/javascript&quot;&gt; var fun = function(e)&#123; e.preventDefault();//阻止事件目标的默认动作 alert(1); &#125; var btn1= document.getElementById(&quot;btn1&quot;); btn1.addEventListener(&apos;click&apos;,fun,false);//事件冒泡阶段 btn1.removeEventListener(&apos;click&apos;,fun,false);&lt;/script&gt; 事件冒泡和事件捕获冒泡捕获过程1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;outA&quot; style=&quot;width:400px; height:400px; background:#ff0000;position:relative;&quot;&gt; &lt;div id=&quot;outB&quot; style=&quot;height:200; background:#0000ff;top:100px;position:relative;&quot;&gt; &lt;div id=&quot;outC&quot; style=&quot;height:100px; background:#00ff00;top:50px;position:relative;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var outA = document.getElementById(&quot;outA&quot;); var outB = document.getElementById(&quot;outB&quot;); var outC = document.getElementById(&quot;outC&quot;); // 使用事件冒泡 outA.addEventListener(&apos;click&apos;,function()&#123;console.log(1);&#125;,true); outB.addEventListener(&apos;click&apos;,function()&#123;console.log(2);&#125;,true); outC.addEventListener(&apos;click&apos;,function()&#123;console.log(3);&#125;,true); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; addEventListener第三个参数为true侦听事件为捕获阶段，当点击outc时输出为123，为false时，侦听事件以冒泡进行。点击outc输出为321。 Dom事件流DOM事件流：将事件分为三个阶段：捕获阶段、目标阶段、冒泡阶段。先调用捕获阶段的处理函数，其次调用目标阶段的处理函数，最后调用冒泡阶段的处理函数。 在outC（目标事件上）上注册的事件处理函数，属于DOM事件流中的目标阶段。目标阶段函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。 1234outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target1&quot;);&#125;,false);outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target2&quot;);&#125;,true);outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target3&quot;);&#125;,true);outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target4&quot;);&#125;,false); 所以上述代码按顺序进行执行。 阻止事件冒泡和捕获12345678910outC.addEventListener(&apos;click&apos;,function(event)&#123;alert(&quot;target2&quot;);event.stopPropagation()&#125;,true); outC.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;target1&quot;);&#125;,true); // 事件冒泡 outA.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;bubble1&quot;);&#125;,false); outB.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;bubble2&quot;);&#125;,false); // 事件捕获 outA.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;capture1&quot;);&#125;,true); outB.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;capture2&quot;)&#125;,true); 阻值事件冒泡方法：function(event){event.stopPropagation()} js事件处理程序有哪几种1、HTML事件处理程序1234567&lt;input id=&quot;btn1&quot; value=&quot;按钮&quot; type=&quot;button&quot; onclick=&quot;showmsg();&quot;&gt;&lt;script&gt; function showmsg()&#123; alert(&quot;HTML添加事件处理&quot;); &#125;&lt;/script&gt; 即我们直接在HTML代码中添加事件处理程序，事件处理是直接嵌套在元素里头的，这样有一个毛病：就是html代码和js的耦合性太强，如果哪一天我想要改变js中showmsg，那么我不但要再js中修改，我还需要到html中修改。 2、DOM0级事件处理程序 即为指定对象添加事件处理，看下面的一段代码12345678&lt;input id=&quot;btn2&quot; value=&quot;按钮&quot; type=&quot;button&quot;&gt;&lt;script&gt; var btn2= document.getElementById(&quot;btn2&quot;); btn2.onclick=function()&#123; alert(&quot;DOM0级添加事件处理&quot;); &#125; btn.onclick=null;//如果想要删除btn2的点击事件，将其置为null即可&lt;/script&gt; 3、DOM2级事件处理程序 但是主要涉及到两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。它们都接收三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（是否在捕获阶段处理事件），看下面的一段代码 12345input id=&quot;btn3&quot; value=&quot;按钮&quot; type=&quot;button&quot;&gt;&lt;script&gt; var btn3=document.getElementById(&quot;btn3&quot;); btn3.addEventListener(&quot;click&quot;,showmsg,false);//这里我们把最后一个值置为false，即不在捕获阶段处理，一般来说冒泡处理在各浏览器中兼容性较好&lt;/script&gt; DOM0和DOM2之间的区别 区别：如果定义了两个dom0级事件，dom0级事件会覆盖 dom2不会覆盖，会依次执行 dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖 DOM api的API的扩展querySelector方法1234567var body = document.querySelector(&quot;body&quot;);//取得ID 为&quot;myDiv&quot;的元素var myDiv = document.querySelector(&quot;#myDiv&quot;);//取得类为&quot;selected&quot;的第一个元素var selected = document.querySelector(&quot;.selected&quot;);//取得类为&quot;button&quot;的第一个图像元素var img = document.body.querySelector(&quot;img.button&quot;) querySelectorAll()方法123456//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于getElementsByTagName(&quot;em&quot;)）var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);//取得类为&quot;selected&quot;的所有元素var selecteds = document.querySelectorAll(&quot;.selected&quot;);//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(&quot;p strong&quot;);]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（4）]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(4)%2F</url>
    <content type="text"><![CDATA[节点修改API1.appendChild parent.appendChild(child); 2.insertBefore parentNode.insertBefore(newNode, refNode); 3. removeChild var deletedChild = parent.removeChild(childnode);返回删除的节点 4.replaceChild parent.replaceChild(newchild,oldchild); 父子关系APIparentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，DocumentDocumentFragment； childNodes：返回一个实时的NodeList，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等； firstChild：返回第一个子节点，不存在返回null，与之相对应的还有一个firstElementChild； lastChild：返回最后一个子节点，不存在返回null，与之相对应的还有一个lastElementChild； 兄弟关系previousSibling：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。 nextSibling：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下 元素属性型API设置属性setAttribute,element.setAttribute(name,value);1document.getElementsByTagName(&quot;INPUT&quot;)[0].setAttribute(&quot;type&quot;,&quot;button&quot;); 获得属性getAttribute, var value=getAttribute(“id”);获取id的值 ## null和undefined的区别？ null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 http状态码 200 OK 正常返回信息 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） 线程和进程的区别一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 js运行机制详解js是单线程的与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下： （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（3）]]></title>
    <url>%2F2017%2F07%2F02%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95(3)%2F</url>
    <content type="text"><![CDATA[## 判断数据类型方法 1.typeof(变量)。typeof用以获取一个变量的类型，typeof一般只能返回如下几个结果：number,boolean,string,function,object,undefined。我们可以使用typeof来获取一个变量是否存在。 12345678typeof(null)&quot;object&quot;typeof(undefined)&quot;undefined&quot;var a =&#123;&#125;;console.log(a instanceof Object) 2.根据constructor来判断。 123var a=&#123;&#125;,b=[];console.log(a.constructor==Object&amp;&amp;b.constructor==Array)结果：true 3.根据toString()方法来判断，是最通用的方法。 1234567var a=&quot;&quot;;console.log(Object.prototype.toString.call(a))结果： [object String]var a=&#123;&#125;,b=[];console.log(Object.prototype.toString.call(b))结果： [object Array] 正则方法使用test:pattern.test(string); exec: pattern.exec(string); 123var reg=/&lt;(\w+)(&gt;)/g;reg.exec(&quot;&lt;hksdjfttekj&gt;&quot;) [&quot;&lt;hksdjfttekj&gt;&quot;, &quot;hksdjfttekj&quot;, &quot;&gt;&quot;] exec返回匹配到的数组，第一个参数为匹配项，第二个参数为第一个捕获项，第三个参数为第二个捕获项 match: str.match(pattern)也是返回一个匹配的数组 replace: 示例11234var str = &quot;Apples are round, and apples are juicy.&quot;;var reg=/apples/ig;console.log(str.replace(reg,&apos;organce&apos;))结果 organce are round, and organce are juicy. 示例2当使用replace方法匹配时，假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么 $n 表示插入第 n 个括号匹配的字符串12345678910var re = /(\w+)\s(\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr);var str=&quot;bat hat cat &quot;;var reg=/((t))/ig;console.log(str.replace(reg,&quot;$1$2&quot;)) batt hatt catt 常用正则表达式总结验证数字：^[0-9]*$ 验证n位的数字：^\d{n}$ 验证至少n位数字：^\d{n,}$ 验证m-n位的数字：^\d{m,n}$ 验证零和非零开头的数字：^(0|[1-9][0-9]*)$ 验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 验证由数字、26个英文字母或者下划线组成的字符串：^\w+$ 验证用户密码:^[a-zA-Z]\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线 验证Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+))(.(w+(-w+)))(?S)?$ CDNCDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 跨域资源共享 CORS 详解需要浏览器和服务器同时支持。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求: （1) 请求方法是以下三种方法之一：HEAD，GET，POST （2）HTTP的头信息不超出以下几种字段：Accept；Accept-Language；Content-Language；Last-Event-ID；Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain；凡是不同时满足上面两个条件，就属于非简单请求。 简单请求 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123GET /cors HTTP/1.1；Origin: http://api.bob.com；Host: api.alice.com；Accept-Language: en-US；Connection: keep-alive；User-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。123456789var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。123456789OPTIONS /cors HTTP/1.1Origin: http://api.bob.com； Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.com； Accept-Language: en-USConnection: keep-alive； User-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 CORS与JSONP的使用目的相同，但是比JSONP更强大。 localStorage判断浏览器是否支持 1234if(window.localStorage)&#123; console.log(true)&#125;结果：true 可以通过setItem和getItem方法设置localStorage1234localStorage.setItem(&quot;haha&quot;,&quot;hello&quot;)console.log(localStorage.getItem(&quot;haha&quot;))hello Cookie、sessionStorage 和 localStroragesessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。 sessionStorage 、localStorage 和 cookie 之间的区别： 共同点：都是保存在浏览器端，且同源的。 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 html5（websocket等）1 新的Doctype ：尽管使用&lt;!DOCTYPE html&gt;，即使浏览器不懂这句话也会按照标准模式去渲染 2 去掉link和script标签里面的type属性 3 Local Storage ：使用Local Storage可以永久存储大的数据片段在客户端（除非主动删除），目前大部分浏览器已经支持，在使用之前可以检测一下window.localStorage是否存在 4 语义化的header和footer 5 video audio的支持 Label forfor 属性规定 label 与哪个表单元素绑定。 隐式和显式的联系：标记通常以下面两种方式中的一种来和表单控件相联系：将表单控件作为标记标签的内容(放在标签之间)，这样的就是隐式形式;或者为 标签下的 for 属性命名一个目标表单的id，这样就是显式形式。 清除浮动1.在需要清除浮动的父级元素内部的所有浮动元素后添加这样一个标签清除浮动clear:both; 2.使用该方法是只需在需要清除浮动的元素中定义CSS属性：overflow:auto，即可！”zoom:1″用于兼容IE6,也可以用width:100%。不过使用overflow的时候，可能会对页面表现带来影响，而且这种影响是不确定的，你最好是能在多个浏览器上测试你的页面 3.使用after伪对象清除浮动1234567.container:after&#123; display: block; content:&quot;&quot;; height:0; visibility:hidden; clear:both; &#125; 浏览器内核浏览器：IE，Chrome，FireFox，Safari，Opera。 内核：Trident，Gecko，Presto，Webkit。 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和js引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 dom基本操作创建新节点 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入appendChild() removeChild() replaceChild() insertBefore(newNode,nowNode) //在已有的子节点前插入一个新的子节点 查找 getElementsByTagName() //通过标签名称 getElementById() //通过元素Id，唯一性 getElementsByClassName()]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试（2）]]></title>
    <url>%2F2017%2F07%2F01%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、从输入网址到显示网页的过程分析1、应用层DNS解析域名：客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。 2、浏览器与服务器建立TCP连接（默认端口80）(详细点可以说下三次握手的过程) 3、应用层客户端发送HTTP请求。 4、服务器响应请求：查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码（200-300，成功；304使用缓存）。 5、服务器返回相应文件给浏览器。 6、Tcp连接释放(可以说下四次挥手的过程)。 7、浏览器对HTML文件进行解析构建DOM树 ，构建渲染树 ，js根据DomAPI操作执行绑定事件等，页面显示完成。 float属性值为:left,right,none;元素会分别左移，右移，直到触碰到容器为止。当块级元素没有设置宽度，但是却设置了float属性(right,left)时，元素的宽度随内容的变化而变化。 清除浮动方法：clear:both;同时设置width:100%(或固定宽度)+overflow:hidden; positionpostion可拥有三种定位形式：静态定位，相对定位，绝对定位，对应的属性值有四个：分别为static(静态定位),relative(相对定位),absolute(绝对定位),fixed(固定定位)，其中最后两种属于绝对定位。 各类定位特点： 相对定位：相对于自身原有位置偏移，仍然处于标准文档流中。 绝对定位：建立了以包含块为基准的的定位，脱离的标准文档流。当一个元素设置了绝对定位但是没有设置宽度，元素的宽度会随着内容而变化。 脱离文档流的操作有： 绝对定位absolute,固定定位fixed，浮动float。 三栏式布局container的宽度固定并垂直居中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;This is my title&lt;/title&gt; &lt;style&gt; #big-box&#123; border:1px solid blue; width:650px; height:400px;/*块级元素定义宽度，高度*/ margin:0 auto;/*元素水平居中*/ /*margin用法可以有1,2,3,4个参数*/ &#125; #header&#123; /*块级元素不设置宽度时，宽度随着内容的变化而变化*/ padding:auto; border:1px solid blue; margin-top:10px; margin-left:10px; margin-right:10px; &#125; #left&#123; border:1px solid blue; margin-left:10px; height:250px; width:175px; float:left; &#125; #main&#123; border:1px solid blue; height:250px; width:250px; margin:0 auto; /*margin-left:10px;margin-right:10px*/通过这种设置让左右两边距离相同 &#125; #right&#123; border:1px solid blue; margin-right:10px; margin-top:-250px; height:250px; width:175px; float:right; &#125; #footer&#123; margin-top:10px; border:1px solid blue; clear:both; margin-left:10px; margin-right:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;big-box&quot;&gt; &lt;p id = &quot;header&quot;&gt;header header header header header header header header header header&lt;/p&gt; &lt;div id=&quot;left&quot;&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;p&gt;left left left&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;right&quot;&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;p&gt;right right right&lt;/p&gt; &lt;/div&gt; &lt;p id = &quot;footer&quot;&gt;footer footer footerfooter footer footerfooter footer footerfooter footer footerfooter footer&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 两栏布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;This is my title&lt;/title&gt; &lt;style&gt; #big-box&#123; display:block; border:1px solid blue; width:640px; height:410px; margin:auto; &#125; #header&#123;/* padding:auto;*/ border:1px solid blue; margin-top:10px; margin-left:10px; margin-right:10px; &#125; #left&#123; border:1px solid blue; margin-left:10px; width:240px; height:265px; float:left; text-align:center; &#125; #left12&#123; height:125px; border:1px solid blue; margin:5px; &#125; #left1&#123; border:1px solid blue; margin:3px; float:left; height:110px; &#125; #left2&#123; border:1px solid blue; margin-left:auto; margin-top:3px; margin-right:3px; height:110px; width:100px; &#125; #left3&#123; border:1px solid blue; margin:5px; height:125px; &#125; #main&#123; border:1px solid blue; margin-left:auto; margin-right:10px; height:265px; width:370px; &#125; #footer&#123; border:1px solid blue; margin-top:10px; margin-left:10px; margin-right:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;big-box&quot;&gt; &lt;p id = &quot;header&quot;&gt;header header header header header header header header header header&lt;/p&gt; &lt;div id=&quot;left&quot;&gt; &lt;div id=&quot;left12&quot;&gt; &lt;div id=&quot;left1&quot;&gt; &lt;p&gt;left1 left1 left1&lt;/p&gt; &lt;p&gt;left1 left1 left1&lt;/p&gt; &lt;p&gt;left1 left1 left1&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;left2&quot;&gt; &lt;p&gt;left2 left2 &lt;/p&gt; &lt;p&gt;left2 left2 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left3&quot;&gt; &lt;p&gt;left3 left3 left3&lt;/p&gt; &lt;p&gt;left3 left3 left3&lt;/p&gt; &lt;p&gt;left3 left3 left3&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;p&gt;main main main&lt;/p&gt; &lt;/div&gt; &lt;p id=&quot;footer&quot;&gt;footer footer footerfooter footer footerfooter footer footerfooter footer footerfooter footer&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html 注意：页面布局从外往里，熟悉相关属性方法，层层思考。 跨域的实现方式由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。 （1）JSONP这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制（所谓同源是指所请求的主机，域名，协议，端口与当前相同），同时资源加载到页面后会立即执行。具体来说就是本站脚本创建一个元素，地址指向第三方的API网址，形如：&lt;script src=&quot;http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt;并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;})这样浏览器会调用callback函数，并传递解析后json对象作为参数，，客户端即可拿到数据。 12345678910111213141516function json(jsonObj) &#123; //dosomthing&#125;// 调用jsonHandle，传入地址、追加参数，服务器端返回js代码，// 并调用客户端写好的json方法并把json数据传入进来。function jsonHandle(url) &#123; var script = document.createElement(&quot;script&quot;); script.setAttribute(&quot;src&quot;,url); document.body.appendChild(script); // 防止 script 标签冗余 if(oScript) &#123; document.body.removeChild(oScript); &#125;&#125; (2)通过修改document.domain来跨子域 在页面http://www.example.com/a.html 上设置12345678910document.domain = &apos;example.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://example.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;; 同时，在页面http://example.com/b.html上设置`document.domain = ‘a.com’` ## 安全性问题 ###1、SQL注入 ### 所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将(恶意)的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入(恶意)SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 ###2、Xss###Xss表示Cross Site Scripting(跨站脚本攻击)。它与SQL注入攻击类似，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在Xss攻击中，通过插入恶意脚本，实现对用户浏览器的控制。 现代web开发框架如vue.js、react.js等，在设计的时候就考虑了Xss攻击对html插值进行了更进一步的抽象、过滤和转义（转义安全字符），我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。同时，许多基于MVVM框架的SPA（单页应用）不需要刷新URL来控制view，这样大大防止了XSS隐患。 ###3、Csrf### HTTP最常见的响应头如下所示 Allow：服务器支持哪些请求方法（如GET、POST等）； Content-Encoding： 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档 的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面； Content-Length： 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream())发送内容； Content-Type： 表 示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。可在web.xml文件中 配置扩展名和MIME类型的对应关系； Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦； Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。 Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置； Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302； Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的`实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置 Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续 刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是`。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F30%2Fvue(3)%2F</url>
    <content type="text"><![CDATA[Vue基础知识虚拟dom的概念在一个HTML中，DOM节点通常表示如下：1234&lt;ul id=&apos;myId&apos;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt;&lt;ul&gt; DOM 节点也可以表示 JavaScript 中的对象，像这样：1234567Let domNode = &#123; tag: &apos;ul&apos; attributes: &#123; id: &apos;myId&apos; &#125; children: [ // where the LI&apos;s would go ]&#125;; 这就是我们的“虚拟”DOM，更新虚拟节点的开销不大，1domNode.children.push(&apos;&lt;ul&gt;Item 3&lt;/ul&gt;&apos;); 当使用虚拟DOM，而不是直接在代码中调用类似 .getElementById的DOM API方法，操作就会像改变JS对象一样非常的简单省时。所有的操作均在虚拟dom中实现，最后一次性完成dom渲染。 Vue2.0的版本对于之前的版本进行了很大的瘦身，如果原生js能够实现的，就舍弃vue，直接用原生js实现。 过滤器(filter)的介绍Vue中过滤器是对于接口返回的字段进行业务(形式)上的转换。 vue实例在一些多页应用中，可以直接建立vue实例，然后通过标签引入。 下面举一个过滤器在中使用的小例子：1234&lt;p&gt;&#123;&#123;data | formateMoney&#125;&#125;&lt;/p&gt;&lt;div v-for=&quot;(item,index) in formateSlice &quot;&gt;//以函数的形式，当有参数是则为formateMoney(value) 1234567891011121314151617181920212223242526272829303132333435363738394041new Vue(&#123; el:&quot;#app&quot;, //所对应需要渲染的部分块 data:&#123; getData:[] &#125;, filters:&#123; formateMoney:function(value)&#123;//这里传入进来的参数即为过滤器前的数值 return value+&quot;处理过程&quot; &#125; &#125;, computed:&#123; formateSplice:function()&#123; return this.getData.slice(0,n) &#125; &#125; mounted:function()&#123; //页面加载完成后所需进行的操作,只使用mounted钩子并不能保证实例已经插入文档，还需要在实例中包含vue.$nextTick this.$nextTick(function()&#123; this.cart(); &#125;) &#125;, methods:&#123; cart:function()&#123; this.$http.get().then(function()&#123; //调用vue-resource方法取数据，利用promise.then( res=&gt;&#123; this.getData=res.data; //这里使用箭头函数的好处在于，箭头函数无this指向，函数内的this指向外部，即函数内层的this和外层的this为同一指向 &#125; )方法完成回调 &#125;) &#125; &#125;,&#125;) vue实例包括一些，实例属性，实例方法，和实例事件使用方法详见官网API教程。]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F29%2FVue%E5%9F%BA%E7%A1%80(1)%2F</url>
    <content type="text"><![CDATA[Vue中组件之间的通信父组件可以通过调用子组件的形式来在父组件的模板中渲染出子组件的内容，当然，父组件也可以通过组件属性，向子组件传递信息。 ## 示例1 父组件想子组件中传递信息 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;hello&gt;&lt;/hello&gt; **//定义message属性，并将属性值传回子组件 &lt;testComponent message=&quot;welcome to the App&quot; &gt;&lt;/testComponent&gt;** &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Hello from &apos;./components/Hello&apos;import TestComponent from &apos;./components/TestComponent&apos;import Store from &apos;./store&apos;export default &#123; name: &apos;app&apos;, data()&#123; return&#123; msg: &apos;Welcome to Your Vue.js App&apos;, &#125; &#125;, components: &#123; Hello, TestComponent &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.finished&#123; text-decoration:underline;&#125;&lt;/style&gt; 子组件中通过props:[]接受属性，此时在子组件即可对接受到的值进行渲染1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;acceptMessage&quot;&gt; acceptMessage&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;testComponent&apos;, data () &#123; return &#123; msg:&apos;Here is testComponent&apos; &#125; &#125;, ** props:[&quot;message&quot;],** methods:&#123; acceptMessage:function()&#123; //直接调用父组件的信息进行渲染 **this.msg=this.message;** &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125; 示例2子组件向父组件中传递信息通过以上可知，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！ 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;hello&gt;&lt;/hello&gt; &lt;testComponent message=&quot;welcome to the App&quot; **v-on:messageFromChild=&quot;messageFromChildren&quot;&gt;&lt;/testComponent&gt; //自定义事件messageFromChild,即接受到子组件发出事件messageFromcChild后，执行messageFromChildren方法** &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Hello from &apos;./components/Hello&apos;import TestComponent from &apos;./components/TestComponent&apos;import Store from &apos;./store&apos;export default &#123; name: &apos;app&apos;, data()&#123; return&#123; msg: &apos;Welcome to Your Vue.js App&apos;, &#125; &#125;, components: &#123; Hello, TestComponent &#125;, methods:&#123; messageFromChildren:function()&#123; this.msg= &quot;I&apos;m child&quot; &#125; &#125;&#125;&lt;/script&gt; 子组件中 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;acceptMessage&quot;&gt; acceptMessage&lt;/button&gt; &lt;button @click=&apos;sendMessage&apos;&gt;sendMessage&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;testComponent&apos;, data () &#123; return &#123; msg:&apos;Here is testComponent&apos; &#125; &#125;, props:[&quot;message&quot;], methods:&#123; acceptMessage:function()&#123; this.msg=this.message; &#125;, sendMessage:function()&#123; //通过点击按钮，触发自定义事件messageFromChild //$emit(a,b)也可以将所需传递的参数b发送到父组件 ** this.$emit(&apos;messageFromChild&apos;);** &#125; &#125;&#125;&lt;/script&gt; 以前的方法中还可以使用$dispatch和$broadcast来向上、向下传递信息，但是它们连同events使用在Vue.2.x中已经被弃用！ 此外，Vue作为一个框架，还有作为数据层面以Ajax(Vue-resource)和服务端交互，还有就是作为单页面应用时路由功能(Vue-router库)。 对于开发中的其他问题，可以查看Vue的官方开发文档，以及Vue的论坛forum.vuejs.org的中文板块]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(9)]]></title>
    <url>%2F2017%2F06%2F29%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(9)%2F</url>
    <content type="text"><![CDATA[装饰者模式装饰者模式能够在不改变对象自身的基础上，在程序运行期间为对象动态的增加新的职责。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。其作用实际就是为对象动态地加入新的职责和行为。 用AOP装饰函数1234567891011121314151617181920Function.prototype.before=function(beforefn)&#123; var self=this; //保存原函数的引用 return function()&#123; beforefn.apply(this,arguments); //执行新函数，且保证this不会被劫持，新的函数的参数也会被原封不动的传入原函数，新函数在原函数之前执行(共用一组参数列表) return self.apply(this,arguments); //执行原函数，并且返回原函数执行结果，并且保证this不会被劫持 &#125;&#125;Function.prototype.after=function(afterfn)&#123; var self=this; //返回一个代理函数，代理函数分别执行新函数与原函数 return function()&#123; var ret=self.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;&#125; 也可以在不污染原型的情况下，做出一些变通，123456789101112var before=function(fn,beforefn)&#123; return function()&#123; beforefn.apply(this,arguments); return fn.apply(this,arguments); &#125;&#125;var a =before(function()&#123;console.log(1)&#125;,function()&#123;console.log(2)&#125;);a=before(a,function()&#123;console.log(5)&#125;);a();结果： 5 2 1 利用AOP装饰函数的技巧，可以把行为依照职责分成粒度更加细的函数，随后将它们装饰合并到一起，有利用一个松耦合高复用的系统。 利用AOP动态改变函数的参数1234567891011121314151617Function.prototype.before=function(fn)&#123; var self=this; return function()&#123; fn.apply(this,arguments); return self.apply(this,arguments); &#125;&#125;var func=function(para)&#123; console.log(para)&#125;func=func.before(function(para)&#123; para.b=&apos;b&apos;;&#125;)func(&#123;a:&apos;a&apos;&#125;)结果：Object &#123;a: &quot;a&quot;, b: &quot;b&quot;&#125; 值得注意的是：Function.prototype.before或者Function.prototype.afte被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会发生丢失。1234567891011121314151617181920Function.prototype.before=function(fn)&#123; var self=this; return function()&#123; fn.apply(this,arguments); return self.apply(this,arguments); &#125;&#125;var func=function(haha)&#123; console.log(haha)&#125;//原函数的属性func.a=&apos;a&apos;func=func.before(function(para)&#123; para.c=&apos;c&apos;;&#125;)func(&#123;b:&apos;b&apos;&#125;)//属性发生了丢失Object &#123;b: &quot;b&quot;, c: &quot;c&quot;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(10)]]></title>
    <url>%2F2017%2F06%2F29%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(10)%2F</url>
    <content type="text"><![CDATA[状态模式状态模式额关键在于区分事物内部的状态，事物内部状态的改变往往会带来行为的改变。 通常我们谈到的封装，一般会优先封装状态的行为，但是在状态模式中正好相反，状态模式的关键是将事物的每种状态都封装成单独的类，与此种状态有关的行为也会被封装在这个类的内部。 状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 将这句话拆分开来解释的话就是：将状态封装成独立的类，并将请求委托给当前的状态对象，当对象内部状态发生改变时，会通过改变行为带来不同的变化。我们使用的对象，在不同状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//定义一个Light类（context），随后在Light类的构造函数中创建每个状态类的实例对象，context将持有这些状态对象的引用，以便把请求委托给状态对象。var Light=function()&#123; this.offLightState= new OffLightState(this); this.weakLightState=new WeakLightState(this); this.strongLightState=new StrongLightState(this); this.button=null;&#125;Light.prototype.init=function()&#123; var button =document.createElement(&apos;button&apos;); self=this; this.button=document.body.appendChild(button); this.button.innerHTML=&apos;开关&apos;; this.currState=this.offLightState; this.button.onclick=function()&#123; self.currState.buttonWasPressed(); &#125;&#125;//建立每个状态类var OffLightState=function(light)&#123; this.light=light;&#125;OffLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;weaklight&apos;); this.light.setState(this.light.weakLightState);&#125;var WeakLightState=function(light)&#123; this.light=light;&#125;WeakLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;stronglight&apos;); this.light.setState(this.light.strongLightState);&#125;var StrongLightState=function(light)&#123; this.light=light;&#125;StrongLightState.prototype.buttonWasPressed=function()&#123; console.log(&apos;offlight&apos;); this.light.setState(this.light.offLightState);&#125;//设置状态Light.prototype.setState=function(newState)&#123; this.currState.newState;&#125;var light=new Light();light.init(); 状态模式的优点 1.定义了状态和行为之间的关系，并将其封装在一个类中。通过增加新的状态类，很容易增加新的状态和转换。 2.Context中的请求动作和状态类中的封装的行为可以非常容易的独立变化而不相互影响。 1234567891011121314151617181920212223242526272829303132var Light=function()&#123; this.currState=FSM.off; this.button=null;&#125;Light.prototype.init=function()&#123; var button=document.createElement(&apos;button&apos;); self=this; this.button.onclick=function()&#123; //把请求委托给FSM状态机 self.currState.buttonWasPressed.call(self); &#125;&#125;var FSM=&#123; off:&#123; buttonWasPressed:function()&#123; console.log(&apos;关灯&apos;); this.currState=FSM.on; &#125; &#125;, on:&#123; buttonWasPressed:function()&#123; console.log(&apos;开灯&apos;); this.currState=FSM.off; &#125; &#125;&#125;var light=new Light();light.init(); 利用call()方法直接把请求委托给某个字面量对象来执行。 设计原则1.单一职责原则：一个对象(方法)只做一件事情，即将对象划分为较小的粒度使用。 2.最少知识原则：提供中介、只暴露必须的API接口，降低对象之间的耦合。 3.开放-封闭原则：软件实体（模块，类，函数等）应该是可以扩展的但是不可以修改(AOP扩展) 常用的方法来保证开放-封闭原则： 1.用对象的多态性(同一消息对不同对象产生不同效果)来消除条件分支语句。 2.放置挂钩。利用挂钩的结果来决定程序的下一步走向。 3.使用回调函数。回调函数是一种特殊的挂钩，可以把一部分易于变化的部分封装在回调函数里，然后回调函数当做参数传入一个稳定的封闭函数中。当回调函数被执行时，程序就会因为回调函数内部的逻辑不同而产生不同的效果。 写代码需要注意：提炼函数、合并重复条件片段、合理使用循环、传递对象参数代替过长的参数列表、尽量减少参数数量、使用return退出多重循环]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(8)]]></title>
    <url>%2F2017%2F06%2F28%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(8)%2F</url>
    <content type="text"><![CDATA[职责链模式定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，再将这些对象练成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。 异步的职责链1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Chain=function(fn)&#123; this.fn=fn; this.successor=null;&#125;//指定在链中的下一个节点Chain.prototype.setNextSuccessor=function(successor)&#123; return this.successor=successor;&#125;//传递请求给某节点Chain.prototype.passRequest=function()&#123; var ret = this.fn.apply(this,arguments); if(ret==&apos;nextSuccessor&apos;)&#123; return this.successor&amp;&amp;this.successor.passRequest.apply(this.successor,arguments); &#125;&#125;Chain.prototype.next=function()&#123; return this.successor.passRequest.apply(this.successor,arguments);&#125;var fn1=new Chain(function()&#123; console.log(1); return &apos;nextSuccessor&apos;;&#125;)var fn2=new Chain(function()&#123; console.log(2); var self=this; setTimeout(function()&#123;self.next()&#125;,1000); return &apos;nextSuccessor&apos;&#125;)var fn3=new Chain(function()&#123; console.log(3); return &apos;nextSuccessor&apos;;&#125;)var fn4=new Chain(function()&#123; console.log(4);&#125;)fn1.setNextSuccessor(fn2);fn2.setNextSuccessor(fn3);fn3.setNextSuccessor(fn4);fn1.passRequest();VM835:24 1VM835:29 2VM835:36 3VM835:41 4一秒过后VM835:36 3VM835:41 4 除此之外，也可以用AOP实现职责链。 中介者模式其作用是解除对象与对象之间的紧耦合关系。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; 选择颜色:&lt;select id=&quot;colorSelect&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;红色&lt;option&gt; &lt;option value=&quot;blue&quot;&gt; 蓝色&lt;/option&gt; &lt;/select&gt; 输入购买量:&lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt; 你选择的颜色:&lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt; 你输入的数量:&lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt; &lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和数量&lt;/button&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var colorSelect=document.getElementById(&quot;colorSelect&quot;), numberInput=document.getElementById(&quot;numberInput&quot;), colorInfo=document.getElementById(&quot;colorInfo&quot;), numberInfo=document.getElementById(&quot;numberInfo&quot;), nextBtn=document.getElementById(&apos;nextBtn&apos;); var goods=&#123;&apos;red&apos;:3,&apos;blue&apos;:6&#125;; colorSelect.onchange=function()&#123; var color=this.value, number=numberInput.value, stock=goods[color]; colorInfo.innerHTML=color; if(!color)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot;; return; &#125; if(number&gt;stock)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;库存不足&quot;; return; &#125; nextBtn.disalbed=false; nextBtn.innerHTML=&quot;放入购物车&quot;; &#125; numberInput.oninput=function()&#123; var color=this.value, number=numberInput.value, stock=goods[color]; numberInfo.innerHTML=number; if(color==&quot;&quot;)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot; &#125; if(number&gt;stock)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;库存不足&quot;; &#125;else&#123; nextBtn.disalbed=false; nextBtn.innerHTML=&quot;放入购物车&quot;; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 使用中介者模式改变之后，所有的节点只和中介者进行通信，当下拉框colorSelect和文本输入框numberInput发生了事件变化时，它们仅仅通知中介者它们发生了改变，同时把自身以参数的形式传入中介者，以便中介者辨别是谁发生了改变。12345678910111213141516171819202122232425262728293031var mediator=(function()&#123; var colorSelect=document.getElementById(&quot;colorSelect&quot;), numberInput=document.getElementById(&quot;numberInput&quot;), colorInfo=document.getElementById(&quot;colorInfo&quot;), numberInfo=document.getElementById(&quot;numberInfo&quot;), nextBtn=document.getElementById(&apos;nextBtn&apos;); var goods=&#123;&apos;red&apos;:3,&apos;blue&apos;:4&#125;; return&#123; changed:function(obj)&#123; var color=colorSelect.value, number=numberInput.value, stock=goods[color]; colorInfo.innerHTML=color; if(obj===colorSelect)&#123; colorInfo.innerHTML=color; &#125;else if(obj==numberInput)&#123; numberInfo.innerHTML=number; &#125; if(!color)&#123; nextBtn.disabled=true; nextBtn.innerHTML=&quot;请选择手机颜色&quot;; return; &#125; &#125; &#125; &#125;)()colorSelect.onchange=function()&#123; console.log(this); mediator.changed(this); &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F28%2FReactJs%2F</url>
    <content type="text"><![CDATA[基础知识示例11234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .test&#123; color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; var Hello=React.createClass(&#123; render:function()&#123; var styleObject=&#123;color:&apos;blue&apos;,fontSize:&apos;50px&apos;&#125; return &lt;div className=&quot;test&quot;&gt;&#123;this.props.title&#125; hello &#123;this.props.name&#125;&lt;/div&gt; &#125; &#125;) React.render(&lt;Hello name=&quot;world&quot; title=&quot;first one&quot; /&gt;, document.getElementById(&quot;root&quot;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件的声明周期三个状态（每个状态封装了自己的hook函数）： 1.Mounted:指的是React Components被render解析生成对应的DOM节点，并被插入浏览器的DOM结构的一个过程 2.Updating:指的是一个mounted的React Components被重新render的过程。方法是比较相邻两次render()时的state,当state发送改变且影响DOM结构时，重建渲染DOM树 3.Unmounted:指的是mounted的组件被移除，从DOM树中移除DOM节点 Mounted状态的hook函数顺序：getDefaultProps()=&gt;getInitialState()=&gt;componentWillMount=&gt;render=&gt;componentDidMount Updating的过程：componentWillReceiveProps（接受新的props，在函数体内比较老旧props,从而执行一些类似于修改state的操作）=&gt;shouldComponentUpdate（接收到新的props和state之后判断是否有必要去更新dom结构，返回true需要更新，反之亦然）=&gt;componentWillUpdate=&gt;render=&gt;componentDidUpdate Unmounting过程：componentWillUnmount 示例21234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; var Hello=React.createClass(&#123; render:function()&#123; alert(&quot;ing&quot;); return &lt;div style=&#123;this.state&#125;&gt; this is a test&lt;/div&gt; &#125;, getInitialState:function()&#123; return&#123; opacity:0.5, color:&apos;blue&apos;, fontSize:&apos;44px&apos; &#125; &#125;, componentWillMount:function()&#123; alert(&quot;will&quot;) &#125;, componentDidMount:function()&#123; window.setTimeout(function()&#123; this.setState(&#123;opacity:1,color:&apos;red&apos;,fontSize:&apos;54px&apos;&#125;); &#125;.bind(this),1000) &#125; &#125;) React.render(&lt;Hello /&gt;, document.getElementById(&quot;root&quot;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果是以此出现：”will”, “ing”,一秒过后 出现”ing”并且样式改变。 以上例子是通过给一个初始state并且设置更改state的方法改变样式。这里还涉及了this的对外绑定，否则应在setTimeout()的函数内将this传递给一个的新的变量。这里需要知道props和state的区别，props是属于调用方，结构上为parent所有，state为当前组件所拥有，是可变的。 示例3（事件侦听）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/react@latest/dist/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@latest/dist/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- 因为通过this.refs.test拿到的并非是真实的DOM节点而是react component，对于真实DOM节点操作需要调用React.findDOMNode()方法--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/jsx&quot;&gt; var Click=React.createClass(&#123; handlerClick:function(event)&#123; var real = React.findDOMNode(this.refs.test) if(real.style.display==&apos;none&apos;)&#123; real.style.display=&apos;inline&apos;; &#125; else&#123; real.style.display=&apos;none&apos;; &#125; //event事件 event.preventDefault(); event.stopPropagation(); &#125;, render:function()&#123; return &lt;div&gt; &lt;button onClick=&#123;this.handlerClick&#125;&gt;显示|隐藏&lt;/button&gt;&lt;span ref=&quot;test&quot;&gt;测试&lt;/span&gt;&lt;/div&gt; &#125; &#125;) var Input=React.createClass(&#123; getInitialState:function()&#123; return &#123; inputText:&apos;&apos; &#125; &#125;, handlerChange:function(event)&#123; this.setState(&#123;inputText:event.target.value&#125;); event.preventDefault(); event.stopPropagation(); &#125;, render:function()&#123; //设置初始state，并在元素中绑定state状态进行重新渲染 return &lt;div&gt;&lt;input type=&quot;text&quot; onChange=&#123;this.handlerChange&#125; /&gt;&lt;span&gt;&#123;this.state&#125;&lt;/span&gt;&lt;/div&gt; &#125; &#125;) React.render(&lt;div&gt;&lt;Click /&gt;&lt;Input /&gt;&lt;/div&gt;, document.getElementById(&quot;root&quot;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意：render()函数渲染时必须是有一个最外层的包裹元素，React.render()方法中渲染组件也是如此。]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5基础知识(2)]]></title>
    <url>%2F2017%2F06%2F28%2FH5%E7%94%BB%E5%B8%832%2F</url>
    <content type="text"><![CDATA[Canvas的一些高级功能示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; var canvas=$(&quot;#mycanvas&quot;); var context=canvas.get(0).getContext(&quot;2d&quot;); context.fillRect(40,40,100,100); &#125;) &lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var cxt=c.getContext(&quot;2d&quot;); cxt.fillStyle=&quot;rgb(255,0,0)&quot;; //红色压栈 cxt.save(); cxt.fillRect(50,50,100,100); cxt.fillStyle=&quot;rgb(0,255,0)&quot;; //绿色压栈 cxt.save(); cxt.fillRect(200,50,100,100); //自动取出栈中的最后状态,绿色 cxt.restore(); cxt.fillRect(350,50,100,100); //红色 cxt.restore(); cxt.fillRect(50,200,100,100); //平移 cxt.fillRect(0,0,20,20); cxt.translate(150,150); //平移后的显示，之后所有操作均带有平移属性 cxt.fillRect(0,0,20,20); //之后的所有操作均带有旋转属性 cxt.rotate(0.7854);//旋转45度(Math.PI/4); cxt.fillRect(150,150,40,40); //合成 cxt.fillStyle=&quot;rgb(63,169,245)&quot;; cxt.fillRect(200,50,100,100); cxt.globalAlpha=0.5; cxt.fillStyle=&quot;rgb(255,123,172)&quot;; cxt.fillRect(250,100,100,100); //阴影 cxt.shadowBlur=20; cxt.shadowColor=&quot;rgb(0,0,0)&quot;; cxt.fillRect(10,10,50,50);s &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2017%2F06%2F28%2FVue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[脚手架搭建1.windows上安装git、node 2.利用命令行安装Vue,这里注意可以借助淘宝的npm国内镜像，使用cnpm替代npm加速下载，安装速度。 3.具体命令行为： //全局安装 vue-cli$ cnpm install –、global vue-cli// 创建一个基于 webpack 模板的新项目$ vue init webpack my-project// 安装依赖，走你$ cd my-project$ cnpm install$ cnpm run dev 安装过程中可能出现问题包括:node或者npm版本不够，或者端口8080被占用等情况，可自行网搜解决。 todoList示例通过todoList的示例，了解基本Vue的api使用。这里只展示了父组件APP.Vue(项目的入口)和子组件Hello.Vue的代码结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//template为展示界面&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; //引入组件 Hello &lt;hello&gt;&lt;/hello&gt; &lt;!-- v-on用于绑定事件--&gt; &lt;button v-on:click=&quot;doSomething&quot;&gt;Click me!&lt;/button&gt; &lt;!-- v-bind用于绑定属性,常用于绑定class,以下展示的为&#123;类名：布尔值的形式&#125; 当:class=&quot;[classA,classB]&quot;时，为绑定两个类名，且此时，被绑定的类名需要在数据中给予声明。--&gt; &lt;--v-for用于循环输出数据--&gt; **这里注意：Vue1.0和2.0中对于V-for的索引使用方式是不同的，2.0中，若要出现索引，则v-for=&quot;(item,index) in items&quot;然后在接下来的使用中直接写index即可。** &lt;ul &gt; &lt;li v-for=&quot;item in items&quot; v-bind:class=&quot;&#123;finished: item.isFinish&#125;&quot; @click=&quot;changed(item)&quot;&gt;&#123;&#123;item.label&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 用 v-model 指令在表单控件元素上创建双向数据绑定,获取表单中的数据值 --&gt; &lt;!-- 事件的侦听有多种，以下为侦听输入enter所执行的操作 --&gt; &lt;input v-model=&quot;newItem&quot; v-on:keyup.enter=&quot;addNewItem&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入组件import Hello from &apos;./components/Hello&apos;import Store from &apos;./store&apos;//export default&#123;&#125;方法相当于 new Vue(&#123;&#125;)的方式。export default &#123;//组件对外显示的名称 name: &apos;app&apos;,//ES6中的表达方式，等效于 data:function()&#123;&#125; data()&#123; return&#123; msg: &apos;Welcome to Your Vue.js App&apos;, haha:&apos;&lt;spna&gt;really!&lt;/span&gt;haha tomorrow&apos;, a:1, show:false, isShow:true, items:Store.fetch(), newItem:[] &#125; &#125;,//组件必须注册，才能使用 components: &#123; Hello &#125;,//事件方法 methods:&#123; doSomething:function()&#123; this.a++; &#125;, changed:function(item)&#123; item.isFinish=! item.isFinish; &#125;, addNewItem:function()&#123; this.items.push(&#123;label:this.newItem,isFinish:false&#125;) this.newItem=&apos;&apos;; &#125; &#125;,//侦听事件变化，事件变化时驱动方法 watch:&#123; //简写模式 a :function(val,oldVal)&#123; console.log(val,oldVal); &#125;, items:&#123; handler: function()&#123; Store.save(this.items) &#125;, //深度侦听键值的变化 deep:true &#125; &#125;&#125;&lt;/script&gt;//所有的样式全部包括在&lt;style&gt;标签下&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.finished&#123; text-decoration:underline;&#125;&lt;/style&gt; 子组件示例子组件Hello 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;!-- 模板指令是html和vue之间的粘合剂 --&gt; &lt;!-- v-on用于时间绑定 v-on:click==@click --&gt; &lt;!-- 模板命令v-if v-show是通过布尔值用来控制模块的隐藏 --&gt; &lt;!-- 区别在于v-if是不渲染，而v-show是通过css属性的display:none;来隐藏属性 --&gt; &lt;!-- &lt;p v-if=&quot;isShow&quot;&gt;hello p element&lt;/p&gt; &lt;p v-show=&quot;show&quot;&gt; hi p element &lt;/p&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- vue.js中我们只是去关心抽象出来的数据，并不去关心这些数据实现的过程(这个过程交给vue来做) --&gt;&lt;script&gt;// export&#123;&#125;对象出来的东西会在 new Vue(&#123;&#125;)中自动生成一个属于自己的属性export default &#123;//对外暴露组件名，这里需要注意 name: &apos;hello&apos;, data () &#123; return &#123; msg:&apos;hello everyone&apos; &#125; &#125;,&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5基础知识]]></title>
    <url>%2F2017%2F06%2F28%2FH5%E7%94%BB%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Canvas基础知识示例：canvas基本方法使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; var canvas=$(&quot;#mycanvas&quot;); var context=canvas.get(0).getContext(&quot;2d&quot;); context.fillRect(40,40,100,100); &#125;) &lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var cxt=c.getContext(&quot;2d&quot;); //画长方形，参数分别为坐标x,y,width,height cxt.fillStyle=&quot;#00FF00&quot;;//设置填充颜色 cxt.lineWidth=5;// 设置线条宽度 cxt.fillRect(100,100,50,100); //画边框 cxt.strokeStyle=&quot;#FF0000&quot;;//设置线条颜色 &quot;#FF0000&quot;==&quot;rgb(255,0,0)&quot; cxt.strokeRect(0,0,150,75); //画线&amp;&amp;也可用于画复杂图形，例如三角 cxt.beginPath(); cxt.moveTo(50,50); cxt.lineTo(50,60); cxt.closePath(); cxt.stroke(); //画圆 cxt.beginPath(); //6个参数分别为：圆心坐标想x,y，圆的半径，开始角度，结束角度，逆顺时针（逆时针用true,顺时针用false）; //注意：这里的角度以弧度为单位 cxt.arc(230,90,50,0,Math.PI*2,false); cxt.closePath(); //填充圆 cxt.fill(); //清除填充，参数分别为起点坐标x,y,宽度width和高度height cxt.clearRect(230,90,50,50); //画轮廓 cxt.stroke(); &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(5)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(5)%2F</url>
    <content type="text"><![CDATA[观察者模式(发布-订阅模式)它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。 js中一般使用注册回调函数的形式来代替传统的观察者模式，并且arguments可以很方便地表示参数列表，因而一般用推模型使用Function.prototype.apply方法将所有参数都推送给订阅者。 观察者模式优点：时间上解耦，对象之间的解耦。 命令模式应用场景：有时候需要向某些对象发送请求，但是不知道请求的接受者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接受者消除彼此之间的耦合关系。 js中的利用闭包实现命令模式：123456789101112131415161718192021var setCommand=function(button,command)&#123; button.onclick=function()&#123; command.execute; &#125;&#125;var MenuBar=&#123; refresh:function()&#123; console.log(&apos;刷新菜单界面&apos;) &#125;&#125;var RefreshMenuBarCommand=function(receiver)&#123; return &#123; execute:function()&#123; receiver.refresh; &#125; &#125;&#125;var RefreshMenuBarCommand=RefreshMenuBarCommand(MenuBar);setCommand(button1,RefreshMenuBarCommand); 宏命令通过宏命令，一次可以执行一批命令12345678910111213141516171819202122232425262728293031323334var closeDoorCommand=&#123; execute:function()&#123; console.log(&apos;1&apos;); &#125;&#125;var openDoorCommand=&#123; execute:function()&#123; console.log(&apos;2&apos;); &#125;&#125;var openWindow=&#123; execute:function()&#123; console.log(&apos;3&apos;); &#125;&#125;var MacroCommand=funciton()&#123; return&#123; commandList:[], add:funciton(command)&#123; this.commandList.push(command) &#125;, execute:function()&#123; for(var i=-0,command;command=this.commandList[i++];)&#123; command.execute; &#125; &#125; &#125; &#125;var macroCommand=MacroCommand();macroCommand.add(closeDoorCommand);macroCommand.add(openDoorCommand);macorCommand.add(openWindow);macroCommand.execute; 组合模式组合模式就是用小的对象来构建更大的对象，而这些小的子对象本身也许来自更小的对象。上一节中的宏命令即为一个组合模式的例子。 注意1.组合模式不是父子关系，组合模式把对象的请求委托给它包含的所有叶对象。 2.组合模式除了要求组合对象和叶对象拥有相同的接口，还要求对一组叶对象的操作必须具有一致性。 3.可以用职责连模式来提高组合模式的性能]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(6)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(6)%2F</url>
    <content type="text"><![CDATA[# 模板方法模式 模板方法模式是一种只需要使用继承就可以实现的简单模式。 通常该方法由两个部分组成：第一部分是抽象父类，第二部分是具体的实现子类。通常在父类中封装了子类的算法框架，包括一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也就继承了整个算法结构。 在模板方法中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。 示例：冲泡茶和冲泡咖啡的过程大致可以总结为以下几个步骤： 1.把水煮沸 2.用沸水冲泡 3.将冲泡好的导入杯子中 4.加其他调料 于是可以这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var Beverage = function()&#123;&#125;;Beverage.prototype.boilWater=function&#123; console.log(&apos;冲水&apos;);&#125;Beverage.prototype.brew=funciton()&#123;&#125;;Beverage.prototype.pourInCup=function()&#123;&#125;;Beverage.prototype.addCondiments=funciton()&#123;&#125;;Beverage.prototype.init=function()&#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); &#125;//***********************************************************************对于咖啡和茶，用不同的子类继承该父类var Coffee=funciton()&#123;&#125;;Coffee.prototype=new Beverage();接下来可以调用Beverage的原型方法，并加入自己的不同之处Coffee.prototype.brew=function()&#123; console.log(&apos;用水冲咖啡&apos;);&#125;Coffee.prototype.pourInCup=function()&#123; console.log(&apos;把咖啡倒进杯子&apos;);&#125;Coffee.prototype.addCondiments=function()&#123; console.log(&apos;加糖&apos;);&#125;var coffee = new Coffee();coffee.init();//******************************************************************var Tea=function()&#123;&#125;;Tea.prototype=new Beverage();Tea.prototype.brew=function()&#123; console.log(&apos;用水冲茶&apos;)&#125;Tea.prototype=function()&#123; console.log(&apos;把茶倒入杯子中&apos;);&#125;Tea.prototype=function()&#123; console.log(&apos;加入柠檬&apos;);&#125;var tea=new Tea();tea.init(); 这里，真正的模板方法是Beverage.prototype.init()。因为该方法中封装了子类的算法框架，它作为一个算法框架，知道子类以何种顺序去执行那些算法。在Beverage.prototype.init()方法中，算法的每一个步骤都清晰的呈现在眼前。 js中在父类中有些抽象方法只是被声明，但是并没有具体的实现方法，如果在子类中忘记重写，显然不是我们所需要的。解决方法可以有：1234567Beverage.prototype.brew=funciton()&#123; throw new Error(&apos;子类必须重写brew方法&apos;)&#125;;Beverage.prototype.pourInCup=function()&#123; throw new Error(&apos;子类必须重写pourInCup方法&apos;)&#125; 让Beverage.prototype.brew()等方法抛出一个异常。 应用场景Web开发中在构建UI组件的过程可以用到模板模式： 1.初始化一个div容器 2.通过ajax请求拉取相应的数据 3.把数据渲染到div容器里，完成组件的构造 4.通知用户组件渲完毕 钩子方法模板封装子类的算法框架适合用于大多数子类，但是如果有些特别‘个性’子类，就需要让子类可以跳出模板的约束。这时，可以用钩子方法来隔离变化，究竟需不需要钩子则由子类决定。12345678910111213141516171819202122232425262728293031Beverage.prototype.customWantCondiments=function()&#123; return true;&#125;Beverage.prototype.addCondiments=funciton()&#123;&#125;;Beverage.prototype.init=function()&#123; this.boilWater(); this.brew(); this.pourInCup(); if(this.customWantCondiments())&#123; this.addCondiments(); &#125; &#125;var Coffee=funciton()&#123;&#125;;Coffee.prototype=new Beverage();Coffee.prototype.addCondiments=function()&#123; console.log(&apos;加糖&apos;);&#125;Coffee.prorotype.customWantConiments=function()&#123; window.confirm(&apos;要加调料吗？&apos;)&#125;var coffee = new Coffee();coffee.init(); ‘好莱坞原则’允许低层组件将自己挂钩到高层组件中，而高层组件会决定在什么时候，以何种方式去使用这些低层组件。而模板方法模式就是该原则的一个重要体现，当我们用模板方法模式来进行编码时，就意味着我们放弃了对自己的控制权，而改为父类通知子类哪些方法应该在什么时候被调用。而作为子类，只是负责提供一些设计上的细节。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(7)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(7)%2F</url>
    <content type="text"><![CDATA[享元模式享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 享元模式要求将对象的属性划分为内部状态与外部状态(这里的状态通常指属性)。其目标是尽量减少共享对象的数量。具体的内部对象是指独立于具体的场景，通常不会改变，外部对象是指取决于具体场景，并且根据外部场景的变化，外部状态不能被共享。 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里面获取。如果对象池是没有空闲对象，则新建一个新的对象，当获取出的对象完成了它的职责之后，再次进入池子等待被获取。1234567891011121314151617181920212223242526272829303132333435363738var toolFactory=(function()&#123; var toolPool=[]; return&#123; create:function()&#123; if(toolPool.length==0)&#123; var div=document.creat(&apos;div&apos;); document.body.appendChild)(div); return div; &#125;else&#123; return toolPool.shift(); &#125; &#125;, recover:function(toolDom)&#123; return toolPool.push(toolDom); &#125; &#125;&#125;))()var arr=[];//创建两个节点for(var i=0,str;str=[&apos;a&apos;,&apos;b&apos;][i++];)&#123; var toolTip=toolFactore.create(); toopTip.innerHTML=str; arr.push(toopTip);&#125;//回收进对象池for(var j=0,tooptip;tooptip=arr[i++];)&#123; toolFactory.recover(tooptip);&#125;//再次创建节点时可以直接从对象池里面获取for(var k=0,str;str=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;][i++];)&#123; var toopTip=toolFactory.create(); toopTip.innerHTML=str;&#125; 通用的对象池12345678910111213141516171819202122232425var toolFactory=function(fn)&#123; var toolPool=[]; return&#123; create:function()&#123; if(toolPool.length==0)&#123; return fn.apply(this.arguments); &#125;else&#123; return toolPool.shift(); &#125; &#125;, recover:function(obj)&#123; return toolPool.push(obj); &#125; &#125;&#125;var finalFactory=toolFactory(function()&#123; var div = document.create(&apos;div&apos;); document.body.appendChild(div); return div;&#125;)var tooltip=finalFactory.create();tooltip.innerHTML=&apos;a&apos;;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(4)]]></title>
    <url>%2F2017%2F06%2F27%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)%2F</url>
    <content type="text"><![CDATA[代理模式定义：为一个对象或提供一个代用品或占位符，以便控制对它的访问。 代理模式分为保护代理和虚拟代理。保护代理是用于控制不同权限对象对目标对象的访问。虚拟代理会把一些开销很大的对象，延迟到真正需要它的再去创建。 代理的意义实现单一职责原则。即，就一个类（通常也包括对象和函数），应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，意味着将这些职责耦合到了一起，这种耦合会导致脆弱和迪内聚的设计。 示例加载一张图片：12345678910var myImage=(funciton()&#123; var imgNode=document.creatElement(&apos;img&apos;); document.body.appendChild(imgNode); return&#123; setSrc:function(src)&#123; imgNode.src=src &#125; &#125;&#125;)()myImage.setSrc(&quot;..........&quot;) 增加代理之后，将预加载与图片加载分离：12345678910111213var proxyImage=(function()&#123; var img=new Image; img.onload=function()&#123; myImage.setSrc(this.src); &#125; return&#123; setSrc:function(src)&#123; myImage.setSrc(&apos;本地的loading图片&apos;); img.src=src; &#125; &#125;&#125;)()proxyImage.setSrc(&apos;真正图片&apos;)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式(3)]]></title>
    <url>%2F2017%2F06%2F26%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)%2F</url>
    <content type="text"><![CDATA[单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局节点。 js中的单例模式是为了避免全局变量的使用，降低全局变量带来的污染。具体方法有： 1.使用命名空间 2.使用闭包封装私有变量 惰性单例定义：仅仅在需要时候才创建对象实例。 通用的惰性单例模式：123456var getSingle = function(fn)&#123; var result; return function()&#123; return result||(fn.apply(this,arguments)); &#125;&#125; 策略模式定义：定义一系列算法，把它们一个个封装起来。将算法的使用和算法的实现分离开来。12345678910var stratgies=&#123; &quot;s&quot;:function(salary)&#123;return salary*4&#125;, &quot;A&quot;:function(salary)&#123;return salary*5&#125;, &quot;B&quot;:function(salary)&#123;return salary*6&#125;&#125;;var calculate=function(level,salary)&#123; return stratgies[level](salary);&#125;calculate(&quot;A&quot;,4000);20000 示例利用策略模式将表单提交重构12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;post&quot;&gt; 用户名:&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt; 密码:&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt; 手机号:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var registerForm = document.getElementById(&apos;registerForm&apos;); registerForm.onsubmit=function()&#123; if(registerForm.userName.value===&quot;&quot;)&#123; alert(&apos;用户名不能为空&apos;) return false; &#125; if(registerForm.password.value==&quot;&quot;)&#123; alert(&apos;密码不能为空&apos;); return false; &#125; if(!/^1[3|5|8][0-9]&#123;9&#125;$/.test(registerForm.phoneNumber.value))&#123; alert(&apos;手机号码不对&apos;); return false; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 重构后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form id=&quot;registerForm&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 手机号:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; //***********************************策略对象*************************************************** var strategies=&#123; isEmpty:function(value,errorMsg)&#123; if(value==&quot;&quot;)&#123; return errorMsg; &#125; &#125;, isMobile:function(value,errorMsg)&#123; if(!/1[3|5|8][0-9]&#123;9&#125;/.test(value))&#123; return errorMsg; &#125; &#125; &#125; //**********************************Validator类，作为context,负责接收用户的请求并委托给strategy对象************** var validator=function()&#123; this.cache=[]; &#125; validator.prototype.add=function(dom,rule,errorMsg)&#123; var self=this; var arr=[]; this.cache.push(function()&#123; arr.unshift(dom.value); arr.push(errorMsg); return strategies[rule].apply(dom,arr); &#125;) &#125;; validator.prototype.start=function()&#123; for(var i=0,validatorFunc;validatorFunc=this.cache[i++];)&#123; var msg=validatorFunc(); if(msg)&#123; return msg; &#125; &#125; &#125; //**************************客户调用代码******************************************** var registerForm = document.getElementById(&apos;registerForm&apos;); var validataFunc=function() &#123; var validator=new validator(); validator.add(registerForm.userName,&apos;isEmpty&apos;,&apos;用户名不能为空&apos;); validator.add(registerForm.phoneNumber,&apos;isMobile&apos;,&apos;手机号码格式不正确&apos;); var errorMsg=validator.start(); return errorMsg; &#125; registerForm.onsubmit=function()&#123; var errorMsg=validataFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http基础知识]]></title>
    <url>%2F2017%2F06%2F26%2Fhttp%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Http基础知识介绍定义：基于文本的、用来在因特网中传输数据的协议。基于tcp/ip协议。Web的开发者们至少应该关注HTTP请求的两个方面：1.请求的目的是获取资源2.HTTP是一个无状态的协议。 1.资源 访问资源首先需要使用URL。它指明了要使用的协议、服务器地址、要在服务器访问的特定文件。 HTTP中资源具体而言就是：作为对象请求的响应，服务器总是会往客户端(用户代理)返回一些东西。这些东西可能是直接响应，也可能是间接响应。直接响应会把请求的资源返回，例如一张图片、一个HTML文档。间接响应会返回请求在指定资源上执行的结果，例如是一个告知操作成功失败的界面，或者一个状态码。 2.无状态 HTTP是一种无状态协议，因为每个请求/响应周期都是独立的，服务器无法通过HTTP协议来判断多个请求是否来自同一个用户代理。因此，许多web服务器引入了‘会话’(Session)的概念。‘会话概念’的引入使得服务器可以得以在多个请求之间存放状态。通常，不通的会话是通过客户端和服务器之间反复传递一二独一无二的秘钥(通常称为会话ID)，通常使用cookies来维护会话ID 会话的实现机制：cookie与session是各种教材，网上文章所介绍到的与HTTP会话相关的两个内容。这两者较常见的解释是：cookie存在在浏览器，session存储在服务器中。但实际上这是一种不严谨的说法。实际上会话的实现机制是：首先，用户端向服务端发送一个请求，服务端接收到请求（这里忽悠无须会话控制的情况）后，初始化会话，生成相应的会话信息，核心是会话ID，把会话ID发送给客户端，客户端接收到这个会话ID，把它存储起来，下一次发送请求的时候，附带着这个会话ID一起发送给服务端，服务端只要根据这个会话ID，就知道是谁**了。 对于如何存储会话ID，服务端与客户端是不同的，服务端存储会话ID有多种方式，常见的有本地存储，如：普通文本，文本名就是会话ID。对于文件系统，同一目录下，同一文件名只允许唯一一个文件，那么使用会话ID作为文件名是可以做到唯一确定会话的。除了本地文件存储，还可以使用memcache、redis、或者Mysql之类的数据库存储，即使用第三方数据库进行存储。只有一个原则：存储的会话ID必须是唯一的。客户端对于会话信息的存储就是使用“域”，不同的域拥有独立的会话。客户端以域相关信息作为文件标识符创建会话文件（客户端存储）对会话信息进行存储，其中域与会话ID结合就能唯一确定服务端，并且确定会话。浏览器是最常见的HTTP客户端，浏览器存储会话信息，是使用cookie文件的，里面保存着cookieE信息，而服务端返回的会话ID也存储在里面。会话ID存储在cookie文件中是一般情况下的，而cookie信息是作为HTTP头发送给服务端的，也就是说这种情况下，会话ID是附带在请求头中。粗糙地，可理解为服务端返回给客户端的会话ID是存储在COOKIE文件中的 请求类型原理实际上，客户端可以往服务器发送的请求有8种。不同的请求类型根据其在请求中指定的发送方法来辨别。HTTP请求方法有包括：GET,HEAD,POST,PUT,DELETE,TRACE,OPTIONS,CONNECT。常用的有get,post,head方法。一般来说，get一般用于获取/查询资源信息，而post一般用于更新资源信息。 1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 (1)这里所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 * 注意：这里安全的含义仅仅是指是非修改信息。 (2)幂等的意味着对同一URL的多个请求应该返回同样的结果 2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求 方法的区别原理性的问题，我们再从表面现像上面看看GET和POST的区别： 1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连。POST把提交的数据则放置在是HTTP包的包体中。 2.POST的安全性要比GET的安全性高，在地址栏看不到。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存 3.GET方式提交的数据是有限制的（因为其参数通过URL传递，而浏览器对于URL的长度限制为1024个字节），这里的限制是特定的浏览器和服务器对它的限制。理论上POST没有限制，可传较大量的数据。 HTTP消息格式一个HTTP周期由请求和响应构成，因此HTTP消息格式分为请求消息格式和响应消息格式，通常情况下，浏览器或者Ajax的XMLHttpRequest对象会为我们格式化这些消息。 请求消息格式： 1.起始行。定义使用的方法，资源和协议。字段之间用一个空格隔开。 2.首部行(可以没有也可以多个)。每行规定一个首部，包含首部名、冒号、至少一个空白字符，以及首部值。 3.一个可选的请求消息正文。它的解释方法取决于它的使用方法。 示例： 123456789101112131415161718192021222324********请求头*******POST /some/path/folder/haha.html HTTP/1.1&lt;CRLF&gt;Host: www.haha.com: 80&lt;CRLF&gt;//必须是域名，不能是IP地址Connection: keep-alive//告诉服务器客户端可以接受什么类型文件Accept: text/html,application/xhtml+xml//指定了客户端提交给服务器的数据类型，这里multipart/form-data(二进制数据)是其中一种Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryqrt*******（随机的边界分割符）User-Agent: somebody&apos;s browser &lt;CRLF&gt;//浏览器类型********请求主体********************-------WebKitFormBoundaryqrt*******Content-Disposition: 提交数据-------WebKitFormBoundaryqrt*******如果是文件上传的话 响应消息格式:1.起始行。定义使用的协议、响应状态码和一个原因字符串(状态码解释)。 2.首部行(可以没有也可以多个)。每行规定一个首部，包含首部名、冒号、至少一个空白字符，以及首部值。 3.返回的数据。它的解释取决于所使用的方法。 示例： 1234567891011HTTP/1.1 200 OK&lt;CRLF&gt;Content-type: text/html&lt;CRLF&gt;Content-length: 55&lt;CRLF&gt;&lt;html&gt; &lt;body&gt; haha here! &lt;/body&gt;&lt;/html&gt; HTTP中的状态码有很多，常见的有200-OK,403-Forbidden(禁止访问),404-Not Found(文件找不到),500-Internal Server Error 使用Ajax生成请求示例 12345678new Ajax.Request(&apos;/the/server/side/resource&apos;,&#123; method:&apos;post&apos;, requestHeaders: [ &apos;x-headerName1&apos;,&apos;headValue1&apos;, &apos;x-headerName2&apos;,&apos;headValue2&apos; ], poseBody: Form.serialize(document.someForm)&#125;) 这段代码中第一个参数定义了资源地址，另外一个参数对象则定义了方法、请求首部和要发送的POST正文。 通过Ajax获取响应利用Ajax的XMLHttpRequest对象获取响应，并允许使用该对象的一些方法和属性对响应进行处理。 方法属性列表： responseText:成功请求后的响应文本。 responseXML:此属性包含一个XML DOM，仅仅当响应首部中规定的内容类型为text/html时有效。 status: 响应状态码 statusText: 状态原因消息 getAllHeaders():返回所有响应的首部 getHeader(name):返回指定响应首部 HTTP协议1.0与HTTP协议1.1的主要区别在于引入connection:keep-alive,使得连接中断后仍然能够保证一段时间的连接。其他的区别还包括：支持持久连接，虚拟主机，代理连接]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式基础(2)]]></title>
    <url>%2F2017%2F06%2F26%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)%2F</url>
    <content type="text"><![CDATA[闭包闭包在js中的作用：1.封装变量 2.延续局部变量的寿命 利用闭包解决onclick时间被异步触发123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++) &#123; node[i].onclick=function()&#123; console.log(i); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 无论点击那个div,都会出现5，因为for循环早已结束，而onclick为异步调用。 解决方法 将每次循环的i值封闭起来。当在事件函数中顺着作用域链从内而外查找变量i时，会先找到被封闭在闭包环境中的i12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++) &#123; (function(i)&#123; node[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i) &#125;&lt;/script&gt;&lt;/html&gt;结果：2 3 闭包优缺点： 优点：将变量封闭在闭包中，是因为后续可能依然还会用到。缺点：会带来内存泄漏的问题。 高阶函数充分条件： 1.函数可以作为一个参数被传递 函数作为参数传递案例包括：1.回调函数 2.Array.prototype.sort()方法 2.函数可以作为返回值输出。 1.判断数据类型1234567891011121314151617181920Object.prototype.toString.call([1]);&quot;[object Array]&quot;Object.prototype.toString.call(&#123;a:1&#125;);&quot;[object Object]&quot;Object.prototype.toString.call(&apos;haha&apos;);&quot;[object String]&quot;Object.prototype.toString.call(1);&quot;[object Number]&quot;Object.prototype.toString.call(true);&quot;[object Boolean]&quot;Object.prototype.toString.call(undefined);&quot;[object Undefined]&quot;Object.prototype.toString.call(null);&quot;[object Null]&quot; 3.实现AOP编程 js中的AOP实现一般是将一个函数‘动态织入’另外一个函数。123456789101112131415161718192021222324252627282930313233Function.prototype.before = function(beforefn)&#123; var self=this; //保存原函数的引用 return function()&#123; beforefn.apply(this,arguments); //修正this，执行新函数 return self.apply(this,arguments);//修正this，执行原函数 &#125;&#125;var func=function()&#123;console.log(2)&#125;;func = func.before(function()&#123;console.log(3)&#125;);func()结果：3 2Function.prototype.before = function(beforefn)&#123; var self=this; return function()&#123; beforefn.apply(null,arguments); return self.apply(null,arguments); &#125;&#125;;Function.prototype.after = function(afterfn)&#123; var self = this; return function()&#123; self.apply(this,arguments); return afterfn.apply(this,arguments); &#125;&#125;var func=function()&#123;console.log(2)&#125;;func = func.before(function()&#123;console.log(3)&#125;).after(function()&#123;console.log(1)&#125;);func() 3 2 1]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式基础(1)]]></title>
    <url>%2F2017%2F06%2F25%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. 封装 1.封装数据：Js中并没有提供private,public,protected等关键字来提供访问权限，只能后依赖变量的作用域特性，而且只能模拟出public和private两种数据封装特性。除了ES6中的let属性，一般可以通过函数来创建作用域。 2.封装实现：封装使得对象内部的变化对外是透明的，其他对象不关心对象内部的实现。封装使得对象之间的耦合变松散，对象之间只通过api接口通信。 3.封装的作用：把系统中稳定不变的部分和容易变化的部分分离开，在系统演变过程中，只需替换那些容易变化的部分。 二. 原型模式和基于原型继承的js对象系统 js中不存在类的概念，对象也并非从类中创建出来，所有的js对象都是从某个对象上克隆出来的。如果对象A是由对象B克隆出来的，则成B为A的原型。 原型编程的规则: 1.所有数据都是对象。 事实上，js中的根对象是Object.prototype对象，所有的对象都是从他克隆出来的。Object.prototype的原型是null。123var obj=&#123;&#125;;console.log(Object.getPrototypeOf(obj)===Object.prototype);VM217:2 true 2.要得到一个对象，不是通过实例化类，而是找到一个对象作为他的原型 js中的函数既可以作为普通函数被调用，可以作为构造器函数被调用，当用new运算符来调用函数时，此时函数是一个构造器。用运算符来创建对象的过程中，实际上也是先克隆Object.prototype对象，再进行一些额外的其他操作。 3.对象会记住它的原型 对象会记住它的构造器原型12345678910var a= new Object();console.log(a.__proto__===Object.prototype);VM353:2 truefunction haha()&#123;return &apos;hahha&apos;&#125;;var a = new haha();console.log(a.__proto__===haha.prototype);VM507:5 true 4.如果对象无法响应某个请求，它会把这个请求委托给它自己的原型 这规则是原型继承的精髓所在，当一个对象无法响应某个请求的时候，会把这个请求顺的原型链传递下去。 虽然js中的对象最初都是由Object.prototype对象克隆出来的，但是对象构造器的原型并不局限于Object.prototype，也可以有选择性的把对象a的构造器原型指向对象b,从而达到继承的效果。12345678910111213var a=function()&#123;&#125;var A=new a();var obj=&#123;name:&apos;haha&apos;&#125;;a.prototype=obj;console.log(A.name);VM658:5 var a=function()&#123;&#125;var obj=&#123;name:&apos;haha&apos;&#125;;a.prototype=obj;var A=new a();console.log(A.name);VM659:6 haha 三. this、call、apply的作用 thisjs中的this总是指向一个对象，具体指向哪个对象，是在运行时基于函数的执行环境而动态绑定的，而非函数声明时的环境。 this的指向1.作为对象的方法调用 当函数作为对象的方法被调用时，this指向该对象。123var obj =&#123;a:1,getA:function()&#123;console.log(this==obj)&#125;&#125;;obj.getA();VM200:1 true 2.作为普通函数调用123456789var obj =&#123;a:1,getA:function()&#123;console.log(this==obj)&#125;&#125;;var getB=obj.getA;getB();VM229:1 falsevar obj =&#123;a:1,getA:function()&#123;console.log(this)&#125;&#125;;var getB=obj.getA;getB();VM236:1 Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; 当函数不作为对象的属性被调用时，也就是常说的普通函数方式，此时的this总是指向全局对象 3.构造器调用12345var a =function()&#123;this.name = &apos;haha&apos;&#125;;var b = new a;console.log(b.name);VM209:4 haha 当用new调用函数时，该函数会返回一个对象，通常情况下，构造器里面的this指向返回的这个对象 但是，如果构造器显示的返回一个object类型的对象，则此次运算结果返回这个显示对象1234567var a =function()&#123;this.name = &apos;haha&apos;;return &#123;name:&apos;hehe&apos;&#125;&#125;var b = new a();console.log(b.name);VM308:6 hehe 4.Funcition..prototype.call和Function.prototype.apply调用。 与普通函数相比，call()和apply()方法可以动态的改变传入函数的this。12345var obj1=&#123;name:&apos;haha&apos;,getName:function()&#123;return this.name&#125;&#125;;var obj2=&#123;name:&apos;heihei&apos;&#125;;console.log(obj1.getName.apply(obj2));console.log(obj1.getName.apply(obj2));VM500:3 heihei apply &amp;&amp; callapply()与call()方法唯一不同处在于传入参数的形式不同。 apply()接受两个参数，第一个参数是传递给这个函数用来绑定函数内部this的值，第二个参数可以数组或者类数组（传递给这个函数的所有参数），apply()方法把这个数组中的元素作为参数传递给被调用的函数。 call()方法接受的参数数量不固定，与apply()相同的是，第一个参数也是参数代表函数体内的this的指向，之后的每一个参数依次被传入函数。123456789101112131415var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.apply(null, [1,2,3]);6var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, [1,2,3]);1,2,3undefinedundefinedvar fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, 1,2,3);6var fun = function(a,b,c)&#123;console.log(a+b+c)&#125;;fun.call(null, 1,2,4,9);7 如果函数第一个参数指向null,则默认函数体内的this指向默认的宿主对象，在浏览器中是window:123var fun = function(a,b,c)&#123;console.log(this)&#125;;fun.call(null, 1,2,4,9);Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; apply()与call()用途1.改变this的指向1234var getName=function()&#123;return this.name;&#125;var obj1=&#123;name:&apos;hahh&apos;&#125;;getName.call(obj1);&quot;hahh&quot; 将函数getName的this指向对象obj1; 2.使用其他对象的方法 1.借用构造函数：123456var A=function(name)&#123;this.name=name&#125;;var B=function()&#123;A.apply(this,arguments);&#125;B.prototype.getName=function()&#123;return this.name;&#125;;var b=new B(&apos;heihei&apos;);console.log(b.getName());heihei 2.对于函数的参数列表arguments(一个类数组对象)，并非一个真正的数组。可以通过apply()或者call()方法来增加所需用到的方法。1234567891011121314151617(function()&#123;Array.prototype.push.apply(arguments,[3]);console.log(arguments);&#125;)(1,2);[1, 2, 3, callee: function, Symbol(Symbol.iterator): function](function()&#123;Array.prototype.push.call(arguments,3);console.log(arguments);&#125;)(1,2);[1, 2, 3, callee: function, Symbol(Symbol.iterator): function]var a=&#123;&#125;;Array.prototype.push.call(a,&apos;haha&apos;);console.log(a);Object &#123;0: &quot;haha&quot;, length: 1&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(5)]]></title>
    <url>%2F2017%2F06%2F17%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5%20end)%2F</url>
    <content type="text"><![CDATA[高级算法1 动态规划动态规划的解决方案与递归相反，它是通过从底部开始解决一个个小问题，然后合并成一个大的解决方案,从而解决一个大的问题 示例 1fiboancci 对比 递归方法12345678910function recurFib(n)&#123; if(n&lt;2)&#123; return n; &#125; else &#123; return recurFib(n-1)+ recurFib(n-2); &#125;&#125;recurFib(10);55 动态规划方法12345678910111213141516171819function recurFib(n)&#123; var value=[]; for(var i=0;i&lt;=n;i++)&#123; value[i]=0; &#125; if(n==1||n==2)&#123; return 1; &#125; else &#123; value[1]=1; value[2]=1; for(var j=3;j&lt;=n;j++)&#123; value[j]=value[j-1]+value[j-2]; &#125; return value[n] &#125;&#125;recurFib(10);55 示例 2寻找公共子字符串的动态规划实现12345678910111213141516171819202122232425262728293031323334353637383940function lcs(word1,word2)&#123; var max = 0; var index = 0; var lcsarr = new Array(word1.length+1); for(var i=0;i&lt;word1.length+1;i++)&#123; lcsarr[i]=new Array(word2.length+1); for(var j=0;j&lt;word2.length+1;j++)&#123; lcsarr[i][j]=0; &#125; &#125; for(var i=0; i&lt;=word1.length;i++)&#123; for(var j=0; j&lt;=word2.length;j++)&#123; if(i==0||j==0)&#123; lcsarr[i][j]=0; &#125;else&#123; if(word1[i-1]==word2[j-1])&#123; lcsarr[i][j]=lcsarr[i-1][j-1]+1; &#125;else&#123; lcsarr[i][j]=0; &#125; &#125; if(max&lt;lcsarr[i][j])&#123; max = lcsarr[i][j]; index = i; &#125; &#125; &#125; var str = &apos;&apos;; if(max==0)&#123; return &quot;&quot;; &#125;else&#123; for(var i=index-max;i&lt;=max;i++)&#123; str =str + word2[i] &#125; return str; &#125;&#125;lcs(&apos;abbcc&apos;,&apos;dbbcc&apos;);结果:&quot;bbcc&quot; 示例3背包的问题利用贪婪算法解决，贪婪算法核心思想为解决找到局部次优解。 解决部分背包问题的方案： 1.设背报容量为W，物品价格为v,物品重量为w。 2.根据v/w的比例对物品排序。 3.按比例降序方法来建立对应数组。 4.尽可能的放过多的物品。12345678910111213141516171819function ksack(values,weights,capacity)&#123; var load=0; var i=0; var w=0; while(load&lt;capacity&amp;&amp;i&lt;values.length)&#123; if(weights[i]&lt;=(capacity-load))&#123; w = w + values[i]; load = load + weights[i]; &#125;else&#123; var r=(capacity-load)/weights[i]; w = w + r * values[i]; load = load +weights[i]; &#125; i++; &#125;return w;&#125;ksack([13,10,11,4,5],[9,7,8,3,4],16);23 背包问题的递归方法123456789101112131415function ksack(capacity,size,value,n)&#123; if(n==0||capacity==0)&#123; return 0; &#125; if(size[n-1]&gt;capacity)&#123; return ksack(capacity,size,value,n-1); &#125;else&#123; return max(value[n-1]+ksack(capacity-size[n-1],size,value,n-1),ksack(capacity,size,value,n-1)) &#125;&#125;function max(a,c)&#123; return (a&gt;c)?a:c;&#125;ksack(16,[3,4,7,8,9],[4,5,10,11,13],5)23]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的设计模式]]></title>
    <url>%2F2017%2F06%2F17%2Fjs%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[函数声明&amp;&amp;函数表达式函数声明Function Declaration 可以定义命名的函数变量，而无需给变量赋值。Function Declaration 是一种独立的结构，不能嵌套在非功能模块中。可以将它类比为 Variable Declaration（变量声明）。就像 Variable Declaration 必须以var开头一样，Function Declaration 必须以function开头。 eg123function test()&#123; return 3&#125; 函数声明时，函数名在自身作用域和父作用域内是可获取的（否则就取不到函数了）。 函数表达式Function Expression 将函数定义为表达式语句（通常是变量赋值）的一部分。通过 Function Expression 定义的函数可以是命名的，也可以是匿名的。Function Expression 不能以function开头 eg1234567891011var a = function()&#123; return 3;&#125;var a = function test()&#123; return 3&#125;(function test()&#123; return 3;&#125;)(); 两者的区别JavaScript 解释器中存在一种变量声明被提升hoisting的机制，也就是说变量（函数）的声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。 eg:Q1123456789101112function bling()&#123; function test()&#123; return 3 &#125;; return test(); function test()&#123; return 8; &#125; &#125;console.log(bling());结果为:8 由于函数声明的变量提升，该程序经过解释器解释后为 1234567891011 function bling()&#123; function test()&#123; return 3 &#125;; function test()&#123; return 8; &#125; return test(); &#125; eg:Q21234567891011function foo()&#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125;console.log(foo());结果为:3 该程序经过解释器解释后为：1234567function foo()&#123;//变量声明提升var bar = undefined;var bar = undefined;bar = function()&#123;return 3&#125;;return bar();&#125; eg:Q3123456789101112console.log(foo());function foo()&#123; var bar = function() &#123; return 3; &#125;; return bar(); var bar = function() &#123; return 8; &#125;;&#125;结果为:3这次是函数foo()的声明提升了 eg:Q4123456789101112function foo()&#123; return bar(); var bar = function() &#123; return 3; &#125;; var bar = function() &#123; return 8; &#125;;&#125;console.log(foo());结果为：Uncaught TypeError: bar is not a function因为这里没有函数提升]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(4)]]></title>
    <url>%2F2017%2F06%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(4)%2F</url>
    <content type="text"><![CDATA[排序算法简单排序算法1 冒泡排序1234567891011121314151617function bubble(arr)&#123; var length = arr.length; var temp; for(var i =0; i&lt;length;i++)&#123; for(var j=length-1;j&gt;i;j--)&#123; if(arr[i]&lt;=arr[j])&#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var a = [3,2,4,1];bubble(a);结果为:[4, 3, 2, 1] 2 选择排序1234567891011121314151617function select(arr)&#123; var length = arr.length; var temp; var min for(var i =0; i&lt;length-2;++i)&#123; min = i; for(var j=i+1;j&lt;length-1;++j)&#123; if(arr[j]&lt;=arr[min])&#123; min = j; &#125; temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr;&#125; 高级排序算法1 希尔排序希尔排序在插入排序的基础上做了一些改变，它会首先比较距离较远的元素而非距离较近的元素。然后不断缩小元素之间的比较距离直到处理到数据集末尾，这时候算法开始比较相邻元素。1234567891011121314151617181920212223function shellSort(arr)&#123;var length = arr.length;var h=1;while(h&lt;length/3)&#123; h = 3*h +1;&#125;while(h&gt;=1)&#123; for(var i=h; i&lt;length;i++)&#123; for(var j=i;j&gt;=h&amp;&amp;arr[j]&lt;arr[j-h];j=j-h)&#123; if(arr[j]&lt;arr[j-h])&#123; temp = arr[j]; arr[j] = arr[j-h]; arr[j-h] = temp; &#125; &#125; &#125; h=(h-1)/3;&#125;return arr;&#125;var a =[92,31,5,96,44,88,34,57,44,72,20,83,4,623,12,12,932,54];shellSort(a);结果为： [4, 5, 12, 12, 20, 31, 34, 44, 44, 54, 57, 72, 83, 88, 92, 96, 623, 932] 2 快速排序首先在列表中选择一个基准值，数据围绕基准值进行分类，将小于基准值的放在基准值的左边，大于基准值的放在基准值的右边。快速排序对于大型数据集合非常实用，在处理小型数据集合时性能反而会下降12345678910111213141516171819function fastSort(arr)&#123;if(arr.length==0)&#123; return[];&#125;var lesser = [];var greater = [];var standard = arr[0];for(var i=1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;standard)&#123; lesser.push(arr[i]) &#125;else&#123; greater.push(arr[i]); &#125;&#125;return fastSort(lesser).concat(standard,fastSort(greater))&#125;var a =[68,80,12,95,70,97,27,88,93];fastSort(a);结果：[12, 27, 68, 70, 80, 88, 93, 95, 97]]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(3)]]></title>
    <url>%2F2017%2F06%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(3)%2F</url>
    <content type="text"><![CDATA[二叉树与二叉查找树树是一种非线性的数据结构，以分层的方式存储数据。二叉树由节点构成，在这里需要定义一个Node对象123456789function Node(data,left,right)&#123; this.data = data; this.left = left; this.right = right; this.show = show;&#125;function show()&#123; return this.data;&#125; 在这里可以创建一个类来表示二叉查找树(BST),该类的构造函数将根节点初始化为null,以此创建一个空节点。此外，还有一个insert()方法，用来向树中增加新节点。1234function BST()&#123; this.root = null; this.insert = insert;&#125; 具体的insert()方法实现思想： (1)判断有无根节点，如果没有根节点，将插入点直接设为根节点，结束。 (2)如何已有根节点，将根节点设为当前节点，比较待插数据与根节点的大小，如果小于当前节点，设新的当前节点为原节点的做节点，否则设为右节点。 (3)知道当前节点的做节点或右节点为空时，插入数据，完成算法。具体实现：12345678910111213141516171819202122232425262728function insert(data)&#123; var n = new Node(data,null,null); if(this.root==null)&#123; this.root = n; &#125; else&#123; var current = this.root; var parent; while(true)&#123; parent = current; if(current.data&gt;data)&#123; current = current.left; if(current==null)&#123; parent.left = n; break; &#125; &#125; else&#123; current = current.right; if(current==null)&#123; parent.right = n; break; &#125; &#125; &#125; &#125;&#125; 常用的遍历二叉查找树的方法有三种：中序、先序，后序。中序：即为升序排列。左，中，右先序：从最左边开始：中，左，右。后序：从最左边开始：左，右，中。]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法(2)]]></title>
    <url>%2F2017%2F06%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(2)%2F</url>
    <content type="text"><![CDATA[栈js中实现一个栈的低层数据结构是数组。 利用栈的几种情况示例1:数制之间的相互转换12345678910111213141516function chang(num,base)&#123; var arr=[]; var result = &quot;&quot;; do&#123; arr.push(num%base); num = num/base; &#125;while(num&gt;=1); arr.reverse(); for(var i=0;i&lt;arr.length;i++)&#123; result = result + arr[i]; &#125; return result;&#125;var haha = chang(256,8);console.log(haha);结果:400 示例2:判断回文123456789101112function back(s)&#123; var regexp=/[a-z]/gi;//全局匹配不区分大小写 var arr=s.match(regexp); var arrRevs=arr.reverse(); if(arr.join(&apos;&apos;)==arrRevs.join(&apos;&apos;))&#123; return true; &#125; return false;&#125;var str = &apos;A man, a plan, a canal: Panama&apos;; console.log(back(str));结果：true 队列队列先进先出，可以利用js中的push()和shift()方法从尾部增加，从头部删除。 利用队列的示例基数排序基数排序的基本原理：从个位，十位，百位的数字依次进行排序。12345678910111213141516171819202122232425262728293031323334353637383940414243//sort函数功能将数组根据个位或者十位的大小进行分组function sort(nums,digital,queue)&#123; for(var i=0;i&lt;nums.length;i++) &#123; if(digital==1)&#123; queue[nums[i]%10].push(nums[i]); &#125; else&#123; queue[Math.floor(nums[i]/10)].push(nums[i]); &#125; &#125; &#125;//将前面的排序结果选出，准备下次排序function out(queue)&#123; var arr=[]; for(var i=0;i&lt;10;i++)&#123; if(queue[i].length!=0)&#123; var h=queue[i].length; for(var j=0;j&lt;h;j++)&#123; arr.push(queue[i].shift()); &#125; &#125; &#125; return arr;&#125;var nums=[45,72,93,51,21,16,70,41,27,31];var queues=[];for(var i =0;i&lt;10;i++)&#123; queues[i]=[];&#125;sort(nums,1,queues);console.log(queues[1]);var temp = out(queues);console.log(temp);sort(temp,10,queues);var result = out(queues);console.log(result);结果: [51, 21, 41, 31] [70, 51, 21, 41, 31, 72, 93, 45, 16, 27] [16, 21, 27, 31, 41, 45, 51, 70, 72, 93] 链表一种不同于数组的一种底层存储的数据结构基于对象的列表包含两个类，分别为Node类和LinkedLise类；Node类的构造函数有两个属性1234function Node(element)&#123; this.element = element; this.next = null;&#125; LinkedList类的构造函数只有一个属性，此外还包含链表中的一些方法1234567function()&#123; this.head=new Node(&apos;head&apos;); this.find=find; this.insert=insert; this.remove=remove; this.display=display; &#125; 散列使用散列存储数据时，通过一个高效的散列函数将键映射到一个数字，这个数字的长度是0到散列表的长度。当散列对于多个输入同时产生同样的输出时，就会产生碰撞。解决散列表的碰撞问题的方法有1.开链法2.线性探测法。开链法：实现散列表的底层数组中，每个数组元素有都是一个新的数据结构，比如数组，这样就能存储多个键。线性探测法：检查散列表的下一个位置是否为空，如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空位置为止。 两种方法比较当数据量比较大的时候，存储数据使用数组比较大时，使用线性探测法比较好(数组大小是待存数据的两倍或两倍以上时)，其他使用开链法比较好。]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据结构与算法]]></title>
    <url>%2F2017%2F06%2F14%2Fjs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组数组中常用方法1. 判断数组方法 js中数组对外类型显示为object,因而判断数组的方式可以是调用Array.isArray();来判断数组。 示例1: var arr=[];console.log(Array.isArray(arr)) 结果:true 2.查找元素方法 数组查找方法有indexOf();该函数返回第一个与参数相同的元素的索引位置。laseIndexOf()该函数返回参数相同元素的最后的索引位置。 示例2:12var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];console.log(a.indexOf(&apos;you&apos;),a.lastIndexOf(&apos;you&apos;));结果:0 6 3. 数组的字符串表示 数组的字符串表示方法有join()和toString(); 示例3:123456var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];a.join();结果:&quot;you,need,to,live,a,life,you,will,remember&quot;var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];a.toString();结果:&quot;you,need,to,live,a,life,you,will,remember&quot;var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;];a.join(&apos;&apos;);结果:s&quot;youneedtolivealifeyouwillremember&quot; 4. 从已有数组创建新的数组 concat()以及splice()方法都可以从已有数组中创建新的数组 示例4:123456789101112131415161718192021var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];a.concat(b);结果:[&quot;you&quot;, &quot;need&quot;, &quot;to&quot;, &quot;live&quot;, &quot;a&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;, &quot;I&quot;, &quot;remember&quot;, &quot;that&quot;, &quot;she&quot;, &quot;told&quot;, &quot;me&quot;]删除数组元素var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];a.splice(3);结果:[&quot;live&quot;, &quot;a&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;]var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];console.log(a.splice(3,2),a);结果: [&quot;live&quot;, &quot;a&quot;] (7) [&quot;you&quot;, &quot;need&quot;, &quot;to&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;]增加数组元素var a=[&apos;you&apos;,&apos;need&apos;,&apos;to&apos;,&apos;live&apos;,&apos;a&apos;,&apos;life&apos;,&apos;you&apos;,&apos;will&apos;,&apos;remember&apos;]; var b=[&apos;I&apos;,&apos;remember&apos;,&apos;that&apos;,&apos;she&apos;,&apos;told&apos;,&apos;me&apos;];console.log(a.splice(3,1,&apos;haha&apos;),a);结果:[&quot;live&quot;] (9) [&quot;you&quot;, &quot;need&quot;, &quot;to&quot;, &quot;haha&quot;, &quot;a&quot;, &quot;life&quot;, &quot;you&quot;, &quot;will&quot;, &quot;remember&quot;] 5.也可以利用push(),unshift(),pop(),shift()方法改变数组 push()方法从数组尾部添加一个元素，pop()方法从尾部删除一个元素，unshift()方法从头部增加一个元素，shift()方法从头部删除一个元素，以上方法均为返回该元素。 6. 迭代器方法 迭代器方法接受一个函数作为参数，对数组中每个元素应用该函数。 (1)不生成新数组的迭代器方法 forEach()方法接受一个函数作为参数，对数组中每个元素应用该函数。123456[1,24,4].forEach(function(n)&#123; console.log(n*n)&#125;);结果:157616 every()方法接受一个返回值为布尔类型的函数，对数组中每个元素使用该该函数，每个元素返回结果都为true时，该方法返回true，否则返回false123456function even(num)&#123; if(num%2==0) return true&#125;;[1,24,3].every(even);结果:false some()方法与every()方法类似，但是只要某个元素满足条件返回true,则该方法返回true12345function even(num)&#123; if(num%2==0) return true&#125;;[1,24,3].some(even); reduce()接受一个函数，返回一个值。它会从一个累加值开始，不断地对累加值和数组中的后续元素调用该函数12345function SUM(sum,currentValue)&#123; return sum+currentValue&#125;;[1,24,3].reduce(SUM)结果:28 (2)生成新数组的迭代器方法 map()方法与forEach()方法类型，只是返回一个新的数组1234var nums=[1,24,4];var newarr=nums.map(function(n)&#123;return(n*n)&#125;);console.log(nums,newarr);结果:[1, 24, 4] [1, 576, 16] filter()方法与every()方法类似，但是其返回的为满足条件为true时的新数组12345678910function grade(nums)&#123; if(nums&gt;60) return true&#125;;for(var i=0;i&lt;10;i++)&#123; var marks=[]; marks[i]=Math.floor(Math.random()*101);&#125;marks.filter(grade);结果:[97]]]></content>
      <categories>
        <category>js数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中应该掌握的知识2.0]]></title>
    <url>%2F2017%2F06%2F12%2FJS%E4%B8%AD%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%862.0%2F</url>
    <content type="text"><![CDATA[柯里化(Currying)函数柯里化的含义:对于每一个逻辑参数，柯里化函数会逐渐返回已配置的函数，直到所有的参数用完。 示例1：123456789function Currying(n) &#123; return function(d)&#123; return n/d; &#125; &#125;;var result = Currying(10);result(2);结果:5 示例2:1234567891011function Currying(fun)&#123; return function(secondPara)&#123; return function(firstPara)&#123; return fun(firstPara,secondPara); &#125; &#125;&#125;function div(n,d)&#123;return n/d&#125;; var result = Currying(div)(2); result(10);结果:5]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中应该掌握的知识]]></title>
    <url>%2F2017%2F06%2F11%2FJS%E4%B8%AD%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[闭包相关知识闭包的定义：闭包是一个函数，用于捕获作用域内的外部绑定函数调用之闭包:示例1:123456789101112131415var haha=&apos;hello&apos;; function test(n)&#123; var haha=&apos;hi&apos;; return function(n)&#123; return haha+n; &#125; &#125;console.log(test());结果: function (n)&#123; return haha+n; &#125; var result1 = test(); console.log(result1(&apos;123&apos;))结果: hi123 当然这里的参数n可以是任何类型，数组，对象，函数等。此外，需要注意JS中对于函数的调用和引用的不同 示例2:1234567891011121314151617var haha=&apos;hello&apos;; function test(n)&#123; var haha=&apos;hi&apos;; return function(n)&#123; return haha+n; &#125; &#125;console.log(test);var result1 = test;console.log(result1(&apos;123&apos;))结果: function test(n)&#123; var haha=&apos;hi&apos;; return function(n)&#123; return haha+n; &#125; &#125; apply和call的具体使用 obj.call(thisObj, arg1, arg2, ...); obj.apply(thisObj, [arg1, arg2, ...]); 两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj“继承”了obj的属性和方法。可以看出call和apply是为了动态改变this而出现的。 绑定后会立即执行函数。两者之间唯一区别是apply接受的是数组参数，call接受的是连续参数。 使用示例:示例3:1234567891011121314function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125;add(5,3); //8add.call(sub, 5, 3); //结果8add.apply(sub, [5, 3]); //结果8sub(5, 3); //2sub.call(add, 5, 3); //结果2sub.apply(add, [5, 3]); //结果2 调用原生对象的方法 对象a类似array，但不具备array的slice等方法。使用call绑定，这时候就可以调用slice方法。 示例4:12345var a = &#123;0:1, 1:&quot;yjc&quot;, length: 2&#125;; a.slice(); //结果TypeError: a.slice is not a functionArray.prototype.slice.call(a);//结果[1, &quot;yjc&quot;]]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试题（1）]]></title>
    <url>%2F2017%2F01%2F14%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[行内元素有哪些？块级元素有哪些？CSS的盒模型？行内元素有：a b span I b em img input select strong;块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p;盒模型：由内到外：margin border padding width;2.CSS引入的方式有哪些? link和@import的区别是?（1） i. 使用 LINK标签将样式规则写在.css的样式文件中，再以&lt;link&gt;标签引入。 例如:&lt;link rel=stylesheet type=&quot;text/css&quot; href=&quot;example.css&quot;&gt;ii. 使用@import引入跟link方法很像，但必须放在… 中 例如:&lt;STYLE TYPE=&quot;text/css&quot;&gt;&lt;!-- @import url(css/example.css);--&gt;&lt;/STYLE&gt;iii. 使用STYLE标签将样式规则写在&lt;STYLE&gt;...&lt;/STYLE&gt;标签之中。iv. 使用STYLE属性 v. 使用&lt;span&gt;&lt;/span&gt;标记引入样式（2）两者区别：加载顺序的差别。当一个页面被加载的时候，link引用的css会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。@import可以在css中再次引入其他样式表，比如可以创建一个主样式表，在主样式表中再引入其他的样式表，这样做有一个缺点，会对网站服务器产生过多的HTTP请求，以前是一个文件，而现在却是两个或更多文件了，服务器的压力增大 前端页面由哪三层构成，分别是什么？作用是什么？网页分成三个层次，即：结构层、表示层、行为层。网页的结构层(structural layer)由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”网页的表示层(presentation layer) 由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。网页的行为层(behavior layer)负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript语言和DOM主宰的领域 H5&amp;css3在HTML5平台上，视频，音频，图象，动画，以及同电脑的交互都被标准化。HTML5的技术概览： HTML5新增和移除的元素 HTML5新增了很多多媒体和交互性元素如video, audio，在HTML4当中如果要嵌入一个视频或是音频的话需要引入一大段的代码，还有兼容各个浏览器，而HTML5只需要通过引入一个标签就可以，就像img标签一样方便。 HTML5对表单的支持 HTML5提供了强大的控件类型如url, email, date, tel等，强大的约束属性，如required表示必填，文件上传的accept属性，以及一些表单重复元素模型的支持，HTML5在提交表单的时候还可 以设置提交的方式为XML提交方式，这样服务器端接收到的数据将是XML格式，HTML5的表单被定义为“Web Forms 2.0” CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器 CSS3对于动画的支持 CSS3支持的动画类型有：transform(变换)、transition(过渡)和animation(动画)。你可以对特定的属性设置transition，transiton和animation的区别不大，animation的动画是自己定义的，面向的更多的是脚本开发者，往往更加复杂 如何理解HTML结构的语意化？i. 去掉或样式丢失的时候能让页面呈现清晰的结构ii. 屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页iii. PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）iv. 搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重，页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记v. W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率 谈谈以前端角度出发做好SEO需要考虑什么？ i.了解搜索引擎如何抓取网页和如何索引网页 &amp;nbsp;&amp;nbsp;你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot或叫web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。ii. Meta标签优化 &nbsp;&nbsp;主要包括主题(Title)，网站描述(Description)，和关键词(Keywords)。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。iii.如何选取关键词并在网页中放置关键词 &nbsp;&nbsp;搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。iv.了解主要的搜索引擎 &nbsp;虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。 v.主要的互联网目录 &nbsp;&nbsp;Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。vi.按点击付费的搜索引擎 &nbsp;搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。vii.搜索引擎登录 &nbsp;&nbsp;网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。viii.链接交换和链接广泛度（Link Popularity） &nbsp;&nbsp;网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。ix.标签的合理使用 经常遇到的浏览器的兼容性有哪些？怎么会出现？解决方法是什么？兼容性处理要点i. DOCTYPE影响CSS处理ii. FF: 设置padding后,div会增加height和width， 但IE不会， 故需要用!important多设一个height和widthiii. FF: 支持!important， IE则忽略， 可用!important为 FF 特别设置样式iv. div 的垂直居中问题: vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行v. 在mozilla firefox和IE中的BOX模型解释不一致导致相差2px解决方法： &nbsp;&nbsp;div{margin:30px!important;margin:28px;} 注意这两个margin的顺序一定不能写反，!important这个属性IE不能识别，但别的浏览器可以识别。 所以在IE下其实解释成这样： div{maring:30px;margin:28px} 重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;浏览器差异i.ul和ol列表缩进问题 &nbsp;&nbsp;消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px; 其中margin属性对IE有效，padding属性对FireFox有效。 [注] 经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才 能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。ii.CSS透明问题 &nbsp;&nbsp;IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。 &nbsp;&nbsp;FF：opacity:0.6。 [注] 最好两个都写，并将opacity属性放在下面。iii.CSS圆角问题 &nbsp;&nbsp;IE：ie7以下版本不支持圆角。iv.cursor:hand VS cursor:pointer &nbsp;&nbsp;问题说明：firefox不支持hand，但ie支持pointer ，两者都是手形指示。 &nbsp;&nbsp;解决方法：统一使用pointerv.字体大小定义不同 &nbsp;&nbsp;对字体大小small的定义不同，Firefox中为13px，而IE中为16px，差别挺大。 &nbsp;&nbsp;解决方法：使用指定的字体大小如14px。 &nbsp;&nbsp;并列排列的多个元素（图片或者链接）的div和div之间，代码中的空格和回车在firefox中都会被忽略，而IE中却默认显示为空格（约3px）。 ajax是什么？ajax的交互模型？同步和异步的区别？如何解决跨域问题？ajax(动态网站静态化)伴随的goole 的推动，越来越多的站点开始使用了，在开大ajax(动态网站静态化)程序的时候会遇到很多的问题，主要有以下几个方面： i. 跨浏览器问题ii. 历史后退状态问题iii. 跨域问题 跨浏览器的问题因为现在有很多的开元的框架已经解决了，我们无需为此而烦恼。历史后退状态问题我们可以使用一个数组来保存历史纪录，然后把这些数据村到历史对象中去，中的也可以解决，并且还有很多的开元框架给与支持，这样问题就不是很大 跨域的问题就不是很好的解决，但是还是有办法的，一下给出一些基本的解决方案供大家选择： &nbsp;&nbsp;i.使用代理，你可以使用web端的程序编写代理程序，把所有的ajax(动态网站静态化)请求的数据进行转发，web程序可以使php(做为现在的主流 开发语言)，jsp(SUN企业级应用的首选)，asp等所有的编程语言。相信大家对这种方式一定很熟悉，这里就不详细的介绍了&nbsp;&nbsp;ii.使用iframe的方式来定势的刷新叶面，这种方式只是取得数据来显示，并不能真正的和求得的数据进行交互，转化成本页面的动态数据，不是很可取，应用也不是很多。&nbsp;&nbsp;iii.使用apache(Unix平台最流行的WEB服务器平台)的代理功能，主要就是apache(Unix平台最流行的WEB服务器平台)的方向代理， 或者是url从定向，你也可以把其他的站点直接的挂在自己的网站上，这样的方式可能会友邦权的问题，多的九部介绍了，有兴趣的本有可以自己实践以下&nbsp;&nbsp;iv.使用标签的方式，这样的话就可以保正使用真正的ajax(动态网站静态化)来跨域，并且可以使用返回来的数据，在我们的后台程序处理后的到的结果都直接的用javascript 的方式返回，在我们的html中直接的使用返回数据的变量就可以了]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>笔试面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-promise]]></title>
    <url>%2F2017%2F01%2F13%2FES6-promise%2F</url>
    <content type="text"><![CDATA[## 含义：Promise是一个对象，从它可以获取异步操作的消息。它有两个特点： 1.对象的状态不受外界影响：Promise对象代表一个异步曹组，有三种状态：pending（进行中），Resolved（已完成），Rejected(已失败)。只有异步操作的结果才能决定当前是哪一种状态，其他操作都无法改变这个状态。 2.一旦状改变就不会再变。一旦状态幼pending转变为Resolved或者Rejected之后，就不会再变，会一直保持这个结果。 优点：有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise的基本实现:123456var promise = new Promise(function(resolve,reject)&#123; if(异步操作成功)&#123;| resolve(value) &#125;else reject(error)&#125;) Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数 1promise.then(function(value)&#123;&#125;,function(error)&#123;&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Rejected时调用。其中，第二个函数是可选的，不一定要提供。 示例1123456789101112function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;timeout(1000).then(() =&gt; &#123; console.log(&quot;haha&quot;);&#125;);Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;haha 示例212345678910var promise=new Promise((resolve,reject)=&gt;&#123; console.log(1); resolve();&#125;);promise.then(()=&gt;&#123;console.log(2)&#125;);console.log(3);VM505:2 1VM505:6 3VM505:5 2 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);结果：2 1 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给then方法的回调函数。 ##Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 1234567891011121314var promise = new Promise(function(resolve, reject) &#123;// console.log(&quot;haha&quot;);// resolve(4); throw new Error(&apos;test&apos;);&#125;);promise.then((value)=&gt;&#123;console.log(value)&#125;).catch(function(error) &#123; console.log(error);&#125;);结果：Error: test at &lt;anonymous&gt;:4:9 at Promise (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:15 若在此之前调用resolv()方法，则不会catch到错误，因为得到Resolved状态后，状态不会再改变。 Promise.all()Promise.all方法接受一个数组作为参数Promise.all([p1,p2,p3])，p1、p2、p3都是 Promise 实例。 p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Demo：同时并发现象（一次性计算10个数）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function add(a, b, cb)&#123; setTimeout(function()&#123; cb(a + b); &#125;, 1000);&#125;function addQ(a, b)&#123; return new Promise((resolve, reject) =&gt; &#123; add(a, b, function(result) &#123; resolve(result); &#125;); &#125;);&#125; let running = false, i = 0, task = [];let timerID = setInterval(() =&gt; &#123; if(running) &#123; return; &#125; running = true;// 任务结束条件 if(i == 10) &#123; running = false; clearInterval(timerID); Promise.all(tasks) .then((results) =&gt; &#123; console.log(results); &#125;); &#125; //任务可以继续 let task = addQ(i, 2) .then((result) =&gt; &#123; return addQ(3, result); &#125;) .then((result) =&gt; &#123; return addQ(4, result); &#125;) .then((result) =&gt; &#123; running = false; return result; &#125;); tasks.push(task); i++;&#125;, 200);add(1, 2, function(result)&#123; add(result, 3, function(result)&#123; add(result, 4, function(result)&#123; console.log(result); &#125;); &#125;);&#125;);]]></content>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js知识]]></title>
    <url>%2F2017%2F01%2F12%2F%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[删除自身元素12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=&quot;J_container&quot;&gt; &lt;div class=&quot;record-head&quot;&gt; &lt;div class=&quot;head id&quot;&gt;序号&lt;/div&gt;&lt;div class=&quot;head name&quot;&gt;姓名&lt;/div&gt;&lt;div class=&quot;head sex&quot;&gt;性别&lt;/div&gt;&lt;div class=&quot;head tel&quot;&gt;电话号码&lt;/div&gt;&lt;div class=&quot;head province&quot;&gt;省份&lt;/div&gt;&lt;div class=&quot;head&quot;&gt;操作&lt;/div&gt; &lt;/div&gt; &lt;ul id=&quot;J_List&quot;&gt; &lt;li&gt;&lt;div class=&quot;id&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;name&quot;&gt;张三&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt;&lt;div class=&quot;tel&quot;&gt;13788888888&lt;/div&gt;&lt;div class=&quot;province&quot;&gt;浙江&lt;/div&gt;&lt;div class=&quot;user-delete&quot; &gt;删除&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;id&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;name&quot;&gt;李四&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;女&lt;/div&gt;&lt;div class=&quot;tel&quot;&gt;13788887777&lt;/div&gt;&lt;div class=&quot;province&quot;&gt;四川&lt;/div&gt;&lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div class=&quot;id&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;name&quot;&gt;王二&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt;&lt;div class=&quot;tel&quot;&gt;13788889999&lt;/div&gt;&lt;div class=&quot;province&quot;&gt;广东&lt;/div&gt;&lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt;// 此处也可换成ES6的写法function Contact()&#123; this.init();&#125;var _ul = document.getElementsByTagName(&apos;ul&apos;)[0];var _li = _ul.getElementsByTagName(&apos;li&apos;);var _delete = document.getElementsByClassName(&quot;user-delete&quot;);// console.log(_li[1].parentNode.removeChild(_li[1]));// console.log(_li[0].childNodes[5]===_delete[0])for(var i=0;i&lt;_li.length;i++)&#123; _delete[i].onclick=function()&#123; this.parentNode.parentNode.removeChild(this.parentNode); &#125;&#125;//删除元素自己本身，利用this.parentNode.removeChild(this);//删除元素父类，利用this.parentNode.parentNode.removeChild(this.parentNode); &lt;/script&gt; 原生Ajax的实现1.1234567var xmlHttp;function createxmlHttpRequest()&#123;if(window.ActiveXObject)&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;else if(window.XMLHttpRequest) xmlHttp=new XMLHttpRequest();&#125; 2.GET方法 123456789101112function doGet(url)&#123;//注意在传参数值的时候最好使用encodeURI处理一下，防止乱码 createxmlHttpRequest(); xmlHttp.open(&quot;GET&quot;,url); xmlHttp.send(null); xmlHttp.onreadystatechange=function()&#123; if(xmlHttp.readyState==4&amp;&amp;xmlHttp.status==200)&#123; alert(&apos;success&apos;); &#125;else&#123; alert(&apos;fail&apos;); &#125; &#125;&#125; 其中url的格式为： 1.传递的参数必须在？后指定，多个参数时用&amp;分隔。 2.GET方法请求同一URL时会有缓存，通过参数是否一致来判断 3.解决缓存问题，价格时间戳即可，使得每次的参数不一致 具体方式：1url+Math.random() 2.POST方法 12345678910111213function doPost(url,data)&#123;//注意在传参数值的时候最好使用encodeURI处理一下，防止乱码 createxmlHttpRequest(); xmlHttp.open(&quot;POST&quot;,url); xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlHttp.send(data); xmlHttp.onreadystatechange=function()&#123; if(xmlHttp.readyState==4&amp;&amp;xmlHttp.status==200)&#123; alert(&apos;success&apos;); &#125;else&#123; alert(&apos;fail&apos;); &#125; &#125;&#125; 这里注意： 1.POST方法没有缓存 2.POST方法发送数据量大 3.Ajax无法发送文件 4.readyState改变时触发onreadystatechange事件，4为完成。 5.status是返回状态，200便是成功，404是找不到页面 6.responseText是返回的数据，为字符串格式 JsonJSON(JavaScript Object Notation, JS 对象标记） JSON 和 JS 对象互转 要实现从对象转换为 JSON 字符串，使用 JSON.stringify() 方法：1var json = JSON.stringify(&#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;); //结果是 &apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos; 要实现从 JSON 转换为对象，使用 JSON.parse() 方法：1var obj = JSON.parse(&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;); //结果是 &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125; 优点：书写简单，一目了然；符合JavaScript原生语法，可以由解释引擎直接处理，不用另外添加解析代码。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Git命令]]></title>
    <url>%2F2017%2F01%2F12%2Fcommon-knowledge%2F</url>
    <content type="text"><![CDATA[Git需要掌握的命令：git branch（列出所有本地分支） git init （在当前目录新建一个git代码库） git add -a （添加指定文件到暂时存在的地方） git commit （可以将已经标识的内容提交到本地仓库） git commit -a （提交工作区从上次commit之后的变化，直接到仓库内） git commit -m （提交暂存区到仓库内） git checkout -b 分支名称 （可以创建自己的分支，一般情况下分支名称用你的名字拼音） git remote add 源名称 https网址 （在本地初始化的仓库中配置远程服务器地址和源名称） git checkout 分支名称 （切换至本地已经存在的分支） git push 源名称（origin） 分支名称 （将本地分支名称发送到远程服务器） git pull 源名称 分支名称 （将远程服务器指定分支下载到本地，如果与当前分支有冲突需合并） git merge 分支名称 （将指定的分支合并到当前分支） git clone [url] （下载一个项目和他的整个历史代码） git status （显示有变更的文件） git log （查看当前分支的历史版本） *.gitignore文件可以标记当前路径中哪些文件可以不进行git管理。为了避免将依赖代码和自己开发代码一起审核的混乱，我们一般会忽略node_modules和bower_components目录，同时也会忽略.DS_STORE这种操作系统缓存文件。 node.js含义：nodejs 是一个将Google V8 Javascript引擎与封装给Javascript使用的系统API集合，nodejs还提供了npm包管理工具来管理依赖包关系，cnpm是npm工具的国内版本，下载速度更快。 Npm含义：npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）。 npm init命令可以初始化当前路径，建立package.json，通过npm install 包名称 可以将工具安装到当前目录的node_modules中，通过sudo npm install -g 包名称可以讲工具安装到全局（也就是任意目录下均可以使用）；通过–save,–save-dev参数分别可以将依赖包标记为运行时依赖和开发阶段依赖。 Cnmp的含义：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 Bower的含义：bower init命令可以初始化当前路径的前端包依赖，建立bower.json，通过bower install包名称可以安装前端包到bower_components目录中； 通过–save,–save-dev参数分别可以将依赖包标记为运行时依赖和开发阶段依赖。]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习经历]]></title>
    <url>%2F2017%2F01%2F12%2Fyopu%2F</url>
    <content type="text"><![CDATA[前端发布（打版本到服务器）打开项目文件（此文件不能做任何添加和改动，复制文件命名）git pull origin masterrun deploy:prod （命令结束之后会在文件夹下生成一个新文件dist目录）桌面上找到服务器进去（user01软件）选择左边的站点进入/root/var/www/html删除除了pmn以外的文件复制dist中的所有文件到/var/www/html内]]></content>
      <categories>
        <category>基本知识</category>
      </categories>
      <tags>
        <tag>基本知识</tag>
      </tags>
  </entry>
</search>